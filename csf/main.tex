% Fixing: Too many math alphabets used in version normal.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\documentclass[dvipsnames,conference]{IEEEtran}

\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage[switch]{lineno}
\usepackage{fontawesome5}
\usepackage{listofitems}
\usepackage{glossaries}
\usepackage{orcidlink}
\usepackage{cleveref}
\usepackage{stmaryrd}
\usepackage{marvosym}
\usepackage{listings}
\usepackage{xspace}
\usepackage{xfrac}
\usepackage{tikz}
\usepackage{soul}
\usepackage{bm}

\setul{0.95ex}{0.3ex}

% https://tex.stackexchange.com/questions/648845/sans-serif-uppercase-greek-no-longer-showing-in-acmart
\DeclareMathAlphabet{\mathsf}{OT1}{LibertinusSans-LF}{m}{n}
\SetMathAlphabet{\mathsf}{bold}{OT1}{LibertinusSans-LF}{bx}{n}

\DeclareMathAlphabet{\mathtt}{OT1}{lmtt}{m}{n}
\SetMathAlphabet{\mathtt}{bold}{OT1}{lmtt}{bx}{n}

\input{cmds.tex}

\loadglsentries{acronyms}
\makeglossaries

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}
\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\renewcommand\thelinenumber{\color{red}\arabic{linenumber}}
\begin{document}
\linenumbers

\title{Secure Composition of Robust and Optimising Compilers}

\author{\IEEEauthorblockN{1\textsuperscript{st} Matthis Kruse\orcidlink{0000-0003-4062-9666}}
\IEEEauthorblockA{\textit{CISPA and Saarland University} \\
Saarbr\"ucken, Germany \\
matthis.kruse@cispa.de}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Michael Backes}
\IEEEauthorblockA{\textit{CISPA} \\
Saarbr\"ucken, Germany \\
director@cispa.de}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Marco Patrignani\orcidlink{0000-0003-3411-9678}}
\IEEEauthorblockA{\textit{Trento University} \\
Trento, Italy \\
marco.patrignani@unitn.it}%
}

\maketitle

\begin{abstract}
% \MPpost{
%   this abstract fails in setting up the robustness argument.
%   it'll be a good exercise for you to take inspiration from this, but then write something as concise but with a more direct focus on robust properties
% }
% context
To ensure that secure applications do not leak their secrets, they are required to uphold several security properties such as spatial and temporal memory safety as well as cryptographic constant time.
% need
Existing work shows how to enforce these properties individually, in an architecture-independent way, by using secure compiler passes that each focus on an individual property.
% task
Unfortunately, given two secure compiler passes that each preserve a possibly different security property, it is unclear what kind of security property is preserved by the composition of those secure compiler passes.
%there is no way to tell what kind of security property will the composition of those secure compilers preserve.

% object
This paper is the first to study what security properties are preserved across the composition of different secure compiler passes.
% findings
Starting from a general theory of property composition for security-relevant properties (such as the aforementioned ones), this paper formalises a theory of composition of secure compilers.
Then, it showcases this theory on a secure multi-pass compiler that preserves the aforementioned security-relevant properties.
% conclusion
Crucially, this paper derives the security of the multi-pass compiler from the composition of the security properties preserved by its individual passes, which include security-preserving as well as optimisation passes.
% 
From an engineering perspective, this is the desirable approach to building secure compilers.


  % \MKin{context}
  % Memory safety necessitates secrecy, since breaking it can lead to an arbitrarily large attack space, i.e., from simply reading a secret up to alteration of control-flow in order to execute arbitrary code.
  % However, secrecy cannot be achieved with just memory safety alone, since, e.g., private data could be leaked by differences in execution time for varying program inputs.
  % This leakage is avoidable by ensuring that programs are cryptographic constant time, i.e., different inputs do not change execution time.
  % Prior work has shown that strategies to ensure cryptographic constant time can be rendered useless, since a compiler may simply optimize them away.
  % \MKin{need}
  % This is why secure compilation is an integral ingredient to achieve security, because a secure compiler guarantees (formally) that properties that hold in the source, also hold in the target. %% mention attacker? the text describes correctness
  % \MKin{task}
  % Unfortunately, it is an open question whether secure compilers can be engineered in a modular way.
  % Ideally, compiler engineers develop two different compilation passes, one that ensures memory safety and another one that is security preserving with respect to cryptographic constant time. %, because this style of engineering is well-established for its simplifying divide-and-conquer approach as well as enhanced reusability.
  % \MKin{object+findings}
  % This paper answers that question positively: The composition of compilers that are secure with respect to some security-properties yields the intersection of these properties.
  % \MKin{object}
  % This article discusses different variants of compositions of secure compilers and instantiates parts of these results in a case-study.
  % To this end, it presents an optimizing, secure compilation chain that preserves both memory safety and cryptographic constant time.
  % \MKin{conclusion}
  % The compositionality results enable modular proofs for the presented, secure compiler. % that is secure with respect to both memory safety and cryptographic constant time.
  % Some results of this work are implemented in the Coq proof assistant.

\begin{center}\small\it
	{This paper uses syntax highlighting accessible to both colourblind and black \& white readers.
	% ~\citep{patrignani2020use}.
% 	% Specifically, it makes use of a $\src{blue}$, $\src{sans\text{-}serif}$ font for a $\src{source}$,
% 	% a $\trg{red}$, $\trg{bold}$ font for an $\trg{intermediate}$,
% 	% and a $\obj{green}$, $\obj{teletype}$ font for a $\obj{target}$ language.
	}
\end{center}
\end{abstract}

\begin{IEEEkeywords}
  memory-safety, secure compilation, privacy
\end{IEEEkeywords}

\section{Introduction\pages{4}}\label{sec:introduction}

\cite{patrignani2020use}



\section*{Acknowledgements}\label{sec:acks}

\bibliographystyle{IEEEtran}
\bibliography{main}

%%
%% If your work has an appendix, this is the place to put it.
\appendix

\end{document}
\endinput
