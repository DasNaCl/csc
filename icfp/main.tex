\PassOptionsToPackage{dvipsnames}{xcolor} % Added for new colors.
% Fixing: Too many math alphabets used in version normal
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\documentclass[acmsmall]{acmart}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage[T1]{fontenc}
\usepackage[scaled=.83]{beramono}

\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage[dvipsnames]{xcolor}
\usepackage[switch]{lineno}
\usepackage{halloweenmath}
\usepackage{fontawesome5}
\usepackage{listofitems}
\usepackage{breakcites}
\usepackage{glossaries}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{stmaryrd}
\usepackage{marvosym}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{nameref}
\usepackage{amsthm}
\usepackage{xspace}
\usepackage{xfrac}
\usepackage{tikz}
\usepackage{soul}
\usepackage{bm}
\usepackage{paralist}

\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%\newcommand{\url}[1]{\lstinline{#1}}

\setul{0.95ex}{0.3ex}

\input{cmds.tex}

% allow page breaks inside multiline alignment displays
\allowdisplaybreaks

\Crefname{exampleenv}{Example}{Examples}

\theoremstyle{definition}
\newtheorem{exampleenv}{Example}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{definition}{Definition}[section]

\loadglsentries{acronyms}
\makeglossaries
\renewcommand\thelinenumber{\color{red}\arabic{linenumber}}
\begin{document}
\linenumbers
\title{
  Secure Composition of Robust and Optimising Compilers
}

\author{Matthis Kruse}
\affiliation{%
   \institution{Saarland University and CISPA}
   \city{Saarbr\"ucken}
   \state{Saarland}
   \country{Germany}}
\email{matthis.kruse@cispa.de}
\author{Marco Patrignani}
\affiliation{%
   \institution{Trento University}
   \city{Trento}
   \state{South Tyrol}
   \country{Italy}}
\email{marco.patrignani@unitn.it}
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Kruse and Patrignani}

\begin{abstract}
% \MPpost{
%   this abstract fails in setting up the robustness argument.
%   it'll be a good exercise for you to take inspiration from this, but then write something as concise but with a more direct focus on robust properties
% }
% context
To ensure that secure applications do not leak their secrets, they are required to uphold several security properties such as spatial and temporal memory safety, cryptographic constant time, as well as speculative safety.
% need
Existing work shows how to enforce these properties individually, in an architecture-independent way, by using secure compiler passes that each focus on an individual property.
% task
Unfortunately, given two secure compiler passes that each preserve a possibly different security property, it is unclear what kind of security property is preserved by the composition of those secure compiler passes.
%there is no way to tell what kind of security property will the composition of those secure compilers preserve.

% object
This paper is the first to study what security properties are preserved across the composition of different secure compiler passes.
% findings
Starting from a general theory of property composition for security-relevant properties (such as the aforementioned ones), this paper formalises a theory of composition of secure compilers.
Then, it showcases this theory on a secure multi-pass compiler that preserves the aforementioned security-relevant properties.
% conclusion
Crucially, this paper derives the security of the multi-pass compiler from the composition of the security properties preserved by its individual passes, which include security-preserving as well as optimisation passes.
% 
From an engineering perspective, this is the desirable approach to building secure compilers.
% \begin{center}\small\it
% 	{This paper uses syntax highlighting accessible to both colourblind and black \& white readers.
% 	% ~\cite{patrignani2020use}.
% % 	% Specifically, it makes use of a $\src{blue}$, $\src{sans\text{-}serif}$ font for a $\src{source}$,
% % 	% a $\trg{red}$, $\trg{bold}$ font for an $\trg{intermediate}$,
% % 	% and a $\obj{green}$, $\obj{teletype}$ font for a $\obj{target}$ language.	
% 	For a better experience, please print or view in colours.
% 	}
% \end{center}
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>00000000.0000000.0000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Do, Not, Us, This, Code, Put, the, Correct, Terms, for,
  Your, Paper}

\received{20 February 2007}
\received[revised]{12 March 2009}
\received[accepted]{5 June 2009}

\maketitle

\input{sections/intro.tex}
\input{sections/background.tex}
\input{sections/compo.tex}
\input{sections/prop.tex}
\input{sections/langs.tex}
\input{sections/csc.tex}








\section{Formal Insights}\label{sec:formalities}

This section discusses how to connect each language-specific security property to the general security properties of \Cref{sec:compprop} (\Cref{subsec:formalities:maps}), and it demonstrates that the security property resulting from the universal image projection is faithful to the original property (\Cref{subsec:formalities:props}). 
% 
Then, this section discusses why the order of compiler passes matters, and how does our framework help with identifying insecure compositions (\Cref{subsec:compatsecpasses}), and it gives additional technical insights on the secure compilation proofs (\Cref{subsec:seccompproofs}).

\subsection{From Language Traces to General Ones}\label{subsec:formalities:maps}

The previous theorems talk about preserving properties expressed in the trace model of the languages of each compiler.
However, these trace models are not the same trace model we used to specify the properties of \Cref{sec:compprop} (indicated with \ev{L}), which serves as the ``ground truth'' for the meaning of our properties.
% 
To bridge this gap, the formal development requires specifying additional trace relations, from each of the language trace models to the \ev{L} one, that, for example, relate $\src{Get\ \loc\ n}$ and $\src{Set\ \loc\ n}$ to $\ev{Use\ \loc\ n}$ (and that induce a related universal image that we use in \Cref{subsec:formalities:props}).
% 
One key insight of these relations is that they all omit context-made actions for two reasons: (1) contexts (which are universally quantified) can trivially invalidate any property and (2) we are interested in the component upholding the properties.
% 

 % disregarded a glaring but minor technical issue: take $\tmssafe$ (\Cref{def:trace:tmsdef}) as an example.
% It contains traces as specified in \Cref{subsec:basic:memsafety:tracemodel}.
% However, these are different from $\Ltms$ traces (\Cref{subsec:ltms}) which means that \Cref{thm:wt:tms} is ``ill-typed''.
% Similarly for the other theorems.
% In the interest of reducing visual baggage, the notation left out yet another cross-language trace relation, translating language-specific traces into these non-language specific traces. 
% In doing so, context-level actions are dropped and, e.g., both $\src{Get\ \loc\ n}$ and $\src{Set\ \loc\ n}$ are translated into $\ev{Use\ \loc\ n}$.


\subsection{Security Properties and Their Meaning}\label{subsec:formalities:props}
Each of the presented compilers uses a cross-language trace relation, which is also used to translate the property from one language to the other one (via the existential or universal images).
% 
%Whenever such translations occur, it is important to check whether there has been a change of meaning.
%Secure compiler engineers need to ensure that such translations of properties do not change meaning in a fundamental wrong way. 
% lifting or lowering reasoning from target- to source-level or vice-versa,
While the meaning of projected properties does change with a translation, the change should not allow for a flawed compilation pipeline.
% 
For example, we could be using a trace relation that translates a property in a language to a totally different one in another language.
% 
To raise the trust into the translation of properties, \Cref{thm:prop-rel-corr} states (in a general fashion) that each security property is faithfully translated using the universal image according to the cross-language trace relation induced by the compiler.

\begin{theorem}[Properties Relation Correctness]\label{thm:prop-rel-corr}
  \begin{align*}
    \forall& \pi \in \{\tmssafe,\smssafe,\scctsafe,\sssafe\}, 
    \\
    \text{ for each }& \text{pair of languages } \src{L} \text{ and } \trg{L} \text{ used by the compilers},
    \\
    \text{ if }& 
    % \tau_{\sim^{\trg{L}}_{\ev{L}}}(\pi) \sim^{\trg{L}}_{\ev{L}} \pi
    \sigma_{\sim^{\trg{L}}_{\ev{L}}}(\pi) \sim^{\trg{L}}_{\ev{L}} \pi
    \text{ and } 
    % \sigma_{\sim^{\src{L}}_{\trg{L}}}(\tau_{\sim^{\trg{L}}_{\ev{L}}}(\pi)) \sim^{\src{L}}_{\trg{L}} \tau_{\sim^{\trg{L}}_{\ev{L}}}(\pi)
    \sigma_{\sim^{\src{L}}_{\trg{L}}}(\sigma_{\sim^{\trg{L}}_{\ev{L}}}(\pi)) \sim^{\src{L}}_{\trg{L}} \sigma_{\sim^{\trg{L}}_{\ev{L}}}(\pi)
    \\
    \text{ then }& 
    % \tau_{\sim^{\src{L}}_{\ev{L}}}(\pi) = \sigma_{\sim^{\src{L}}_{\trg{L}}}(\tau_{\sim^{\trg{L}}_{\ev{L}}}(\pi)) 
    \sigma_{\sim^{\src{L}}_{\trg{L}}}(\sigma_{\sim^{\trg{L}}_{\ev{L}}}(\pi)) \sim^{\src{L}}_{\ev{L}} \pi
  \end{align*}
\end{theorem}
The complexity of this theorem is that the relation in the conclusion cannot be obtained by composing the two relations in the premises.
% 
%% MK: the following does not say anything about the theorem, only about the syntactic compiler
%What happens in practice is that compiler engineers are given the relations from each language to \ev{L} and they need to build a compiler that induces a relation $\sim^{\src{L}}_{\trg{L}}$ that respects this theorem.
% 

We now informally argue why this theorem holds for the composition of all considered properties from \Cref{sec:compprop}.

\paragraph{$\sigma_{\sim^{\Ltms}_{\Lms}}\left(\tmssafe\cap\smssafe\cap\scctsafe\cap\sssafe\right)$}

For the four properties considered here, the trace models of $\Ltms$, $\Ltrg$, and $\Lms$ do not consider actions related to $\scctsafe$ and $\sssafe$, so these two properties are trivially translated correctly.
% 
We now discuss the remaining $\tmssafe$ and $\smssafe$ in the form of their intersection $\mssafe$.

Recall that $\sim^{\Ltms}_{\Lms}$ is the composition of $\sim^{\Ltms}_{\Ltrg}$ and $\sim^{\Ltms}_{\Lms}$.
% 
Since $\sim^{\Ltms}_{\Ltrg}$ is an equality, this relation trivially preserves the meaning of translated properties: related traces are identical!

Finally, let us consider a trace $\irl{\trace}\in\mssafe$ and understand what is related to via $\sim^{\Ltrg}_{\Lms}$.
% 
{\em All} traces $\trg{\trace}$ with $\trg{\trace}\sim^{\Ltrg}_{\Lms}\irl{\trace}$ are identical to $\irl{\trace}$ except for get and set actions, which require for in-bound accesses (as stated in \Cref{subsec:cs:ms}): this clearly respect $\mssafe$.
% 

% In both cases, the translated event does not represent an out-of-bounds memory access. 

% \footnote{Both $\sim^{\Ltms}_{\Ltrg}$ and $\sim^{\Ltrg}_{\Lms}$ filter context actions.}.

% Now, starting from $\mssafe$ expressed in $\Lms$, we check that its translation in $\Ltms$ is still $\mssafe$.
% % 
% We can see that the property resulting from the projection of $\Lms$ traces back to $\Ltms$ faithfully models $\mssafe$, which translates to both $\scctsafe$ and $\sssafe$, 
% \MPin{ equiv  +  other rel only adds traces that fail }
% since these properties trivially hold for $\Ltms$, $\Ltrg$, and $\Lms$ traces.


\paragraph{$\sigma_{\sim^{\Lms}_{\Lscct}}\left(\tmssafe\cap\smssafe\cap\scctsafe\cap\sssafe\right)$}

As before, the trace models of $\Lscct$ and $\Lms$ cannot express $\sssafe$, so that is trivially translated correctly.
% 
Also, the trace model of $\Lscct$ extends the one of $\Lms$ with respect to $\tmssafe$ and $\smssafe$ events, so the translation argument regarding those two properties is the same as before.
% 
Thus, we need to reason about whether $\scctsafe$ is translated correctly.

By definition, $\sim^{\Lms}_{\Lscct}$ only relates $\obj{\unlock}$ events, which is also the same relation induced by $\sim_{\ctsafe}$ in \Cref{sec:msscct-rel}.
% 
This ensures that composing the relations only relates $\unlock$ events, and thus the property is translated correctly.

% Consider a trace $\obj{\trace}\in\scctsafe$ and all $\irl{\trace}$ such that $\irl{\trace}\sim^{\Lms}_{\Lscct}\obj{\trace}$. 
% In turn, $\obj{\trace}$ cannot contain any leaks of secret values, so it cannot violate $\scctsafe$.
% Toggling data-independent timing mode has no impact on $\mssafe$ or $\sssafe$.

\paragraph{$\sigma_{\sim^{\Lscct}_{\Lspec}}\left(\tmssafe\cap\smssafe\cap\scctsafe\cap\sssafe\right)$}
The trace model of $\Lspec$ extends the one of $\Lscct$ with respect to $\tmssafe$, $\smssafe$, and $\scctsafe$, so the translation argument for those three properties is the same as before.
% 
Concerning $\sssafe$, $\sim^{\Lscct}_{\Lspec}$ relates $\Lspec$ speculation traces with $\Lscct$ branches with the $\lock_{\text{NONE}}$ tag, so the property is translated correctly, according to the relation defined in \Cref{sec:spec-ms-rel}.
 % introducing $\ird{barrier}$ never violates $\sssafe$ and has no effect on $\mssafe$ or $\scctsafe$.

%\MPin{
%	can this be made formal?
%	what's the point?
%}

\subsection{Compatibility of Secure Compiler Passes}\label{subsec:compatsecpasses}

% \Cref{thm:rtpsim:sig} is applicable, up to the well-formedness of $\sim_1$ w.r.t. $\trg{\class[_2]}$.
Consider applying $\ccspec$ first and then $\ccb$ (albeit currently syntactically impossible).
% , let us pretend that it is possible by just extending $\ccb$ for the constructs present in $\Lscct$ that are not present in $\Ltrg$.
% Clearly, as evidenced earlier (\Cref{subsec:formalities:props}), $\ccb\cdot\ccspec$ is an acceptable composition that yields an interesting class of security properties, i.e., $\sigma_{\sim_{\irl{ms}}\bullet\sim_{\ird{\mathghost}}}\left(\mssafe\cap\scctsafe\cap\sssafe\right)$. 
In this case, $\ccb$ would insert new branches into the code that are not protected by a speculation barrier! 
This concern is reflected in the proofs that establish that the security class resulting of the composition of the trace relations is meaningful.
% , much similar to ensuring that a definition models what the formal methods expert intends to model. 
For the $\ccspec\cdot\ccb$ case, the class is $\sigma_{\sim_{\ird{\mathghost}}\bullet\sim_{\irl{ms}}}\left(\mssafe\cap\scctsafe\cap\sssafe\right)$.
Since $\ev{Use\ \loc\ n}\sim_{\irl{ms}}\irl{Branch\ n}\cdot\irl{Spec}\cdots$, where $\cdots$ does not contain a $\ev{{Barrier}}$ event, the resulting class is \emph{not} the original $\sssafe$ that is intended and it would break the corresponding \Cref{thm:prop-rel-corr}.
% Because of this, it is crucial to analyse the precise shape of the class of properties after mapping a target-level property to a source-level property\footnote{Dito for mapping a source-level property to a target-level property.}.

However, the composition is still technically possible and it is the job of the compiler engineers to ensure that the secure compilation pipeline happens in an order that ensures that the mapped security property is the intended one.

\subsection{Secure Compilation Proofs}\label{subsec:seccompproofs}

Our secure compilation proofs rely on backtranslations~\cite{abate2019jour,patrignani2021rsc}, which let one construct a source context starting from either target traces (aka trace-based backtranslations) or target contexts (aka context-based backtranslations).
These backtranslations also require setting up cross-language relations between various language elements such as expressions and program states, so we leave these details for the technical reports.
% , the usual strategy is to establish a backwards simulation between source components and their compiled target counterpart. 
% For the universally quantified target context, a technique known as backtranslation is well-established, which constructs a source-level context either by backtranslating the target-level context, amounting to a ``decompilation'', or by constructing it using the target-level trace, so that the source-context emits parts of the whole execution trace that are related to the parts emitted by the target-level context. 
All backtranslations in the case-study are trace based except for those required by $\ccdce$ and $\cccf$, which are context-based (and they are an identity function). 
% Since these optimisations have no significant semantic effect and source- and target-language are equal, the backtranslation amounts to an identity translation. 

\section{Related Work\pages{2}}\label{sec:relwork}

This section discusses robust compilation, other secure compilation criteria and work related to the properties preserved in the case study.
% (\Cref{subsec:relw:seccomprtp}) 
% (\Cref{subsec:relw:seccompcrit}).
% Since the case study of \Cref{sec:casestud:defs,sec:casestud:rtp} implements measures for preserving \gls*{ms}, \gls*{cct}, and \gls*{ss}, 
% Then, this section discusses work related 
% relevant related work as well 
% (\Cref{subsec:relw:msmechs,subsec:relw:cctmechs,subsec:relw:ssmechs}).

\paragraph*{Secure Compilation as Robust Preservation}\label{subsec:relw:seccomprtp}

The robust preservation of properties as a compiler-level criterion has been analysed extensively~\cite{abate2019jour,patrignani2021rsc,abate2021extacc,patrignani2019survey} and thus we build on that framework.
No existing work is concerned with composing secure compilers, however, existing work~\cite{abate2021extacc} sketches composition of trace-relating compiler correctness in a similar way to what has been presented here.
%Parts of these works consider languages with different trace models and our technical setup can handle this. 
The work relating robust preservation with universal composability~\cite{patrignani2022universal} is closest to what this paper presents.
% 
The authors demonstrate a similar compositionality theorem to ours (\Cref{sec:sequential}) but use it in the context of protocols.
% 
The work does not consider the generality to support different trace models or composition of compilers which robustly preserve different classes.
% The authors demonstrate a similar compositionality theorem to what is presented here (\Cref{sec:sequential}) as well as in an earlier version of this work~\cite{kruse2022csc}.
% However, they do not demonstrate the scalability of the approach by means of a case study.

%\paragraph*{Composition of Secure Compilers}\label{subsec:relw:seccompcomp}

There is work on lifting exploits for single compilers to the whole chain~\cite{paykin2019weird}.
%Our framework does not consider exploits.
%\MP{ a bit dry and short}
While that work considers {\em in}secure compilation and composition thereof in terms of exploits, the composition they are interested in allows to lift an exploit for one compiler pass to the whole compilation chain. 
Our framework takes the opposite direction and provides compositionality results for secure compilers.
%
%
%To the best of our knowledge, there does not exist published work discussing the compositionality of the robust preservation criterion, the gold-standard of secure compilation.

\paragraph*{Other Secure Compilation Criteria}\label{subsec:relw:seccompcrit}

While this paper focuses on the robust preservation framework~\cite{abate2019jour}, other secure compilation criteria exist.
The survey on formal approaches to secure compilation~\cite{patrignani2019survey} discusses a broad spectrum already, while this section presents a very high-level overview.
Fully abstract compilation~\cite{abadi1999fullabstraction} states that a compiler should preserve and reflect observational equivalence between source and target programs.
Abate \emph{et al.}~\cite{abate2021faandrc} showed that fully abstract compilers robustly preserve program properties that are either trivial or meaningless.
As a mitigation for this, the authors presented a categorical approach based on maps of distributive laws~\cite{watanabe2002modl}, which they call many maps of distributive laws.
Maps of distributive laws have been investigated before as a possible secure compilation criterion~\cite{tsampas2020catsc}.
Other approaches are extensions of the compiler correctness criterion as discussed in other work~\cite{patterson2019next700} or the introduction of opaque observations~\cite{vu2021reconciling} to reconcile compiler optimisations with security.
Note that this work also presents secure compilers that are optimising, but contrary to the other~\cite{vu2021reconciling}, provides a formal account of these in the robust preservation framework.
% Lastly, the authors of this paper have presented ongoing work~\cite{patrignani2023blame} on a weaker robust preservation criteria based on the concept blame.

\paragraph*{Memory Safety Mechanisms}\label{subsec:relw:msmechs}

Different mechanisms for enforcing memory safety exist that also consider the secure compilation domain, i.e., have an active attacker model.
For example, the ``pointers as capabilities'' principle represents pointers as machine-level capabilities~\cite{korashy2021capableptrs}, which behave in a similar fashion to capabilities by means of linear typing~\cite{morrisett2005L3}.
The approach of this paper also uses linear typing, but differs from $L^{3}$~\cite{morrisett2005L3} in the way that functions are not first-class.
Moreover, this paper considers an active attacker, while the work on $L^{3}$ only discusses whole programs and, thus, has no active attacker model.
The instrumentation to ensure memory safety that this paper presents is inspired by Softbounds~\cite{nagarakatte2009soft}.
That work inserts bounds-checks in front of pointer-dereferences and, for this to work, inserts meta-data information on pointer creation.
Softbounds also works in a more advanced setting with structured fields accesses and also introduces a table-lookup for pointers that are stored in memory.
This paper only considers arrays of primitive data, i.e., there are no pointers to pointers or structures.
Several other approaches to memory-safety exist in literature, specifically as compiler instrumentations~\cite{akritidis2009baggy,younan2010paricheck,jung2021pico,shankaranarayana2023tailcheck,dhumbumroong2020boundwarden,nam2019framer,zhou2023fatptrs}, hardware-extensions~\cite{kwon2013lowfat,saileshwar2022heapcheck,chen2023flexpointer,kim2023whistle}, or programming language extensions~\cite{elliott2018checkedc,li2022formalcheckedc,jim2002cyclone,elliott2015guilt,west2005cuckoo,weis2019fyr,benoit2019uniqueness}.
What differentiates this work from them is that this work uses known, compiler-based approaches to ensure memory-safety as a means to investigate secure compiler compositions.
This paper does not provide efficient memory-safety, but serves as a theoretical foundation for the secure compilation domain.

To extend the languages in this paper with a less restricted form of pointer arithmetic, the region colouring memory safety monitor presented in earlier work~\cite{michael2023mswasm} can be used.
The work presenting this monitor provides an approach for the robust preservation of memory safety compiling from C to WASM.
However, they do not discuss composition of secure compilers but rather investigate an instance of a secure compiler.

\paragraph*{Cryptographic Constant Time Mechanisms}\label{subsec:relw:cctmechs}

The approach to preserving cryptographic constant time in this paper is high-level, where a programming language exposes a way to switch the semantics to a data (operand) independent timing mode.
Since identifiers in $\Lscct$ are annotated with a secrecy tag, this approach is similar to others with information flow control.
For example, Vale~\cite{bond2017vale} uses Dafny to ensure constant-time assembly code, while Jasmin~\cite{almeida2017jasmin} makes use of the Coq proof assistant to reject non-constant-time programs.
CT-Wasm~\cite{watt2019ctwasm} enforces constant-timeness by means of a type system.
Different to the approach of this paper, these approaches necessitate that the programmer writes \gls*{cct} code.
An approach to allow programmers to write more high-level code is CryptOpt~\cite{kuepper2023cryptopt}, which generates efficient target-code by means of a randomised search.
This paper abstracts over concrete mitigation strategies and simply assumes that there is a flag to switch to a cryptographic-constant time execution mode.
This can be realised by employing the FaCT~\cite{cauligi2019fact} compiler, which translates common non-constant time code patterns to be constant-time, and the data (object) independent timing execution mode of modern processors.

\paragraph*{Speculation Safety Mechanisms}\label{subsec:relw:ssmechs}

This paper uses a taint-tracking mechanism inspired by existing work~\cite{guarnieri2018spectector,fabian2022automatic}.
These taints are used to express absence of any speculative leaks in \gls*{ss}~\cite{guarnieri2018spectector}. 
The semantics of $\Lspec$ hardcodes the kind of speculative leaks to just SPECTRE-PHT~\cite{kocher2019spectre}, but future work could use semantics composition~\cite{fabian2022automatic} to support more variants.
Note that our framework composes compilers and not semantics. 

%This work has taken inspiration in the sematics of $\Lspec$ and in \Cref{def:trace:ss} from recent formalisations~\cite{guarnieri2018spectector,fabian2022automatic}.
% \MPin{
%  we take SS from exorcising.
%  we do not take SNI from spectector because it is a hypersafety.
%  other work defined similar props. 
% }
% A subsequent line of work~\cite{fabian2022automatic} shows how to modularly define and compose formal semantics that models different speculative execution variants. 
% Recent work~\cite{fabian2024lift} demonstrates how to lift existing secure compilation proofs for security properties related to speculative execution to more powerful properties, i.e., properties defined for languages with a trace model that enables more vulnerabilities, such as combinations of different speculative execution exploits. 
% To this end, they define a lifting framework and demonstrate how a secure compilation proof for a weaker property can be lifted to a stronger one. 
% Contrary to the compositionality framework presented in this paper, these works are only concerned with composing semantics of the respective programming languages, while in this paper, the secure compilers themselves are composed.

\input{sections/conclusion.tex}

\newpage

\bibliographystyle{IEEEtranS}
\bibliography{main}

%%
%% If your work has an appendix, this is the place to put it.
\appendix
\subsection{Existential Image}\label{subsec:extimg}

\begin{definition}[Existential Image]
% [Existential and Universal Image]
\label{def:existential:img}\label{def:tau}
  \[
    \tau_\sim\left(\src{\pi}\right) := 
      \left\{ 
        \trg{\trace} \mid \exists \src{\trace}\ldotp \src{\trace}\sim\trg{\trace}, \text{ and } \src{\trace}\in\src{\pi} 
      \right\}
  \]
  %\[ 
  %  \sigma_\sim\left(\trg{\pi}\right) := 
  %    \left\{ 
  %      \src{\trace} \mid \forall \trg{\trace}\ldotp \text{if }\src{\trace}\sim\trg{\trace}, \text{ then } \trg{\trace}\in\trg{\pi} 
  %    \right\}
  %\]
\end{definition}

\begin{definition}[Robust Preservation with $\tau_\sim$]\label{def:rtp:tau}
  % $\;$\\
  % \vspace{-1em}
  % \begin{nscenter}
  % Compiler $\cc{\src{L}}{\trg{L}}$ robustly preserves $\class$, 
  {$\rtptau{\cc{\src{L}}{\trg{L}}}{\src{\class}}{\sim}$}
  %, iff 
  $\isdef$
    {$\forall \src{\pi}\in\src{\class}, \src{p}\in\src{L},$} if {$\rsat{\src{\progvar}}{\src{\pi}}$}, then {$\rsat{\cc{\src{L}}{\trg{L}}\left(\src{p}\right)}{\tau_\sim\left(\src{\pi}\right)}$}.
  % \end{nscenter}
\end{definition}

\begin{theorem}[Composition of Secure Compilers w.r.t. $\tau$]\label{thm:rtpsim:tau}
  $\;$ 

  If {$\rtptau{\cc{\src{L}}{\trg{L}}}{\src{\class[_{1}]}}{\sim_1}$}, {$\rtptau{\cc{\trg{L}}{\obj{L}}}{\tilde{\tau}_{\sim_1}\left(\src{\class[_2]}\right)}{\sim_2}$}, and {$\wfctau{\sim_1}{\src{\class[_2]}}$}, \\ then {$\rtptau{\cc{\src{L}}{\trg{L}}\circ\cc{\trg{L}}{\obj{L}}}{\src{\class[_{1}]}\cap\src{\class[_{2}]}}{\sim_1\bullet\sim_2}$}. \Coqed
\end{theorem}

\begin{corollary}[Swapping Secure Compiler Passes]\label{corr:swappable:tau}
  $\;$ 

  If {$\rtptau{\cc[_{1}]{\trg{L}}{\trg{L}}}{\src{\class[_{1}]}}{\sim_1}$ and $\rtptau{\cc[_{2}]{\trg{L}}{\trg{L}}}{\src{\class[_{2}]}}{\sim_2}$}, %
  {$\wfctau{\sim_1}{\src{\class[_2]}}$ and $\wfctau{\sim_2}{\src{\class[_1]}}$}, %
  and {$\tilde{\tau}_{\sim_1}\left(\src{\class[_2]}\right)=\src{\class[_2]}$ as well as $\tilde{\tau}_{\sim_2}\left(\src{\class[_1]}\right)=\src{\class[_1]}$},
  then {$\rtptau{\cc[_{1}]{\trg{L}}{\trg{L}}\circ\cc[_{2}]{\trg{L}}{\trg{L}}}{\src{\class[_{1}]}\cap\src{\class[_{2}]}}{\sim_1\circ\sim_2}$ and $\rtptau{\cc[_{2}]{\trg{L}}{\trg{L}}\circ\cc[_{1}]{\trg{L}}{\trg{L}}}{\src{\class[_{2}]}\cap\src{\class[_{1}]}}{\sim_2\circ\sim_1}$}. \Coqed
\end{corollary}

\subsection{Secure Upper and Lower Composition}\label{sec:other-compos}
Besides sequential composition, there are two other compositions, namely an {\em upper}, i.e., a compiler that takes multiple inputs and yields one output, and a {\em lower} composition, i.e., a compiler that takes one input and yields multiple outputs.
We {define the upper composition $\cc{\src{L}+\obj{L}}{\trg{L}}$} as follows:
Given a program \texttt{p}, its compiled counterpart is obtained by {plugging \texttt{p} into $\cc{\src{L}}{\trg{L}}$ if $\texttt{p}\in\src{L}$} or by {plugging \texttt{p} into $\cc{\obj{L}}{\trg{L}}$ if $\texttt{p}\in\obj{L}$}.
\begin{definition}[Upper Composition]
  \[
    \text{{$\cc{\src{L}+\obj{L}}{\trg{L}}$}}\isdef
  % Given \texttt{p}, yield
  \lambda \texttt{p}\ldotp
  \left\{\mbox{\begin{tabular}{c}
    {{if $\texttt{p}\in\src{L}$, then $\cc{\src{L}}{\trg{L}}(\texttt{p})$}} \\
    \mbox{{if $\texttt{p}\in\obj{L}$, then $\cc{\obj{L}}{\trg{L}}(\texttt{p})$}} \\
  \end{tabular}}\right. 
  \]
\end{definition}

Examples of this are present in industry:
Consider the Java Virtual Machine bytecode $\trg{JVM BC}$, which is a popular target for programming language designers due to its high performance and relevance in industry.
Compilers for several programming languages have it as their target language, some popular instances are $\src{Java}$ and $\obj{Kotlin}$.
Technically speaking, they both compile to class files and $\obj{Kotlin}$ objects are considered to be the same as $\src{Java}$ objects at that point.
Both languages can be used at the same time in one project~\cite{androidstudio}.
A compiler that accepts both $\src{Java}$ and $\obj{Kotlin}$ code translating to the same target language or intermediate representation performs a kind of {\em upper} composition.
Now, the following theorem tells us what happens if these are secure:
Given {$\cc{\src{L}}{\trg{L}}$ robustly preserves $\class[_{1}]$} and {$\cc{\obj{L}}{\trg{L}}$ robustly preserves $\class[_{2}]$}, it follows that {their upper composition $\cc{\src{L}+\obj{L}}{\trg{L}}$ robustly preserves the intersection of classes $\class[_{1}]$ and $\class[_{2}]$}.

\begin{theorem}[Upper Composition of Secure Compilers]\label{thm:urtp}
  $\;$

  If {$\rtp{\cc{\src{L}}{\trg{L}}}{\class[_{1}]}$} and {$\rtp{\cc{\obj{L}}{\trg{L}}}{\class[_{2}]}$}, then {$\rtp{\cc{\src{L}+\obj{L}}{\trg{L}}}{\class[_{1}]\cap\class[_{2}]}$}. %\Coqed
\end{theorem}

Dually, the {\em lower} composition is concerned about compilers that accept the same source but yield different target languages. %and the same theoretical results apply.
{Define the lower composition $\cc{\src{L}}{\trg{L}+\obj{L}}$} as follows:
Given a program $\src{p}$, its compiled counterpart is obtained by {plugging $\src{p}$ into $\cc{\src{L}}{\trg{L}}$} or by {plugging \texttt{p} into $\cc{\src{L}}{\obj{L}}$}, respectively, {based on the internal decision}.
\begin{definition}[Lower Composition]
  \[
    \text{{$\cc{\src{L}}{\trg{L}+\obj{L}}$}}\isdef
  % Given $L$ and $\src{p}$, yield
  \lambda \src{p}, L\ldotp
  \left\{\mbox{\begin{tabular}{c}
    {{if $L=\trg{L}$, then} {$\cc{\src{L}}{\trg{L}}(\src{p})$}} \\
    \mbox{{if $L=\obj{L}$, then} {$\cc{\src{L}}{\obj{L}}(\src{p})$}} \\
  \end{tabular}}\right.\]
\end{definition}

 Consider two compilers both accepting $\src{LLVM IR}$~\cite{lattner2004llvm} and one of them emits $\trg{x86\_64}$, while the other emits $\obj{ARMv8}$.
 It is intuitive that they are in some sense composed in the LLVM framework, but the decision of when to use one over the other is inherently {\em internal} to the formalisation effort of this kind of composition.
 For example, the user of this compiler provides an explicit flag that instructs to emit $\trg{x86\_64}$ or the framework itself detects the target platform via heuristics, such as supported instructions.

 The following theorem demonstrates what happens if the involved compilers are secure:
Given {$\cc{\src{L}}{\trg{L}}$ robustly preserves $\class[_{1}]$} and {$\cc{\src{L}}{\obj{L}}$ robustly preserves $\class[_{2}]$}, it follows that {their lower composition $\cc{\src{L}}{\trg{L}+\obj{L}}$ robustly preserves the intersection of classes $\class[_{1}]$ and $\class[_{2}]$}.

\begin{theorem}[Lower Composition of Secure Compilers]\label{thm:lrtp}
  $\;$ 

  If {$\rtp{\cc{\src{L}}{\trg{L}}}{\class[_{1}]}$} and {$\rtp{\cc{\obj{L}}{\trg{L}}}{\class[_{2}]}$}, then {$\rtp{\cc{\src{L}}{\trg{L}+\obj{L}}}{\class[_{1}]\cap\class[_{2}]}$}. % \Coqed
\end{theorem}

Either way, the theoretical results suggest that it is possible to always find a ``most-general'', secure compiler, given two secure compilers, that robustly preserves the least-upper bound of the classes involved in their compilation process.

%Future work intends to use upper and lower composition as means to build a secure compiler incrementally
%This follows current non-formal-methods based compiler engineering, such as LLVM~\cite{lattner2004llvm}, where languages such as \texttt{C++} and \texttt{Fortran} translate into LLVM IR and languages such as \texttt{x86} or \texttt{ARMv8} assembly variants translate out of LLVM IR.

% no coq, because above definitions are non-formal. 
%   How would you precisely define the lower compo compiler, given two compilers? 

%\section{Cryptographic Constant Time}\label{sec:cct}

\end{document}
\endinput
