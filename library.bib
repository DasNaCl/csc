
@article{10.1145/1837855.1806657,
author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo M.K. and Zdancewic, Steve},
title = {CETS: Compiler Enforced Temporal Safety for C},
year = {2010},
issue_date = {August 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {8},
issn = {0362-1340},
url = {https://doi.org/10.1145/1837855.1806657},
doi = {10.1145/1837855.1806657},
abstract = {Temporal memory safety errors, such as dangling pointer dereferences and double frees,
are a prevalent source of software bugs in unmanaged languages such as C. Existing
schemes that attempt to retrofit temporal safety for such languages have high runtime
overheads and/or are incomplete, thereby limiting their effectiveness as debugging
aids. This paper presents CETS, a compile-time transformation for detecting all violations
of temporal safety in C programs. Inspired by existing approaches, CETS maintains
a unique identifier with each object, associates this metadata with the pointers in
a disjoint metadata space to retain memory layout compatibility, and checks that the
object is still allocated on pointer dereferences. A formal proof shows that this
is sufficient to provide temporal safety even in the presence of arbitrary casts if
the program contains no spatial safety violations. Our CETS prototype employs both
temporal check removal optimizations and traditional compiler optimizations to achieve
a runtime overhead of just 48% on average. When combined with a spatial-checking system,
the average overall overhead is 116% for complete memory safety},
journal = {SIGPLAN Not.},
month = jun,
pages = {31‚Äì40},
numpages = {10},
keywords = {temporal errors, c, dangling pointers, memory safety}
}
@INPROCEEDINGS{watson15,
  author={Watson, Robert N.M. and Woodruff, Jonathan and Neumann, Peter G. and Moore, Simon W. and Anderson, Jonathan and Chisnall, David and Dave, Nirav and Davis, Brooks and Gudka, Khilan and Laurie, Ben and Murdoch, Steven J. and Norton, Robert and Roe, Michael and Son, Stacey and Vadera, Munraj},
  booktitle={2015 IEEE Symposium on Security and Privacy},
  title={CHERI: A Hybrid Capability-System Architecture for Scalable Software Compartmentalization},
  year={2015},
  volume={},
  number={},
  pages={20-37},
  doi={10.1109/SP.2015.9}
}
@misc{vassena19,
  title={Memory Safety Preservation for WebAssembly},
  author={Marco Vassena and Marco Patrignani},
  year={2019},
  eprint={1910.09586},
  archivePrefix={arXiv},
  primaryClass={cs.PL}
}
@inproceedings{kouwe17,
  author = {van der Kouwe, Erik and Nigade, Vinod and Giuffrida, Cristiano},
  title = {DangSan: Scalable Use-after-Free Detection},
  year = {2017},
  isbn = {9781450349383},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3064176.3064211},
  doi = {10.1145/3064176.3064211},
  abstract = {Use-after-free vulnerabilities due to dangling pointers are an important and growing
  threat to systems security. While various solutions exist to address this problem,
  none of them is sufficiently practical for real-world adoption. Some can be bypassed
  by attackers, others cannot support complex multithreaded applications prone to dangling
  pointers, and the remainder have prohibitively high overhead. One major source of
  overhead is the need to synchronize threads on every pointer write due to pointer
  tracking.In this paper, we present DangSan, a use-after-free detection system that
  scales efficiently to large numbers of pointer writes as well as to many concurrent
  threads. To significantly reduce the overhead of existing solutions, we observe that
  pointer tracking is write-intensive but requires very few reads. Moreover, there is
  no need for strong consistency guarantees as inconsistencies can be reconciled at
  read (i.e., object deallocation) time. Building on these intuitions, DangSan's design
  mimics that of log-structured file systems, which are ideally suited for similar workloads.
  Our results show that DangSan can run heavily multithreaded applications, while introducing
  only half the overhead of previous multithreaded use-after-free detectors.},
  booktitle = {Proceedings of the Twelfth European Conference on Computer Systems},
  pages = {405‚Äì419},
  numpages = {15},
  keywords = {use-after-free, LLVM, Dangling pointers},
  location = {Belgrade, Serbia},
  series = {EuroSys '17}
}

@INPROCEEDINGS{stepanov,
  author={Stepanov, Evgeniy and Serebryany, Konstantin},
  booktitle={2015 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)},
  title={MemorySanitizer: Fast detector of uninitialized memory use in C++},
  year={2015},
  volume={},
  number={},
  pages={46-55},
  doi={10.1109/CGO.2015.7054186}
}

@inproceedings{akritidis09,
  author = {Akritidis, Periklis and Costa, Manuel and Castro, Miguel and Hand, Steven},
  title = {Baggy Bounds Checking: An Efficient and Backwards-Compatible Defense against out-of-Bounds Errors},
  year = {2009},
  publisher = {USENIX Association},
  address = {USA},
  abstract = {Attacks that exploit out-of-bounds errors in C and C++ programs are still prevalent
  despite many years of research on bounds checking. Previous backwards compatible bounds
  checking techniques, which can be applied to unmodified C and C++ programs, maintain
  a data structure with the bounds for each allocated object and perform lookups in
  this data structure to check if pointers remain within bounds. This data structure
  can grow large and the lookups are expensive.In this paper we present a backwards
  compatible bounds checking technique that substantially reduces performance overhead.
  The key insight is to constrain the sizes of allocated memory regions and their alignment
  to enable efficient bounds lookups and hence efficient bounds checks at runtime. Our
  technique has low overhead in practice--only 8% throughput decrease for Apache-- and
  is more than two times faster than the fastest previous technique and about five times
  faster--using less memory--than recording object bounds using a splay tree.},
  booktitle = {Proceedings of the 18th Conference on USENIX Security Symposium},
  pages = {51‚Äì66},
  numpages = {16},
  location = {Montreal, Canada},
  series = {SSYM'09}
}

@inproceedings{rigger17,
  author = {Rigger, Manuel and Schatz, Roland and Grimmer, Matthias and M\"{o}ssenb\"{o}ck, Hanspeter},
  title = {Lenient Execution of C on a Java Virtual Machine: Or: How I Learned to Stop Worrying and Run the Code},
  year = {2017},
  isbn = {9781450353403},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3132190.3132204},
  doi = {10.1145/3132190.3132204},
  abstract = {Most C programs do not conform strictly to the C standard, and often show undefined
  behaviors, for instance, in the case of signed integer overflow. When compiled by
  non-optimizing compilers, such programs often behave as the programmer intended. However,
  optimizing compilers may exploit undefined semantics to achieve more aggressive optimizations,
  possibly breaking the code in the process. Analysis tools can help to find and fix
  such issues. Alternatively, a C dialect could be defined in which clear semantics
  are specified for frequently occurring program patterns with otherwise undefined behaviors.
  In this paper, we present Lenient C, a C dialect that specifies semantics for behaviors
  left open for interpretation in the standard. Specifying additional semantics enables
  programmers to make safe use of otherwise undefined patterns. We demonstrate how we
  implemented the dialect in Safe Sulong, a C interpreter with a dynamic compiler that
  runs on the JVM.},
  booktitle = {Proceedings of the 14th International Conference on Managed Languages and Runtimes},
  pages = {35‚Äì47},
  numpages = {13},
  keywords = {Sulong, C, Undefined Behavior},
  location = {Prague, Czech Republic},
  series = {ManLang 2017}
}

@InProceedings{tarditi2018,
author = {Tarditi, David and Elliott, Archibald Samuel and Ruef, Andrew and Hicks, Michael},
title = {Checked C: Making C Safe by Extension},
booktitle = {IEEE Cybersecurity Development Conference 2018 (SecDev)},
year = {2018},
month = {September},
abstract = {This paper presents Checked C, an extension to C designed to support spatial safety, implemented in Clang and LLVM. Checked C's design is distinguished by its focus on backward-compatibility, incremental conversion, developer control, and enabling highly performant code. Like past approaches to a safer C, Checked C employs a form of checked pointer whose accesses can be statically or dynamically verified. Performance evaluation on a set of standard benchmark programs shows overheads to be relatively low. More interestingly, Checked C introduces the notions of a checked region and bounds-safe interfaces.

&nbsp;},
publisher = {IEEE},
url = {https://www.microsoft.com/en-us/research/publication/checkedc-making-c-safe-by-extension/},
pages = {53-60},
}

@article{aurajo16,
  title = {T√Ωr: A Dependent Type System for Spatial Memory Safety in LLVM},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {324},
  pages = {3-13},
  year = {2016},
  note = {WEIT 2015, the Third Workshop-School on Theoretical Computer Science},
  issn = {1571-0661},
  doi = {https://doi.org/10.1016/j.entcs.2016.09.003},
  url = {https://www.sciencedirect.com/science/article/pii/S1571066116300469},
  author = {V√≠tor Buj√©s Ubatuba {De Ara√∫jo} and √Ålvaro Freitas Moreira and Rodrigo Machado},
  keywords = {Spatial memory, dependent types, type safety, LLVM},
  abstract = {This work proposes a dependent type system for the LLVM Intermediate Representation language for keeping track of pointer bounds information. The system employs a combination of static analysis and runtime checks to avoid spatial memory safety violations, such as buffer overflows. By working on LLVM IR, the system serves a foundation for ensuring spatial memory safety in languages which can be compiled to LLVM, such as C and C++.}
}

@inproceedings{nagarakatte10,
  author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo M.K. and Zdancewic, Steve},
  title = {CETS: Compiler Enforced Temporal Safety for C},
  year = {2010},
  isbn = {9781450300544},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1806651.1806657},
  doi = {10.1145/1806651.1806657},
  abstract = {Temporal memory safety errors, such as dangling pointer dereferences and double frees,
  are a prevalent source of software bugs in unmanaged languages such as C. Existing
  schemes that attempt to retrofit temporal safety for such languages have high runtime
  overheads and/or are incomplete, thereby limiting their effectiveness as debugging
  aids. This paper presents CETS, a compile-time transformation for detecting all violations
  of temporal safety in C programs. Inspired by existing approaches, CETS maintains
  a unique identifier with each object, associates this metadata with the pointers in
  a disjoint metadata space to retain memory layout compatibility, and checks that the
  object is still allocated on pointer dereferences. A formal proof shows that this
  is sufficient to provide temporal safety even in the presence of arbitrary casts if
  the program contains no spatial safety violations. Our CETS prototype employs both
  temporal check removal optimizations and traditional compiler optimizations to achieve
  a runtime overhead of just 48% on average. When combined with a spatial-checking system,
  the average overall overhead is 116% for complete memory safety},
  booktitle = {Proceedings of the 2010 International Symposium on Memory Management},
  pages = {31‚Äì40},
  numpages = {10},
  keywords = {dangling pointers, memory safety, temporal errors, c},
  location = {Toronto, Ontario, Canada},
  series = {ISMM '10}
}

@InProceedings{barthe11,
  author="Barthe, Gilles
  and Crespo, Juan Manuel
  and Kunz, C{\'e}sar",
  editor="Butler, Michael
  and Schulte, Wolfram",
  title="Relational Verification Using Product Programs",
  booktitle="FM 2011: Formal Methods",
  year="2011",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="200--214",
  abstract="Relational program logics are formalisms for specifying and verifying properties about two programs or two runs of the same program. These properties range from correctness of compiler optimizations or equivalence between two implementations of an abstract data type, to properties like non-interference or determinism. Yet the current technology for relational verification remains underdeveloped. We provide a general notion of product program that supports a direct reduction of relational verification to standard verification. We illustrate the benefits of our method with selected examples, including non-interference, standard loop optimizations, and a state-of-the-art optimization for incremental computation. All examples have been verified using the Why tool.",
  isbn="978-3-642-21437-0"
}

@article{patrignani18,
  title={Robustly safe compilation or, efficient, provably secure compilation},
  author={Patrignani, Marco and Garg, Deepak},
  journal={arXiv preprint arXiv:1804.00489},
  year={2018}
}

@InProceedings{patrignani19,
  author="Patrignani, Marco
  and Garg, Deepak",
  editor="Caires, Lu{\'i}s",
  title="Robustly Safe Compilation",
  booktitle="Programming Languages and Systems",
  year="2019",
  publisher="Springer International Publishing",
  address="Cham",
  pages="469--498",
  abstract="Secure compilers generate compiled code that withstands many target-level attacks such as alteration of control flow, data leaks or memory corruption. Many existing secure compilers are proven to be fully abstract, meaning that they reflect and preserve observational equivalence. Fully abstract compilation is strong and useful but, in certain cases, comes at the cost of requiring expensive runtime constructs in compiled code. These constructs may have no relevance for security, but are needed to accommodate differences between the source and target languages that fully abstract compilation necessarily needs.",
  isbn="978-3-030-17184-1"
}

@article{patrignani21,
  author    = {Marco Patrignani and
               Deepak Garg},
  title     = {Robustly Safe Compilation, an Efficient Form of Secure Compilation},
  journal   = {{ACM} Trans. Program. Lang. Syst.},
  volume    = {43},
  number    = {1},
  pages     = {1:1--1:41},
  year      = {2021},
  url       = {https://doi.org/10.1145/3436809},
  doi       = {10.1145/3436809},
  timestamp = {Wed, 26 May 2021 08:56:20 +0200},
  biburl    = {https://dblp.org/rec/journals/toplas/PatrignaniG21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{clarkson08,
  author    = {Michael R. Clarkson and
               Fred B. Schneider},
  title     = {Hyperproperties},
  booktitle = {Proceedings of the 21st {IEEE} Computer Security Foundations Symposium,
               {CSF} 2008, Pittsburgh, Pennsylvania, USA, 23-25 June 2008},
  pages     = {51--65},
  publisher = {{IEEE} Computer Society},
  year      = {2008},
  url       = {https://doi.org/10.1109/CSF.2008.7},
  doi       = {10.1109/CSF.2008.7},
  timestamp = {Wed, 16 Oct 2019 14:14:49 +0200},
  biburl    = {https://dblp.org/rec/conf/csfw/ClarksonS08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@INPROCEEDINGS{abate2019,
  author={Abate, Carmine and Blanco, Roberto and Garg, Deepak and Hritcu, Catalin and Patrignani, Marco and Thibault, J√©r√©my},
  booktitle={2019 IEEE 32nd Computer Security Foundations Symposium (CSF)},
  title={Journey Beyond Full Abstraction: Exploring Robust Property Preservation for Secure Compilation},
  year={2019},
  volume={},
  number={},
  pages={256-25615},
  doi={10.1109/CSF.2019.00025}
}


Ôªø@article{Futamura1999,
  author={Futamura, Yoshihiko},
  title={Partial Evaluation of Computation Process--An Approach to a Compiler-Compiler},
  journal={Higher-Order and Symbolic Computation},
  year={1999},
  month={Dec},
  day={01},
  volume={12},
  number={4},
  pages={381-391},
  abstract={This paper reports the relationship between formal description of semantics (i.e., interpreter) of a programming language and an actual compiler. The paper also describes a method to automatically generate an actual compiler from a formal description which is, in some sense, the partial evaluation of a computation process. The compiler-compiler inspired by this method differs from conventional ones in that the compiler-compiler based on our method can describe an evaluation procedure (interpreter) in defining the semantics of a programming language, while the conventional one describes a translation process.},
  issn={1573-0557},
  doi={10.1023/A:1010095604496},
  url={https://doi.org/10.1023/A:1010095604496}
}

@article{exorcisingSpectres,
  author    = {Marco Guarnieri and
               Marco Patrignani},
  title     = {Exorcising Spectres with Secure Compilers},
  journal   = {CoRR},
  volume    = {abs/1910.08607},
  year      = {2019},
  url       = {http://arxiv.org/abs/1910.08607},
  eprinttype = {arXiv},
  eprint    = {1910.08607},
  timestamp = {Tue, 22 Oct 2019 18:17:16 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1910-08607.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{lattner04,
     Author  = {Chris Lattner and Vikram Adve},
     Title = {{LLVM}: A Compilation Framework for Lifelong Program
Analysis and Transformation},
     Booktitle = CGO,
     Address = {San Jose, CA, USA},
     Month = {Mar},
     Year  = {2004},
     pages       = {75--88},
}
