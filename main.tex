\documentclass[a4paper,names,dvipsnames]{article}

\usepackage[T1]{fontenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{glossaries}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{marvosym}
\usepackage[capitalize]{cleveref}
\usepackage{bm}
\usepackage{xspace}
\usepackage{etoolbox}
\usepackage{natbib}
\usepackage{xfrac}

% workaround to use extpfeil and stmaryrd together.
% see https://tex.stackexchange.com/questions/297108/
\expandafter\def\csname opt@stmaryrd.sty\endcsname
{only,shortleftarrow,shortrightarrow}
\usepackage{extpfeil}

\usepackage{tikz}
\usetikzlibrary{positioning}

\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newcounter{theoremcounter}
\newcounter{importanttheoremcounter}
\newtheorem{theorem}[theoremcounter]{Theorem}
\newtheorem{importanttheorem}[importanttheoremcounter]{Theorem}

\usepackage{mmmacros}
% \usepackage{./../mmmacros}
% \loadglsentries{./../acronyms}
\loadglsentries{acronyms}
\makeglossaries

\newcommand{\MK}[1]{\todo[color=orange!30]{TODO: #1}}
\newcommand{\MP}[1]{\todo[color=blue!30]{TODO: #1}}

% Definition of Ddots
\makeatletter
\def\Ddots{\mathinner{\mkern1mu\raise\p@
\vbox{\kern7\p@\hbox{.}}\mkern2mu
\raise4\p@\hbox{.}\mkern2mu\raise7\p@\hbox{.}\mkern1mu}}
\makeatother

\begin{document}

\tableofcontents
\clearpage

\section{Preliminaries}

\begin{definition}[Events]\label{def:events}
  $\events$ is the set of atomic propositions hereby called events or actions.
  The internal action is $\emptyevent$.
  The action $\terminationevent$ is program termination.
\end{definition}


We assume that any programming language can be enriched with a self-composition operator in the style of \citet{barthe11}.
Furthermore, we also assume the existence of a low-equivalence relation that distinguishes program states only by their public memory.
Two traces $\trace_{1}$,$\trace_{2}$ are low-equivalent $\loweq{\trace_{1}}{\trace_{2}}$ iff all their public events coincide.

\begin{definition}[Programming Languages]\label{def:pl}
A programming language is a tuple $\left(\partials,\wellf,\singlestep,\linker\right)$ s.t.:

\begin{itemize}
  \item[$\partials$] : Set - is a set of admissible, partial programs.
  \item[$\wellf$] : $\partials$ - a judgement that holds iff a program is not partial.
  \item[$\singlestep$] : $\wholes\to\events\to\wholes$ - a step relation, where $\wholes=\{w\in\partials\ |\ \wellf w\}$.
        For $e\in\events$ and $p,p'\in\wholes$ we say for $\estep{p}{e}{p'}$ that program $p$ performs a step with action $e$ to program $p'$.
        If $e=\emptyevent$, we write $\step{p}{p'}$.
        In case $e=\terminationevent$, we write $\terminates{p}$.
  \item[$\linker$] : $\partials\to\partials\to\partials$ - links two partial programs together in some way, resulting in a new partial program.
\end{itemize}
\end{definition}
Let $\src{S},\irl{I},$ and $\trg{T}$ be any programming language.

% if we get τ1 and τ2, then there is aontehr program that does τ3 which does τ1 and τ2 in parallel
% define self-composition. and then define it with respect to low-equivalent programs
% 

\begin{definition}[Notation for Sequences]
  For any sequence of events, let $\seqnil$ denote the empty sequence and $\seqcons{e}{\bar{t}}$ the sequence that starts with $e$ and continues with $\bar{t}$.
  Hereby, it does not matter whether $\bar{t}$ is finite or infinite, it's merely syntactic sugar to work on sequences of events.
\end{definition}

\begin{definition}[Traces]
  A trace $\trace$ is an infinite sequence of events that results from the relation $\singlestep$.
  That is, we obtain the trace $\trace=\seqcons{e_{0}}{\seqcons{e_{1}}{\dots}}$ for the execution sequence $\estep{p}{e_{0}}{\estep{p'}{e_{1}}{\dots}}$ and write $\mktrace{p}{\trace}$.
  The set of all traces is $\traces$.
\end{definition}
\noindent
We assume $\lightning$ to occur in traces representing terminating programs such that it occurs infinitely often in a one-by-one sequence.

\begin{definition}[Finite Trace Prefixes]
  A finite sequence of events $m$ is a finite trace prefix of $\trace$ iff it satisfies the following judgement.

  $$
    \inference{}{\cdot\le\trace}\hspace{2em}\inference{m\le\trace}{\seqcons{e}{m}\le \seqcons{e}{\trace}}
  $$
\end{definition}

\begin{definition}[Behavior]
  The behavior of a whole program $p$ is a set of all traces it produces, i.e. $\behav{p}=\{\trace\ |\ \mktrace{p}{\trace}\}$.
\end{definition}

\begin{definition}[Observation]
  An observation is a finite set of finite trace prefixes.
  We say that an observation $o$ is the prefix of a behavior $b$ iff $$\forall m\in o.\exists \trace\in b.m\le t$$.
\end{definition}

\begin{definition}[Properties]
  A property $\prop$ is a set of admissible traces. For a program $p$ to satisfy $\prop$ it must not produce a trace that is not part of $\prop$. Thus, $p$ satisfies $\prop$ iff $\behav{p}\subseteq\prop$ and we write $\sat{p}{\prop}$.
\end{definition}

\begin{definition}[Hyperproperties]
  A hyperproperty $H$ is a set of admissible sets of traces. Thus, if $p$ satisfies $H$ (also written $\sat{p}{H}$), then $\behav{p}\in H$.
\end{definition}

\begin{lemma}[Lifting Properties]
  Given a property $\pi$, there exists a unique hyperproperty $\lift{\pi}$ that satisfies the exact same policy.
\end{lemma}
\begin{proof}
  We want $\forall p \in\partials, \sat{p}{\prop}\equiv\sat{p}{\lift{\prop}}$.
  Henceforth, given a $p\in\partials$, we have $\behav{p}\subseteq\prop$ iff $\behav{p}\in\lift{\prop}$.
  Note that if $\behav{p}\subseteq\prop$, we have $\behav{p}\in\left\{\Pi\ |\ \Pi=\behav{p}\subseteq\prop\right\}$.
  Thus, $\lift{\prop}$ is the set of all possible program behaviors that are a subset of $\prop$.
  This is exactly the powerset of $\prop$ and we conclude $\lift{\prop}=\powerset{\prop}$.
\end{proof}
\noindent
The lifting of properties to a singleton set does not suffice, since the empty behavior trivially satisfies any property $\emptyset\subseteq\prop=\{\trace\}$, but if we would define $\lift{\trace}=\{\{\trace\}\}$, then $\emptyset\not\in\lift{\trace}$.

\begin{lemma}[Property Satisfaction Refinement]
  For a property $\prop$ that refines $\prop'$, i.e. $\prop\subseteq\prop'$, if any $p\in\partials$ satisfies $\sat{p}{\prop'}$, then $\sat{p}{\prop}$.
\end{lemma}
\begin{proof}
  Pick any property $\prop'$ and $p\in\partials$ such that $\sat{p}{\prop}$ and assume $\prop\subseteq\prop'$.
  Simple unfolding reveals $\behav{p}\subseteq\prop\implies\behav{p}\subseteq\prop'$.
\end{proof}
\noindent
For lifted properties, this refinement property also holds on the hyperproperty level.
However, it does not work for any hyperproperty~\cite{clarkson08}.

\begin{definition}[Robust Property Satisfaction]
  A program $p$ robustly satisfies a property $\prop$, written $\rsat{p}{\prop}$, iff $\forall C\in\partials,\sat{C\linker p}{\prop}$. The same notation is used for robust hyperproperty satisfaction.
\end{definition}

\begin{lemma}[Weakening Robust Satisfaction]\label{lem:weaken-rsat}
  Given classes $\cC_{1}, \cC_{2}$ and any program $p$ such that
  \begin{assumptions}
    \item\label{lem:weaken-rsat:ass:a} $\cC_{1}\subseteq\cC_{2}$
    \item\label{lem:weaken-rsat:ass:b} $\rsat{p}{\cC_{2}}$
  \end{assumptions}
  We show
  \begin{goals}
    \item\label{lem:weaken-rsat:goal:i} $\rsat{p}{\cC_{1}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Unfolding \Thmref{lem:weaken-rsat:goal:i}, let $\Pi\in\cC_{2}$ and $p$ be a program, we want to show that $\rsat{p}{\Pi}$.
  By \Thmref{lem:weaken-rsat:ass:a}, we also know that $\Pi\in\cC_{1}$.
  Thus, we can use \Thmref{lem:weaken-rsat:ass:b} to conclude.
\end{proof}

\begin{definition}[Classes]
  A class of hyperproperties $\cC$ is a set of hyperproperties.
  Likewise, a class of properties $\cC$ is a set of hyperproperties, where every property is lifted to the hyperproperty level.
  From now on, we use $\Pi$ for elements of any class $\cC$ in case it does not matter whether it is a lifted property or any hyperproperty.
\end{definition}

\begin{definition}[Compilers]
  A compiler between languages $\S$ and $\T$ is a partial function $\stcomp{\bullet}$ from $\src{\partials}$ to $\trg{\partials}$.
\end{definition}

\section{Compositionality of Secure Compilers}

\begin{definition}[Robust Trace-Hyperproperty Preservation]\label{def:rtp}
  For a given class $\cC$, a compiler from languages $\S$ to $\T$ robustly preserves $\cC$ iff
  $$
  \forall\Pi\in\cC,\forall\src{p}\in\src{\partials},\rsat{\src{p}}{\Pi}\implies\rsat{\stcomp{\src{p}}}{\Pi}
  $$
  We write $\rtp{\stcomp{\bullet}}{\cC}$.
  In case we write $\rtp{\stcomp{\bullet}}{\collapse{\cC}}$, substitute the $\cC$ in above definition with $\left\{ \collapse{\cC} \right\}$.
\end{definition}

\begin{definition}[Sequential Composition of Compilers]
  Given two compilers $\sicomp{\bullet}$ and $\itcomp{\bullet}$, their sequential composition is $\sitcomp{\bullet}=\itcompN{\sicomp{\bullet}}$.
\end{definition}
% we can propagate through the assumptions from src langs to intermediate langs
%

\begin{lemma}[Weakening RTP]\label{lem:weaken}
  Given classes $\cC_{1}, \cC_{2}$ such that
  \begin{assumptions}
    \item $\cC_{1}\subseteq\cC_{2}$
    \item $\rtp{\stcomp{\bullet}}{\cC_{2}}$
  \end{assumptions}
  We show
  \begin{goals}
    \item $\rtp{\stcomp{\bullet}}{\cC_{1}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Using \Cref{def:rtp} on the goal, let $\Pi\in\cC_{1}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$, so what's left to prove is $\rsat{\stcomp{p}}{\Pi}$.
  Since $\cC_{1}\subseteq\cC_{2}$ and $\Pi\in\cC_{1}$, we know that $\Pi\in\cC_{2}$.
  Thus, we can apply the assumption $\rtp{\stcomp{\bullet}}{\cC_{2}}$ to our goal, leaving us with $\rsat{\src{p}}{\Pi}$ to show, which was an assumption we made.
\end{proof}

\begin{definition}[Safety Properties]
  The class of safety properties contains the lifting of all properties that can be refuted with a finite trace prefix:
  $$
  \cSafety = \left\{\lift{\prop}\ |\ \forall \trace\in\traces, t\not\in\lift{\prop} \text{ iff } \exists m\ge\trace,\forall \trace'\in\traces,m\le\trace'\implies\trace'\not\in\lift{\prop}\right\}
  $$
\end{definition}

\begin{definition}[Hypersafety Properties]\label{def:hsafety}
  The class of hypersafety properties contains all hyperpropert that can be refuted with an observation:
  $$
  \cHSafety = \left\{\Pi\ |\ \forall b\in 2^{\traces},b\not\in\Pi\text{ iff  }\exists o\ge b,\forall b'\in 2^{\traces},o\le b'\implies b'\not\in\Pi\right\}
  $$
\end{definition}

\begin{lemma}[Safety is entailed in Hypersafety]
  $\cSafety\subseteq\cHSafety$.
\end{lemma}

\begin{definition}[Subset Closed Hyperproperties]
  The class of hyperproperties that are closed with respect to the subset relation is
  $$
  \cSS = \left\{H\ |\ \forall X\in H, \forall Y\subseteq X, Y \in H\right\}
  $$
\end{definition}

\begin{lemma}[Hypersafety is entailed in SSC]
  $\cHSafety\subseteq\cSS$.
\end{lemma}

\begin{definition}[K-Hypersafety]
  Exactly the same as \Cref{def:hsafety}, but the observations $o$ are restricted to cardinality $k$.
  2-Hypersafety is simply $k=2$. \Cref{def:ni} gives an example instance of a classic 2-hypersafe property.
\end{definition}

\begin{definition}[Nontermination]
  Nontermination is a safety property: Any finite trace prefix with $\terminationevent$ violates this property.
\end{definition}

\begin{definition}[Mutual Exclusion]
  Mutual Exclusion (MutEx) means that no two processes during a program execution enter the same critical section.
\end{definition}

\begin{definition}[Determinism]
  Determinism is a 2-hypersafety property, since any two program executions with the same input must yield the same output.
\end{definition}

\begin{definition}[Non-Interference ($\Ni$)]\label{def:ni}
  We define the class containing the non-interference hyperproperty as:
  $$
  \Ni = \left\{ H | \forall \trace_{1},\trace_{2}\in H. \loweq{\trace_{1}}{\trace_{2}}\implies\trace_{1}=\trace_{2} \right\}
  $$
\end{definition}
Note that $=$ may not be strict equality, but some suitable trace equivalence that checks both public and private actions, instead of just public.

\begin{definition}[Average Response Time (ART)]
  The average response time over all executions less than some arbitrary constant~\cite{clarkson08} is a practically useful hyperproperty that is not subset closed.
\end{definition}
Consider the behavior $\{\trace_{1},\trace_{2},\trace_{3}\}$ where $\trace_{1},\trace_{2}$ each take 1 second and $\trace_{3}$ 4 seconds to run.
If the chosen constant is 2, the hyperproperty would be fulfilled. However, the subset behavior $\{\trace_{3}\}$ has an average time of 4, double the bound set by the property.

\begin{lemma}[Classes Lattice]
  Classes with $\subseteq$ form a lattice.
\end{lemma}
\begin{proof}
  The class with all hyperproperties is the top element $\top=\powerset{\traces}$, while the class with no hyperproperties whatsoever is $\bot=\{\}$.
  Obviously, a partial order due to set inclusion.
  $\cap$ is least upper and $\cup$ greatest lower bound of any given pair of subsets of a given class.
\end{proof}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance=4mm,every node/.style={align=center}]
    \node (top) {$\top$};
    \node[below = of top.south] (SSC) {$\cSS$};
    \node[below = of SSC.south] (HSafe) {$\cHSafety$};
    \node[below = of HSafe.south] (HKSafe) {$\cKHSafety$};
    \node[below = of HKSafe.south] (H2Safe) {$\cTwoHSafety$};
    \node[below = of H2Safe.south] (Safe) {$\cSafety$};

    % Specialized classes
    \node[below right = of Safe.south] (Mutex) {$\mutex$};
    \node[below left = of Safe.south,xshift = 0.75em] (NonTerm) {$\nonterm$};

    \node[below left = of H2Safe.south west] (Determ) {$\determ$};
    \node[below right = of H2Safe.south east] (NI) {$\Ni$};

    \node[below = of Safe.south] (emptyspace) {};
    \node[below = of emptyspace.south] (Bot) {$\bot$};

    % edges
    \draw[-] (top.south) -- (SSC.north);
    \draw[-] (SSC.south) -- (HSafe.north);
    \draw[-] (HSafe.south) -- (HKSafe.north);
    \draw[-] (HKSafe.south) -- (H2Safe.north);
    \draw[-] (H2Safe.south) -- (Safe.north);
    \draw[-] (H2Safe.south) -- (Determ.north);
    \draw[-] (H2Safe.south) -- (NI.north);
    \draw[-] (Safe.south) -- (Mutex.north);
    \draw[-] (Safe.south) -- (NonTerm.north);
    \draw[-] (Determ.south) |- (Bot.west);
    \draw[-] (NI.south) |- (Bot.east);
    \draw[-] (Mutex.south) -- (Bot.north);
    \draw[-] (NonTerm.south) -- (Bot.north);
  \end{tikzpicture}
  \caption{Sketch of a fraction of the infinitely sized lattice of classes. The diagram should be read from top to bottom. A connecting edge between two nodes means that the bottom one is a subset of the top one.}
\end{figure}

\begin{lemma}[Sequential Composition with RTP]\label{lem:seqcompo}
  Given $\rtp{\sicomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  We need to show $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
  By definition, assume $\Pi\in\cC_{1}\cap\cC_{2}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$.
  What is left to show is $\rsat{\sitcomp{\src{p}}}{\prop}$.
  Note that $\Pi\in\cC_{2}$ and that $\sicomp{\src{p}}\in\irl{\partials}$, allowing us to apply $\rtp{\itcomp{\bullet}}{\cC_{2}}$ changing our goal to $\rsat{\sicomp{\src{p}}}{\Pi}$.
  Since $\Pi\in\cC_{1}$ also holds, we can this time apply $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
  What is left to show is $\rsat{\src{p}}{\Pi}$, which is an assumption of ours.
\end{proof}

\begin{definition}[Upper Composition]
  Given two compilers $\stcomp{\bullet}$ and $\itcomp{\bullet}$, their upper composition is

  $$\uhcsitcomp{\bullet}=\lambda p.\begin{cases}\stcomp{p} &\text{if }p\in\src{\partials}\\
                                                \itcomp{p} &\text{if }p\in\irl{\partials}\end{cases}$$.
\end{definition}

\begin{lemma}[Upper Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\uhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Analogous argument as in \Thmref{lem:seqcompo}, but with a case distinction on whether the source program is element of $\S$ or $\I$.
\end{proof}
% S = while,    I = while with exceptions           => modularization

% another idea: certified nugget -> minimal RSP compiler

\begin{definition}[Lower Composition]
  Given two compilers $\stcomp{\bullet}$ and $\sicomp{\bullet}$, their lower composition is $\lhcsitcomp{\bullet}$.
\end{definition}

\begin{lemma}[Lower Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\sicomp{\bullet}}{\cC_{2}}$, then $\rtp{\lhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Analogous argument as in \Thmref{lem:seqcompo}, but with a case distinction on whether the compiled source program is element of $\I$ or $\T$.
\end{proof}

\begin{lemma}[Diamond]\label{lem:diamond}
  Given $\rtp{\lhcsiocomp{\bullet}}{\cC_{1}}$ and $\rtp{\uhciotcomp{\bullet}}{\cC_{2}}$ with $\stcomp{\bullet} = \lambda\src{p}.\uhciotcomp{\lhcsiocomp{p}}$, then $\rtp{\stcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Straightforward using \Thmref{lem:seqcompo}.
\end{proof}

\begin{lemma}[Swappable]\label{lem:swappable}
  Given $\rtp{\ttcomp{\bullet}_{(1)}}{\cC_{1}}$ and $\rtp{\ttcomp{\bullet}_{(2)}}{\cC_{2}}$, then $\rtp{\ttcompN{\ttcomp{\bullet}_{(2)}}_{(1)}}{\cC_{1}\cap\cC_{2}}$ and $\rtp{\ttcompN{\ttcomp{\bullet}_{(1)}}_{(2)}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Both follow from \Thmref{lem:seqcompo}.
\end{proof}

\begin{lemma}[Mingle]
  Given
  \begin{assumptions}
  \item\label[ass]{lem:sandwich:ass:a} $\forall\Pi\in\cC_{2}.\forall\src{p}\in\src{\partials}.\rsat{\src{p}}{\Pi}\implies \Pi\in\cC_{1}$
  \item\label[ass]{lem:sandwich:ass:b} $\forall\Pi\in\cC_{1}.\forall\trg{p}\in\trg{\partials}.\rsat{\trg{p}}{\Pi}\implies \Pi\in\cC_{2}$ (not needed)
  \item\label[ass]{lem:sandwich:ass:c} $\rtp{\stcomp{\bullet}}{\cC_{1}}$
  \end{assumptions}
  we have
  \begin{goals}
  \item\label[goal]{lem:sandwich:goal:i} $\rtp{\stcomp{\bullet}}{\cC_{2}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Unfolding \Cref{lem:sandwich:goal:i}; Let $\Pi\in\cC_{2}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$, leaving us with $\rsat{\stcomp{\src{p}}}{\Pi}$ to prove.

  Apply \Cref{lem:sandwich:ass:c}, giving us as new goals $\Pi\in\cC_{1}$ and $\rsat{\src{p}}{\Pi}$, the latter following easily by the exact same assumption made before.

  However, we still need to argue that $\Pi\in\cC_{1}$.

  Instatiate the universal quantifications in \Cref{lem:sandwich:ass:a} with $\Pi$ and $\src{p}$. Apply that to our goal.
  What is left to show is $\rsat{\src{p}}{\Pi}$, which we've proven before already.
\end{proof}

\begin{lemma}[RSP may imply k-RSHP]
  Given
  \begin{assumptions}
  \item\label[ass]{lem:rspimplkrshp:ass:a} $\S$ and $\T$ have $\loweq{}{}$ and $\selfcompo{}{}$ operators
  \item\label[ass]{lem:rspimplkrshp:ass:b} $\Pi\in\cSafety$
  \item\label[ass]{lem:rspimplkrshp:ass:c} $\src{p}\in\src{\partials}$ with $\rsat{\src{p}}{\Pi}$
  \item\label[ass]{lem:rspimplkrshp:ass:d} $\rtp{\stcomp{\bullet}}{\cSafety}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{lem:rspimplkrshp:goal:i} $\exists\stcomp{\bullet}.\sat{\stcomp{\src{p}}}{\text{k-RSHP}}$
  \end{goals}
\end{lemma}
\begin{proof}
  (intuition)

  Take $\src{p}\in\src{\partials}$ and construct the k-product program according to \citet{barthe11}.
  Feed the input into the compiler from \Cref{lem:rspimplkrshp:ass:d}.
  Instantiate the existential in \Cref{lem:rspimplkrshp:goal:i} with the modified compiler.
  Since the product program reflects the behavior of $\src{p}$, the transformation does not interfere with robust property satisfaction.
  Furthermore, \Cref{lem:rspimplkrshp:ass:d} guarantees us that the compiled k-product program of $\src{p}$ is safe.
  Since the k-product construction soundly embeds $k-RSHP$ properties into $\cSafety$, the claim follows.
\end{proof}


\begin{definition}[Instrumentation]\label{def:instrumentation}
  A source code instrumentation done by a compiler takes a program in language $\T$ and emits an altered version of the same program in $\T$ such that it does not go wrong for some class of security relevant (hyper-)properties.
  Formally, given a $\cC$ a compiler $\ttcomp{\bullet}$ is an instrumentation for $\cC$ iff:

  $$
  \forall \trg{p}\in\trg{\partials}, \rsat{\ttcomp{p}}{\cC}
  $$

  We write $\instr{\ttcomp{\bullet}}{\cC}$.
\end{definition}
% S -> I and I -> T
% I -> T preserves memory safety


% enrich pipeline from source to target to see how to do the preservation from source in intermediate/target lang

\begin{definition}[Secure Instrumentation with Respect to $\cC$]\label{def:secure-instrumentation}
  A secure instrumentation with respect to some class $\cC$ ensures (hyper-)properties described by some class $\cC'$ without violating $\cC$-satisfying programs. We write $\sinstr{\ttcomp{\bullet}}{\cC}{\cC'}$.
  Thus, a compiler $\ttcomp{\bullet}$ is a secure instrumentation for $\cC'$ respecting $\cC$ iff:

  $$
  \rtp{\ttcomp{\bullet}}{\cC}\text{ and } \instr{\ttcomp{\bullet}}{\cC'}
  $$

\end{definition}

\begin{lemma}[Sequential Composition with a Secure Instrumentation]\label{lem:seqcompsecinstr}
  Given compilers $\sicomp{\bullet}$, $\itcomp{\bullet}$ and classes $\cC_{0},\cC_{1}$ such that
  \begin{assumptions}
  \item\label[ass]{lem:seqcompsecinstr:ass:a} $\rtp{\sicomp{\bullet}}{\cC_{0}}$
  \item\label[ass]{lem:seqcompsecinstr:ass:b} $\sinstr{\itcomp{\bullet}}{\cC_{1}}{\cC_{0}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{lem:seqcompsecinstr:goal:i} $\rtp{\sitcomp{\bullet}}{\cC_{0}\cup\cC_{1}}$
  \end{goals}
\end{lemma}

%\begin{definition}[No-v* Classes]
%  Let $\nvOne$ denote the singleton-class such that no SPECTRE v1 attack can happen.
%  Analgously, define $\nvFour$ as a singleton-class that disallows SPECTRE v4 attacks and $\nvOneFour$ as the class that disallows both v1 and v4 attacks, i.e. $\nvOneFour=\nvOne\cap\nvFour$.
%\end{definition}

% \begin{example}
%   Consider a compiler $\ttcomp{\bullet}_{1}$ such that $\sinstr{\ttcomp{\bullet}_{1}}{\nvOne}{\nvFour}$ and, similarily,
%   $\ttcomp{\bullet}_{4}$ such that $\sinstr{\ttcomp{\bullet}_{4}}{\nvFour}{\nvOne}$.

%   \begin{lemma}\label{lem:vOnevFourSafe}
%     Using above compilers, we now show that $\rtp{\ttcompN{\ttcomp{\bullet}_{1}}_{4}}{\nvOneFour}$.
%   \end{lemma}
%   \begin{proof}
%     By \Cref{lem:seqcompo} we get two goals, $\rtp{\ttcomp{\bullet}_{1}}{\nvOneFour}$ and $\rtp{\ttcomp{\bullet}_{4}}{\nvOneFour}$.

%     Since both cases are symmetrical, we only consider $\rtp{\ttcomp{\bullet}_{1}}{\nvOneFour}$ now.

%     Unfolding the definition of the goal, suppose there is a $\Pi\in\nvOneFour$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, while our new goal is $\rsat{\ttcomp{p}_{1}}{\Pi}$.

%     Strengthen the goal so that we need to show $\rsat{\ttcomp{p}_{1}}{\Pi}\wedge\Pi\in\nvOneFour$. Now, apply \Cref{def:secure-instrumentation}, so the only things left to show are $\Pi\in\nvOne$ and $\rsat{\trg{p}}{\Pi}$.
%     Both follow easily from our assumptions.
%   \end{proof}
%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{4}}_{1}}{\nvOneFour}$
%   \end{lemma}
%   \begin{proof}
%     By \Cref{lem:vOnevFourSafe} and \Cref{lem:swappable}.
%   \end{proof}

%   We now consider what happens if one of the two instrumentations is not secure with respect to the respective other class.
%   However, we focus on the case where the v1-instrumentation is insecure with respect to v4, due to symmetry.

%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{1}}_{4}}{\nvOneFour}$
%   \end{lemma}
%   \begin{proof}
%     Note that $\ttcomp{p}_{1}$ is a secure $\T$ program with respect to SPECTRE v1 attacks, given any $\trg{p}\in\trg{\partials}$.

%     Unfolding, let $\Pi\in\nvOneFour$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, our goal changes to $\rsat{\ttcompN{\ttcomp{\trg{p}}_{1}}_{4}}{\Pi}$.

%     Strengthen what we want to prove to $\rsat{\ttcompN{\ttcomp{\trg{p}}_{1}}_{4}}{\Pi}\wedge\Pi\in\nvOneFour$.
%     Apply \Cref{def:secure-instrumentation}, giving us proof-obligations that are already part of our assumptions.
%   \end{proof}

%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{4}}_{1}}{\nvOne}$
%   \end{lemma}
%   \begin{proof}
%     Let $\trg{p}=\ttcomp{p'}_{4}$ be some program that is the result of plugging $\trg{p'}\in\trg{\partials}$ into $\ttcomp{\bullet}_{4}$.

%     Our goal becomes $\rtp{\ttcomp{p}_{1}}{\nvOne}$. Unfolding it, let $\Pi\in\nvOne$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, where what is left to prove is $\rsat{\ttcomp{p}_{1}}{\nvOne}$.

%     The goal follows immediately by \Cref{def:instrumentation}, since $\ttcomp{p}_{1}$ is an instrumentation for $\nvOne$.
%   \end{proof}

%   Finally, if both are insecure instrumentations, the strongest result one can get is either the robust preservation of $\nvOne$ or $\nvFour$, depending on which compiler is run last.
% \end{example}

We have seen that we can already swap robust compilers with same input and output language in a compilation pipeline.
Now, we want to formalize this idea of ``being able to swap things around'' for source code instrumentations.

\begin{definition}[Swappable Instrumentations]
  We define vertical compositionality as follows.
  Let $\bar{\cC}$ be a set of classes that are eventually used in the compilation pipeline.
  Given a class $\cC\in\bar{\cC}$ the particular instrumentation $\ttcomp{\bullet}$ ensures any program to robustly satisfy, we can swap the instrumentation in the pipeline \textit{freely} around iff:

  $$
  \forall\cC'\in\bar{\cC}. \sinstr{\ttcomp{\bullet}}{\cC}{\cC'}
  $$
\end{definition}
\MK{it'd be nice to have a property-free version of this, since this here is TEDIOUS to prove in real-world}

\clearpage
Experimental
\begin{definition}[Encoders]
  An encoder $\tenc{\src{\bullet}}$ from language $\S$ to $\T$ is a function that constructs an abstract representation of the given $\S$ program as a $\T$ program.
\end{definition}
\noindent
Think of encoders as parsers.

\begin{definition}[Interpreters]
  An interpreter $\stinterp$ is a $\T$ program that faithfully implements the semantics of $\S$.
  That is, given $\src{p}\in\src{\partials}$ and some encoding function $\tenc{\src{\bullet}}$, then $\mktrace{\stinterp \trg{\linker} \tenc{\src{p}}}{\tau} \Leftrightarrow \mktrace{\src{p}}{\tau}$.
\end{definition}
Note: For an interpreter to \textit{faithfully} realize the semantics of $\S$, we really need the equivalence.
Say we only consider the $\Leftarrow$ direction as defining characteristic, then an interpreter that e.g. tosses a coin and thus $\behav{\stinterp\trg{\linker}\tenc{\src{p}}}=\{\trace_{1},\trace_{2}\}$ given $\behav{\src{p}}=\{\trace_{1}\}$ would be acceptable.
However, an interpreter that 99\% of the time emits $\trace_{2}$ is certainly not what we want.
Consider the converse, so $\Rightarrow$ as defining characteristic.
Then, swapping the behaviors from the previous example, the interpreter does not \textit{faithfully} simulate non-determinism that is present in the source language.
% Due to this, interpreters in our world always robustly satisfy relational hyperproperties

\begin{definition}[Specializers]
  A specializer $\ttspec{\bullet}$ is a $\T$ program that, given an encoding of another $\T$ program as input, emits a specialized version of that $\T$ program.
  So, given a partial program $\trg{p}$ and some set of inputs $\trg{x}\in\trg{\partials}$, $\ttspec{\tenc{p \linker x}}$ always terminates with a residual program $\trg{p'}$ such that $\behav{\trg{p\linker x}}=\behav{\trg{p'}}$.
\end{definition}
\noindent

\begin{definition}[2nd Futamura Projection]
  Given a specializer $\ttspec{\bullet}$, an interpreter $\stinterp$, and an encoding $\tenc{\src{\bullet}}$, we can compose them to a compiler $\stcomp{\bullet} = \ttspec{\stinterp \tenc{\src{\bullet}}}$.~\cite{Futamura1999}
\end{definition}

\clearpage

\section{Case Study}

\subsection{Source Language}
\subsubsection{Syntax}

\myfig{
	\vspace{-1em}
  \begin{gather*}
  \begin{aligned}
  \mi{Expressions}~\src{e} \bnfdef&\ \src{x} \mid \src{v} \mid \src{e_{1} \oplus e_{2}} \mid \src{x[e]} \mid \src{let\ x = e_{1}\ in\ e_{2}}\mid \src{x[e_{1}]\leftarrow e_{2}} \\
  & \mid \src{let\ x=new\ e_{1}\ in\ e_{2}} \mid \src{delete\ x}
  \hspace{0.5cm} \text{where } \src{\oplus}\in\{\src{+},\src{-},\src{\times}\}\\
  %
  \mi{Types}~\taus \bnfdef&\ \src{\nat} \mid \src{ref_q\ \nat} \hspace{0.25cm}
  %
  \mi{Qualifier}~\src{q} \bnfdef\ \full \mid \half\hspace{0.25cm}
  %
  \mi{Values}~\src{v} \bnfdef\ \src{n}\in\src{\nat} \\
  \mi{References}~\src{\loc}&\in\src{\nat} \hspace{0.5cm}
  %
  \mi{Variables}~\ \src{x} \mid \src{y} \mid \dots \hspace{0.5cm}
  %
  \mi{Poison}~\ \src{\poison}~\bnfdef\ \src{\poisonless} \mid \src{\poisoned}\\
  %
  \mi{Importance}~\ \src{i}~\bnfdef&\  \mid \;\src{\diamond}\hspace{0.5cm}
  \mi{Typing. Env.}~\src{\Gamma} \bnfdef\ \src{\hole{\cdot}} \mid \Gammas,\src{x:\tau}\\
  \mi{Store}~\src{\Delta} \bnfdef&\ \src{\hole{\cdot}} \mid \src{x\mapsto\loc_\poison^{i}},\Deltas\\
  %
  \mi{Heaps}~\src{H} \bnfdef&\ \src{\hole{\cdot}} \mid \src{H}::\src{n} \hspace{0.5cm}
  %
  \mi{State}\ \configs \bnfdef\ \sconfig{H}{\Delta} \\
  %
  \mi{Contexts}\ &\src{context\ e_0\ e_1} \hspace{0.5cm}
  \mi{Components}\ \src{component\ e_p} \\
  \mi{Whole\ Programs}\ &\src{prog\ e_0\ e_1\ e_2}\\ %todo
  \end{aligned}
  \end{gather*}
}{mmla-syntax}{Syntax of $\mmlA$}

\subsubsection{Static Semantics}
\begin{definition}[NoPtr]
  We write $\src{\noptr{\Gamma}}$ if for any $\src{x}, \src{\tau}$, if $\src{x} : \src{\tau}\in\src{\Gamma}$, then $\taus\not=\ptr$.
\end{definition}

\myfig{
  \begin{center}
  \typerule{splitEmpty}{
  }{
    \src{\hole{\cdot}} = \src{\hole{\cdot}}\circ\src{\hole{\cdot}}
  }{t-empty-split}
  %
  \typerule{$\nat$split}{
    \Gammas = \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\nat},\Gammas = \src{x:\nat},\src{\Gamma_1}\circ\src{x:\nat},\src{\Gamma_2}
  }{t-nat-split}
  %
  \typerule{weakPtrSplit}{
    \Gammas = \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\wptr},\Gammas = \src{x:\wptr},\src{\Gamma_1}\circ\src{x:\wptr},\src{\Gamma_2}
  }{t-wptr-split}
  %
  \typerule{ptrLSplit}{
    \Gammas = \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\ptr},\Gammas = \src{x:\ptr},\src{\Gamma_1}\circ\src{\Gamma_2}
  }{t-ptr-l-split}
  %
  \typerule{ptrRSplit}{
    \Gammas = \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\ptr},\Gammas = \src{x:\wptr,\Gamma_1}\circ\src{x:\ptr},\src{\Gamma_2}
  }{t-ptr-r-split}
  \end{center}
}{w-ctx-split}{Context Splitting of $\mmlA$ typing contexts.}

\myfig{
  \judgbox{\typechecks{\Gamma}{e}{\taus}}{,,Under environment $\Gammas$ the expression $\src{e}$ has type $\taus$.''}

  \begin{center}
  \typerule{$t-\src{var}$}{
  \src{\noptr{\Gamma_1}}&
  \src{\noptr{x:\tau,\hole{\cdot}}}&
  \src{\noptr{\Gamma_2}}
	}{
    \typechecks{\Gamma_1,x:\tau,\Gamma_2}{x}{\tau}
	}{t-var}
  %
  \typerule{$t-\nat$}{
    \src{\noptr{\Gamma}}
  }{
    \typechecks{\Gamma}{n}{\nat}
  }{t-nat}
  %
  \typerule{$t-\src{\oplus}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{e_1\oplus e_2}{\nat}
  }{t-binop}
  %
  \typerule{$t-get$}{
    \typechecks{\Gamma_2}{x}{\wptr} &
    \typechecks{\Gamma_1}{e}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{x[e]}{\nat}
  }{t-get}
  %
  \typerule{$t-set$}{
    \typechecks{\Gamma_3}{x}{\wptr} &
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{(\Gamma_1\circ\Gamma_2)\circ\Gamma_3}{x[e_1]\leftarrow e_2}{\nat}
  }{t-set}
  %
  \typerule{$t-\src{let}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{x:\nat,\Gamma_2}{e_2}{\tau}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{let\ x=e_1\ in\ e_2}{\tau}
  }{t-let}
  %
  \typerule{$t-\src{new}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{x:\ptr,\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{let\ x=new\ e_1\ in\ e_2}{nat}
  }{w-t-new}
  %
  \typerule{$t-\src{delete}$}{
    \src{\noptr{\Gamma_1}} & \src{\noptr{\Gamma_2}}
  }{
    \typechecks{\Gamma_1,x:\ptr,\Gamma_2}{delete\ x}{\nat}
  }{w-t-delete}
  %
  \end{center}
}{w-expr-ty}{Checking of $\mmlAs$ expressions.}

\myfig{
  \begin{center}
    \typerule{$program$}{
      \vdash_\copyright\src{component\ e_p}&
      \vdash_\copyright\src{context\ e_0\ e_1}
    }{
      \vdash_\copyright\src{prog\ e_0\ e_p\ e_1}
    }{w-program}
    %
    \typerule{$component$}{
      closed\ \{\src{x}\}\ \src{e}
    }{
      \vdash_\copyright\src{component\ e}
    }{w-component}
    %
    \typerule{$context$}{
      closed\ \emptyset\ \src{e_0} &
      closed\ \{\src{y}\}\ \src{e_1}
    }{
      \vdash_\copyright\src{context\ e_0\ e_1}
    }{w-context}
  \end{center}
}{w-programs}{$\mmlAs$ programs, contexts, and components.}

\myfig{
%  \judgbox{\typechecks{\Gamma}{C}{\tau_C}{\Gamma'}}{,,Under environment $\Gammas$, the context $\src{C}$ has type $\src{\tau_{C}}$ and yields environment $\src{\Gamma'}$.''}

  \begin{center}
  \typerule{$t-\text{ctx}$}{
    \typechecks{}{e_1}{\nat}&
    \typechecks{y:\nat}{e_2}{\nat}
	}{
  \typechecks{}{context\ e_1\ e_2}{\nat\to\nat}
	}{w-t-ctx}
  %
  \typerule{$t-\text{component}$}{
    \typechecks{x:\nat}{e}{\nat}&
	}{
  \typechecks{}{component\ e}{\nat}
	}{w-t-comp}
  %
  \typerule{$t-\text{wprog}$}{
    \typechecks{}{context\ e_0\ e_1}{\nat\to\nat} &
    \typechecks{}{component\ e_p}{\nat}
	}{
    \typechecks{}{prog\ e_0\ e_p\ e_1}{\nat}
	}{w-t-prog}
  %
  \typerule{$t-\text{prog}$}{
    \typechecks{}{\Delta}{\Gamma}&
    \typechecks{\Gamma}{e}{\nat}
	}{
  \typechecks{}{H;\Delta\triangleright e}{\nat}
	}{w-t-prog}
  \end{center}
}{w-program-ty}{Checking of $\mmlAs$ contexts, components, programs, and whole programs.}

\myfig{
  \begin{center}
    \typerule{$T\text{empty}\Delta$}{
    }{
    \typechecks{}{\hole{\cdot}}{\hole{\cdot}}
    }{t-empty-store}
    %
    \typerule{$T\text{ref}\nat$}{
    \typechecks{}{\Delta}{\Gamma}
    }{
    \typechecks{}{x\mapsto\loc_\poisonless,\Delta}{x:\ptr,\Gamma}
    }{t-ptr-store}
    %
    \typerule{$T\text{ref}\nat\text{poison}$}{
    \typechecks{}{\Delta}{\Gamma}
    }{
    \typechecks{}{x\mapsto\loc_\poisoned,\Delta}{\Gamma}
    }{t-ptr-store}
  \end{center}
}{store-ty}{$\mmlAs$ store typing.}

\myfig{
  \begin{center}
    $$
    \typerule{plugging}{
      \typechecks{}{prog\ e_0\ e_p\ e_1}{\nat}
    }{
    \src{context}\ (\src{e_0})\ (\src{e_1})\src{\linker}{\src{component\ e_p}} = \src{prog\ e_0\ e_p\ e_1}
    }{src-plugging}
    $$
  \end{center}
}{w-plugging-s}{$\mmlAs$ plugging of contexts and components.}

\subsubsection{Dynamic Semantics}

\myfig{
  \begin{center}
  \typerule{store-qualify}{
    \src{\Delta^\diamond}=\src{\Delta'}
  }{
    \src{(H;\Delta)^\diamond}=\src{H;\Delta'}
  }{t-store-q}
  %
  \typerule{store-mark-nil}{
  }{
    \src{\hole{\cdot}^\diamond}=\src{\hole{\cdot}}
  }{t-store-mark-nil}
  %
  \typerule{store-mark-cons}{
    \src{\Delta^\diamond}=\src{\Delta'}
  }{
    \src{(x\mapsto\loc_\rho,\Delta)^\diamond}=\src{x\mapsto\loc_\rho^\diamond,\Delta'}
  }{t-store-mark-cons}
  \end{center}
}{store-qualified}{$\mmlAs$ state importance marker.}
\myfig{
  \begin{gather*}
  \begin{aligned}
  \mi{Events}~\src{a} \bnfdef& \src{\emptyevent} \mid \src{Alloc\ \loc\ n} \mid \src{Dealloc\ \loc} \mid \src{Read\ \loc\ n} \mid \src{Set\ \loc\ n} \\
  \mi{Qualified\ Events}~\src{q} \bnfdef& \src{a} \mid \src{a^\diamond}
  \end{aligned}
  \end{gather*}
}{w-events}{Events of $\mmlAs$.}

\myfig{
  \begin{gather*}
    \begin{aligned}
      \src{K}\bnfdef &\ \src{\hole{\cdot}}\mid \src{K\oplus e}\mid \src{v\oplus E}\mid \src{x[K]}\mid
      \src{let\ x=K\ in\ e}\\
                     &\ \mid\src{x[K]\leftarrow e}\mid \src{x[v]\leftarrow K}\mid \src{let\ x=new\ K\ in\ e}
    \end{aligned}
  \end{gather*}
}{w-expr-eval-ectx}{Evaluation Contexts of $\mmlAs$.}

\myfig{
  \judgbox{\execs[]{\configs}{K[e]}{\configs'}{K[e']}{q}}{,,Given an evaluation context $\src{K}$ and an expression $\src{e}$,\\it evaluates under configuration $\configs$ to $\src{e'}$ and new\\configuration $\src{\configs'}$ in context $\src{K}$, emitting event $\src{q}$.''}
  \judgbox{\exprevals{\configs}{e}{\configs'}{e'}{q}}{,,Expression $\src{e}$ evaluates under configuration $\configs$ to $\src{e'}$ and new\\configuration $\src{\configs'}$, emitting event $\src{q}$.''}
  %
  \typerule{$e-\text{ctx}$}{
    \exprevals{\configs}{e}{\configs'}{e'}{a}
  }{
    \execs[]{\configs}{K[e]}{\configs'}{K[e']}{a}
  }{w-e-ectx}
  %
  \typerule{$e-\src{\oplus}$}{
    \src{n_1}+\src{n_2}=\src{n_3}
  }{
    \exprevals{\configs}{n_1+n_2}{\configs}{n_3}{\emptyevent}
  }{w-e-oplus}
  % TODO
  \typerule{$e-\src{get}$}{
    \src{\loc}\in\text{dom }\src{H}\implies\src{v}=\src{H}(\src{\loc+n}) &
    \src{\loc}\not\in\text{dom }\src{H}\implies\src{v}=\src{1729}
  }{
    \exprevals{\sconfig{H}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{x[n]}{\sconfig{H}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{v}{Read\ \loc\ n}
  }{w-e-get}
  %
  \typerule{$e-\src{set}$}{
    \src{H'} = \src{H}(\src{\loc+n}\mapsto \src{v})
  }{
    \exprevals{\sconfig{H}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{x[n]\leftarrow v}{\sconfig{H'}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{v}{Set\ \loc\ n\ v}
  }{w-e-set}
  %
  \typerule{$e-\src{let}-\src{x}$}{
  }{
    \exprevals{\sconfig{H}{\Delta}}{let\ x=y\ in\ e}{\sconfig{H}{\Delta}}{e[y/x]}{\emptyevent}
  }{w-e-let-x}
  %
  \typerule{$e-\src{let}-\src{v}$}{
  }{
    \exprevals{\sconfig{H}{\Delta}}{let\ x=v\ in\ e}{\sconfig{H}{\Delta}}{e[v/x]}{\emptyevent}
  }{w-e-let-v}
  %
  \typerule{$e-\src{delete}$}{
  }{
    \exprevals{\sconfig{H}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{delete\ x}{\sconfig{H}{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}{0}{Dealloc\ \loc}
  }{w-e-let-new}
  %
  \typerule{$e-\src{new}$}{
    \text{fresh}\ \src{\loc}&
    \text{fresh}\ \src{z} &
    \src{H'} = \src{H} \ll \src{n} &
  }{
  \exprevals{\sconfig{H}{\Delta}}{let\ x=new\ n\ in\ e}{\sconfig{H'}{z\mapsto \loc_\poisonless,\Delta}}{e[z/x]}{Alloc\ \loc\ n}
  }{w-e-let-new}
  %
}{w-expr-eval}{Evaluation of $\mmlAs$ expressions.}

\myfig{
  $$
  \begin{array}{lllcl}
    H & \ll & n & = & match\ n\ with \\
         &   &   & | & 0 \Rightarrow H \\
         &   &   & | & S m \Rightarrow (\grow{H}{m}) :: 0 \\
  \end{array}
  $$
  \vspace{0.5cm}

  $$
  \begin{array}{lllcl}
           & H & n & = & match\ n,H\ with \\
           &   &   & | & \_,[\ ] \Rightarrow None \\
           &   &   & | & 0,x :: \_ \Rightarrow Some\ x \\
           &   &   & | & S m,x :: xs \Rightarrow xs \ m \\
  \end{array}
  $$
  \vspace{0.5cm}

  $$
  \begin{array}{lllcrl}
    H & (n & \mapsto & v) = & match\ H\        & with  \\
           &   &   & | & [\ ] \Rightarrow    & [\ ] \\
           &   &   & | & x :: xs \Rightarrow & match\ n\ with \\
           &   &   &   &                   | & 0 \Rightarrow v :: xs \\
           &   &   &   &                   | & S m \Rightarrow x :: (xs\ (m\mapsto v)) \\
  \end{array}
  $$
}{w-step-util}{Helper functions for heap manipulation.}

\myfig{
  \begin{center}
    \judgbox{\execs{\configs}{e}{\configs'}{e'}{\bar{a}}}{,,Expression $\src{e}$ evaluates under configuration $\configs$ to $\src{e'}$ and\\new configuration $\src{\configs'}$, emitting list of events $\src{\bar{a}}$.''}
    %
    \typerule{$e-\text{refl}$}{
    }{
      \execs{\configs}{e}{\configs}{e}{\hole{\cdot}}
    }{w-e-trans}
    \typerule{$e-\text{trans}$}{
      \execs[]{\configs}{e}{\configs'}{e'}{a}&
      \execs{\configs'}{e'}{\configs''}{e''}{\bar{a}}&
    }{
      \execs{\configs}{e}{\configs''}{e''}{a \cdot \bar{a}}
    }{w-e-trans}
  \end{center}
}{w-steps}{Trace prefix generation given a $\mmlA$ program using the reflexive-transitive closure.}

\myfig{
  \begin{center}
  \typerule{$e-\text{wprog}$}{
    \typechecks{}{prog\ e_0\ e_p\ e_1}{\nat} &
    \execs{\hole{\cdot};\hole{\cdot}}{e_0}{\configs_0}{v_0}{\overline{a_0}} \\
    \execs{\configs_0^\diamond}{e_p[v_0/x]}{\configs_p}{v_p}{\overline{a_p}} &
    \execs{\configs_p}{e_1[v_p/y]}{\configs_1}{v_1}{\overline{a_1}} &
%    \execs{\hole{\cdot};\hole{\cdot}}{let\ y=let\ x=e_0^\diamond\ in\ e_p\ in\ e_1^\diamond}{\configs}{v}{\overline{a}}
  }{
    \wexecs{prog\ e_0\ e_p\ e_1}{\configs_1}{v_1}{\overline{a_0^\diamond\cdot a_p\cdot a_1^\diamond}}
  }{w-e-prog}
  \end{center}
}{wprog-run}{Running a whole $\mmlA$ program.}
\MK{\Cref{fig:wprog-run}: Maybe mark unimportant stuff in $\src{\Omega_1}$}

\subsubsection{\gls*{tms} Monitor}
\myfig{
  \begin{gather*}
    \begin{aligned}
      \mi{Abstract\ References}~L \subseteq& \nat \hspace{0.5cm}
      \mi{Abstract\ Store}~\tmsmonitor =\{A : L, F : L\} \\
      \mi{Abstract\ Events}~a \bnfdef& \emptyevent \mid \text{Alloc}\ \loc \mid \text{Dealloc}\ \loc \mid \text{Use}\ \loc \\
      \mi{References\ Agreement}~\delta_{\text{tms}} :& \src{L}\to L \\[0.6cm]
      \tmsmonitor\subseteq_F \tmsmonitor['] &\text{ iff } \tmsmonitor[.F] \subseteq \tmsmonitor['.F]\\
      a\not\in \tmsmonitor['] &\text{ iff } a \not\in {\tmsmonitor['.A]} \wedge a \not\in {\tmsmonitor['.F]}\\
      \{\loc\}\cup \tmsmonitor &= \{A : \{\loc\}\cup \tmsmonitor[.A], F : \tmsmonitor[.F]\}\\
    \end{aligned}
  \end{gather*}
}{tms-monitor}{\gls{tms} Monitor.}

\myfig{
  \begin{center}
    \typerule{TMS-Empty}{
    }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\varepsilon}
    }{tms-empty}
    %
    \typerule{TMS-Use}{
      \loc\in \tmsmonitor[.A] &
      \loc\not\in \tmsmonitor[.F] &
    }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\text{Use}\ \loc}
    }{tms-use}
    %
    \typerule{TMS-Alloc}{
      \tmsmonitor[']=\left\{A:\tmsmonitor[.A]\cup\left\{\loc\right\}, F:\tmsmonitor[.F]\right\}&
      \loc\not\in \tmsmonitor&
    }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\text{Alloc}\ \loc}
    }{tms-alloc}
    %
    \typerule{TMS-Dealloc}{
      \loc\in \tmsmonitor[.A] &
      \loc\not\in \tmsmonitor[.F] &
      \tmsmonitor[']=\left\{A:\tmsmonitor[.A]\setminus\left\{\loc\right\},F: \tmsmonitor[.F]\right\}
    }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\text{Dealloc}\ \loc}
    }{tms-dealloc}
    %
    \typerule{TMS-Refl}{
    }{
    \monitorcheck{\tmsmonitor}{\tmsmonitor}{\hole{\cdot}}
    }{tms-refl}
    %
    \typerule{TMS-Trans}{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{a}&
    \monitorcheck{\tmsmonitor[']}{\tmsmonitor['']}{\bar{a}}&
    }{
    \monitorcheck{\tmsmonitor}{\tmsmonitor['']}{a\cdot\bar{a}}
    }{tms-trans}
  \end{center}
}{tms-step}{Steps of \gls{tms} Monitor.}


\myfig{
  \begin{center}
    \typerule{TMS-Internal-Authentic}{
    }{
      \tmstraceagree{\src{\varepsilon}}{\varepsilon}
    }{tms-internal-auth}
    %
    \typerule{TMS-Alloc-Authentic}{
      \delta_{\text{tms}}(\src{\loc})=\loc
    }{
      \tmstraceagree{\src{Alloc\ \loc\ n}}{\text{Alloc}\ \loc}
    }{tms-alloc-auth}
    %
    \typerule{TMS-Dealloc-Authentic}{
      \delta_{\text{tms}}(\src{\loc})=\loc
    }{
    \tmstraceagree{\src{Dealloc\ \loc}}{\text{Dealloc}\ \loc}
    }{tms-dealloc-auth}
    %
    \typerule{TMS-Get-Authentic}{
      \delta_{\text{tms}}(\src{\loc})=\loc
    }{
    \tmstraceagree{\src{Get\ \loc\ n}}{\text{Use}\ \loc}
    }{tms-get-auth}
    %
    \typerule{TMS-Set-Authentic}{
      \delta_{\text{tms}}(\src{\loc})=\loc
    }{
      \tmstraceagree{\src{Set\ \loc\ n\ v}}{\text{Use}\ \loc}
    }{tms-set-auth}
    %
    \typerule{TMS-Refl-Authentic}{
    }{
    \tmstraceagree{\src{\hole{\cdot}}}{\hole{\cdot}}
    }{tms-refl-auth}
    %
    \typerule{TMS-Trans-Authentic}{
      \tmstraceagree{\src{a}}{a} &
      \tmstraceagree{\src{\bar{a}}}{\bar{a}}
    }{
      \tmstraceagree{\src{a}\cdot\src{\bar{a}}}{a\cdot\bar{a}}
    }{tms-trans-auth}
    %
    \typerule{TMS-Trans-Authentic-Ignore}{
      \tmstraceagree{\src{\bar{a}}}{\bar{a}}
    }{
      \tmstraceagree{\src{a^\diamond}\cdot\src{\bar{a}}}{\bar{a}}
    }{tms-trans-auth-ignore}
  \end{center}
}{tms-trace-agreement}{Trace Agreement.}

\myfig{
  \begin{center}
    \typerule{Empty-Agree}{
    }{
      \storeagreetms{\emptyset}{\src{\hole{\cdot}}}
    }{store-empty-agree}
    %
    \typerule{Cons-Agree}{
      \delta_{\text{tms}}\left(\src{\loc}\right)=\loc&
      \storeagreetms{\tmsmonitor}{\src{\Delta}}
    }{
      \storeagreetms{\left\{\loc\right\}\cup \tmsmonitor}{\src{x\mapsto\loc_\poisonless,\Delta}}
    }{store-cons-agree}
    %
    \typerule{Poison-Agree}{
      \delta_{\text{tms}}\left(\src{\loc}\right)=\loc&
      \storeagreetms{\tmsmonitor}{\src{\Delta}}
    }{
      \storeagreetms{\tmsmonitor}{\src{x\mapsto\loc_\poisoned,\Delta}}
    }{store-poison-agree}
    %
    \typerule{Ignore-Agree}{
      \storeagreetms{\tmsmonitor}{\src{\Delta}}
    }{
      \storeagreetms{\tmsmonitor}{\src{x\mapsto\loc_\rho^\diamond,\Delta}}
    }{store-ignore-agree}
  \end{center}
}{tms-store-agreement}{Store Agreement.}

\begin{definition}[\gls{tms} on Traces]\label{def:tempmemsafe}
  We define the property $\src{tmsafe}(\src{\trace})$ as a conjunction of the following conditions:
  \begin{itemize}
    \item $\src{Alloc\ \loc\ s}\le_{\src{\trace}}\src{Dealloc\ \loc}$
    \item $\neg(\src{Read\ \loc\ n}\le_{\src{\trace}}\src{Alloc\ \loc\ s})$
    \item $\neg(\src{Set\ \loc\ n\ v}\le_{\src{\trace}}\src{Alloc\ \loc\ s})$
    \item $\neg(\src{Dealloc\ \loc}\le_{\src{\trace}}\src{Read\ \loc\ n})$
    \item $\neg(\src{Dealloc\ \loc}\le_{\src{\trace}}\src{Set\ \loc\ n\ v})$
    \item $\src{Dealloc\ \loc}\in!\;\src{\trace}$
    \item $\src{Alloc\ \loc\ s}\in!\;\src{\trace}$
    % \makebox(0,0){\put(0,3.0\normalbaselineskip){ %
    % $\left.\rule{0pt}{1.32\normalbaselineskip}\right\}$ no reallocs, references are unique}}
  \end{itemize}
\end{definition}
% relaxed temporal memory safety       -> define garbage collector
% generalize this over Γ, τ
% might need an 'invariant'  -> connect typing to evaluation states
% might need to do an induction on evaluation steps

% might not need to do an induction at the general step, but for the primitive step we need it

\begin{definition}[Spatial Memory Safety]\label{def:spatmemsafe}
  We define the property $\src{smsafe}\left(\src{\trace}\right)$ as a conjunction of the following conditions:
  \begin{itemize}
    \item If $\src{Alloc\ \loc\ s}\in\src{\trace}$ and $\src{Read\ \loc\ n}\in\src{\trace}$, then $\src{n}<\src{s}$
    \item If $\src{Alloc\ \loc\ s}\in\src{\trace}$ and $\src{Set\ \loc\ n\ v}\in\src{\trace}$, then $\src{n}<\src{s}$
  \end{itemize}
\end{definition}

\begin{importanttheorem}[$\mmlA$ is \gls{tms} via Monitor]
  If
  \begin{assumptions}
  \item $\src{prog\ e_0\ e_p\ e_1}=\src{context}\ (\src{e_0})\ (\src{e_1})\src{\linker}{\src{component\ e_p}}$
  \item\label{asm:mmlatmsviamonitor:run} $\wexecs{prog\ e_0\ e_p\ e_1}{\configs}{v}{\bar{a}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\texttt{TMS}(\src{\bar{a}})$
  \end{goals}.
\end{importanttheorem}
For the proof of above see \Cref{thm:mmlAs:tmssafe} in \Cref{sec:mmla:aux}.

\begin{importanttheorem}[$\mmlAs$ is not spatially memory safe]
  There is a well-typed $\mmlAs$ component which does not robustly satisfy \Cref{def:spatmemsafe}:
  $\rsat{\src{p}}{\src{smsafe}}$
\end{importanttheorem}
\begin{proof}
  Pick the component $\src{comp\ let\ z=new\ x\ in\ let\ w = z[1337]\ in\ let\ \_ = delete\ z\ in\ w}$.\\[0.3cm]
  It typechecks.\\[0.3cm]
  Now pick $\src{context\ }(\src{42})\ (\src{y})$.\\[0.3cm]
  Plugging yields \\$\src{prog}\ (\src{let\ y=let\ x=42\ in\ let\ z=new\ x\ in\ let\ w = z[1337]\ in\ let\ \_ = delete\ z\ in\ w\ in\ y})$.\\[0.3cm]
  Running the whole program yields trace prefix\\$\src{\trace}=\src{\emptyevent}\cdot\src{Alloc\ \loc\ 42}\cdot\src{Read\ \loc\ 1337}\cdot\src{\emptyevent}\cdot\src{Dealloc\ \loc}\cdot\src{\emptyevent}\cdot\src{\emptyevent}$.\\[0.3cm]
  \Cref{def:spatmemsafe} requires $\src{Alloc\ \loc\ 42}\in\src{\trace}$ and $\src{Read\ \loc\ 1337}$, which hold.\\[0.3cm]
  But, $\src{1337}\not<\src{42}$, hence $\nrsat{\src{p}}{\src{smsafe}}$.
\end{proof}

\subsubsection{Auxiliary Definitions and Lemmas}\label{sec:mmla:aux}

\begin{lemma}[Weaken Closedness]
  For any two sets $X,Y$ and an expression $\src{e}$, when
  \begin{assumptions}
    \item $closed\ X\ \src{e}$
    \item $X\subseteq Y$
  \end{assumptions}
  Then
  \begin{goals}
    \item $closed\ Y\ \src{e}$
  \end{goals}
\end{lemma}
\begin{proof}
  Structural induction on $\src{e}$.
\end{proof}

We now define temporal and spatial memory safety in terms of traces on events $\src{e}$.

\begin{definition}[Occurence]
  Given an event $e$ and a trace $\trace$, the event $e$ occurs in $\trace$, written $e\in\trace$, iff

  $\exists n, \trace[n]=e$
\end{definition}

\begin{definition}[Unicity]
  Given an event $e$ and a trace $\trace$, the event $e$ occurs exactly once in $\trace$, written $e!_{\trace}$, iff

  $\exists n, \trace[n]=e \wedge \nexists m, n\not= m \wedge \trace[m] = e$
\end{definition}

\begin{definition}[Sequentiality]
  Given two events $e_{0},e_{1}$ and a trace $\trace$, event $e_{0}$ occurs before $e_{1}$ in $\trace$, written
  $e_{0}\le_{\trace}e_{1}$, iff

  $\exists n, \trace[n] = e_{0}\implies \exists m, \trace[m] = e_{1} \wedge n<m$
\end{definition}

\begin{lemma}[Authentic Weaken]
  If
  \begin{assumptions}
    \item $\tmstraceagree[\delta']{\src{\trace}}{\trace}$
    \item $\delta_{\text{tms}}'\subseteq\delta_{\text{tms}}''$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmstraceagree[\delta'']{\src{\trace}}{\trace}$
  \end{goals}
\end{lemma}
\begin{proof}
  Induction on $\tmstraceagree[\delta']{\src{\trace}}{\trace}$.
\end{proof}

\begin{lemma}[Monitor Step Subset]\label{lem:monitor-step-subset}
  If
  \begin{assumptions}
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{a}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmsmonitor\subseteq_F \tmsmonitor[']$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Monitor Steps Subset]\label{lem:monitor-steps-subset}
  If
  \begin{assumptions}
    \item $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{a}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmsmonitor\subseteq_F \tmsmonitor[']$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy induction on $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{a}$ using \Thmref{lem:monitor-step-subset}.
\end{proof}

\begin{lemma}[Monitor Step Back No-Elem Propagation]\label{lem:monitor-step-no-elem-prop}
  If
  \begin{assumptions}
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{a}$
    \item $\loc\not\in \tmsmonitor['].A$
    \item $\loc\not\in \tmsmonitor['].F$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\loc\not\in \tmsmonitor[.A]$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Monitor Steps Back No-Elem Propagation]\label{lem:monitor-steps-no-elem-prop}
  If
  \begin{assumptions}
    \item $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{a}$
    \item $\loc\not\in \tmsmonitor['.A]$
    \item $\loc\not\in \tmsmonitor['.F]$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\loc\not\in \tmsmonitor[.A]$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}


\begin{lemma}[$\alpha$-conv. Typing]\label{lem:alpha-conv-typing}
  If
  \begin{assumptions}
    \item $\typechecks{\Gamma}{e}{\tau}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{\Gamma[z:\tau'/x:\tau]}{e[z/x]}{\tau}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Substitution]\label{lem:substitution}
  If
  \begin{assumptions}
    \item $\typechecks{x:\tau',\Gamma_1}{e}{\tau}$
    \item $\typechecks{\Gamma_2}{v}{\tau'}$
    \item $\src{\Gamma_3}=\src{\Gamma_1}\circ\src{\Gamma_2}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{\Gamma_3}{e[v/x]}{\tau}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Base Preservation]\label{lem:base-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\nat}}$
    \item $\exprevals{\configs}{e}{\configs'}{e'}{a}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\nat}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Ctx Preservation]\label{lem:ctx-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\nat}}$
    \item $\execs[]{\configs}{e}{\configs'}{e'}{a}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\nat}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Steps Preservation]\label{lem:steps-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\nat}}$
    \item $\execs{\configs}{e}{\configs'}{e'}{a}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\nat}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Progress]
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\nat}}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\src{e}=\src{v}$ or $\exists \src{\Omega'}\ \src{e'}\ \src{a}, \execs{\configs}{e}{\configs'}{e'}{a}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Base \gls{tms} via Monitor]
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\nat}}$
    \item $\exprevals{\configs}{e}{\configs'}{e'}{a}$
    \item $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists a\ \delta_{\text{tms}}'\ \tmsmonitor['],$
  \begin{goals}
    \item $\delta_{\text{tms}}\subseteq\delta_{\text{tms}}'$
    \item $\tmstraceagree[\delta']{a}{\src{a}}$
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{a}$
    \item $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
  Induction on $\exprevals{\configs}{e}{\configs'}{e'}{a}$.
  \begin{description}
\item[$\src{e}=\src{free\ x}$:]
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}\triangleright \src{free\ x}}{\nat}$
    \item\label[ass]{asm:basetmsmonitor:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}$
  \end{assumptions}
  Then $\exists a\ \delta_{\text{tms}}'\ \tmsmonitor['],$
  \begin{goals}
    \item\label[goal]{goal:basetmsmonitor:subseteq} $\delta_{\text{tms}}\subseteq\delta_{\text{tms}}'$
    \item\label[goal]{goal:basetmsmonitor:tmstraceagree} $\traceagree[\delta_{\text{tms}}']{a}{\src{Dealloc\ \loc}}$
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{a}$
    \item $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}$
  \end{goals}.

  Choose $a=\text{Dealloc\ }\loc$ and $\delta_{\text{tms}}'=\delta_{\text{tms}}$.

  \Cref{goal:basetmsmonitor:subseteq}, $\delta_{\text{tms}}\subseteq\delta_{\text{tms}}$, follows trivially.

  For $\tmstraceagree{\text{Dealloc}\ \loc}{\src{Dealloc\ \loc}}$ (\Cref{goal:basetmsmonitor:traceagree}), apply \Cref{tr:tms-dealloc-auth}, where $\delta_{\text{tms}}(\src{\loc})=\loc$ follows by inverting \Cref{asm:basetmsmonitor:storeagree}.

  The inversion yields two cases:
  \begin{description}
\item[\Cref{tr:store-cons-agree}:]
  If
  \begin{assumptions}
  \item $\typechecks{}{\src{H;\Delta_1},\src{x\mapsto\loc_\poisonless},\src{\Delta_2}\triangleright \src{free\ x}}{\nat}$
  \item $\storeagreetms{\tmsmonitor[_1]}{\src{\Delta_1}}$
  \item $\delta_{\text{tms}}(\src{\loc})=\loc$
  \item $\storeagreetms{\tmsmonitor[_2]}{\src{\Delta_2}}$
  \item $\tmsmonitor=\tmsmonitor[_1]\cup\left\{\loc\right\}\cup \tmsmonitor[_2]$
  \end{assumptions}
  then $\exists \tmsmonitor[']$,
  \begin{goals}
  \item\label[goal]{goal:basetmsmonitor:monitorcheck1} $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\text{Dealloc}\ \loc}$
  \item\label[goal]{goal:basetmsmonitor:storeagree1} $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}$
  \end{goals}.

  Choose $\tmsmonitor[']=\tmsmonitor[_1]\cup \tmsmonitor[_2]$.

  \Cref{goal:basetmsmonitor:monitorcheck1}, $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\text{Dealloc}\ \loc}$, follows immediately by \Cref{tr:tms-dealloc}.

  \Cref{goal:basetmsmonitor:storeagree1}, $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}$, follows immediately by \Cref{tr:store-poison-agree}.

\item[\Cref{tr:store-poison-agree}:]
  If
  \begin{assumptions}
  \item\label[ass]{asm:basetmsmonitor:typing} $\typechecks{}{\src{H;\Delta_1},\src{x\mapsto\loc_\poisoned},\src{\Delta_2}\triangleright \src{free\ x}}{\nat}$
  \item $\storeagreetms{\tmsmonitor[_1]}{\src{\Delta_1}}$
  \item $\delta_{\text{tms}}(\src{\loc})=\loc$
  \item $\storeagreetms{\tmsmonitor[_2]}{\src{\Delta_2}}$
  \item $\tmsmonitor=\tmsmonitor[_1]\cup \tmsmonitor[_2]$
  \end{assumptions}
  then $\exists \tmsmonitor[']$,
  \begin{goals}
  \item\label[goal]{goal:basetmsmonitor:monitorcheck2} $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\text{Dealloc}\ \loc}$
  \item\label[goal]{goal:basetmsmonitor:storeagree2} $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}$
  \end{goals}.

  Invert \Cref{asm:basetmsmonitor:typing} to get
  \begin{assumptions}
  \item\label[ass]{asm:basetmsmonitor:storechecks} $\typechecks{}{\src{H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}{\Gammas}$
  \item\label[ass]{asm:basetmsmonitor:freechecks} $\typechecks{\Gammas}{free\ x}{\nat}$
  \end{assumptions}.

Due to \Cref{asm:basetmsmonitor:storechecks}, we know $\src{x:\ptr}\not\in\Gammas$.

But, that contradicts \Cref{asm:basetmsmonitor:freechecks}.
\end{description}

\end{description}
\end{incompleteproof}

\begin{lemma}[Ctx \gls{tms} via Monitor]
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\nat}}$
    \item $\execs[]{\configs}{e}{\configs'}{e'}{a}$
    \item $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists a\ \delta_{\text{tms}}'\ \tmsmonitor['],$
  \begin{goals}
    \item $\delta_{\text{tms}}\subseteq\delta_{\text{tms}}'$
    \item $\tmstraceagree[\delta']{a}{\src{a}}$
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{a}$
    \item $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Steps \gls{tms} via Monitor]\label{lem:generaltms:monitor}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\nat}}$
    \item $\execs{\configs}{e}{\configs'}{e'}{\overline{a}}$
    \item $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists \overline{a}\ \delta_{\text{tms}}'\ \tmsmonitor['],$
  \begin{goals}
    \item $\delta_{\text{tms}}\subseteq\delta_{\text{tms}}'$
    \item $\tmstraceagree[\delta']{\overline{a}}{\src{\overline{a}}}$
    \item $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\overline{a}}$
    \item $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{definition}[Trace is temporal memory safe via monitor.]\label{def:src:trace:tms}
  We say $\texttt{TMS}(\src{\bar{a}})$ iff $\exists \delta\ \bar{a}\ \tmsmonitor$ such that:
  \begin{itemize}
    \item $\tmstraceagree{\bar{a}}{\src{\bar{a}}}$
    \item and $\monitorcheck{\emptyset}{\tmsmonitor}{\bar{a}}$
  \end{itemize}
\end{definition}


\begin{lemma}[Empty Agrees with $\src{\Delta^\diamond}$]\label{lem:storeagree:emptyignore}
  $$\storeagreetms[\emptyset]{\emptyset}{\src{\Delta^\diamond}}$$
\end{lemma}
\begin{proof}
By induction on $\src{\Delta^\diamond}$ and using \Cref{tr:store-empty-agree,tr:store-ignore-agree}.
\end{proof}

\begin{theorem}[$\mmlAs$ is \gls{tms} via Monitor]\label{thm:mmlAs:tmssafe}
  If
  \begin{assumptions}
  \item $\src{prog\ e_0\ e_p\ e_1}=\src{context}\ (\src{e_0})\ (\src{e_1})\src{\linker}{\src{component\ e_p}}$
  \item\label{asm:mmlatmsviamonitor:run} $\wexecs{prog\ e_0\ e_p\ e_1}{\configs}{v}{\bar{a}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\texttt{TMS}(\src{\bar{a}})$
  \end{goals}.
\end{theorem}
\begin{proof}
  Inverting \Cref{asm:mmlatmsviamonitor:run}, we get 
  \begin{passumptions}{H}
    \item $\typechecks{}{prog\ e_0\ e_p\ e_1}{\nat}$
    %\ite]\label[ass]{asm:mmlatmsviamonitor:run2} $\execs{\hole{\cdot};\hole{\cdot}}{let\ y=let\ x=e_0^\diamond\ in\ e_p\ in\ e_1^\diamond}{\configs}{v}{\overline{a}}$
    \item\label[ass]{asm:mmlatmsviamonitor:exec0} $\execs{\hole{\cdot};\hole{\cdot}}{e_0}{\configs_0}{v_0}{\overline{a_0}}$
    \item\label[ass]{asm:mmlatmsviamonitor:execp} $\execs{\configs_0^\diamond}{e_p[v_0/x]}{\configs_p}{v_p}{\overline{a_p}}$
    \item\label[ass]{asm:mmlatmsviamonitor:exec1} $\execs{\configs_p}{e_1[v_p/y]}{\configs_1}{v_1}{\overline{a_1}}$
    \item $\src{\overline{a}}=\src{\overline{a_0^\diamond}}\cdot\src{\overline{a_p}}\cdot\src{\overline{a_1^\diamond}}$
  \end{passumptions}
  By \Cref{tr:store-empty-agree}:
  \begin{equation}
    \storeagreetms[\emptyset]{\emptyset}{\src{\emptyset}}\label{asm:mmlatmsviamonitor:agreeempty}
  \end{equation}

  Invert $\typechecks{}{prog\ e_0\ e_p\ e_1}{\nat}$ and invert the subsequent result to get:
  \begin{passumptions}{H^t}
    \item\label[ass]{asm:mmlatmsviamonitor:type0} $\typechecks{\hole{\cdot}}{e_0}{\nat}$
    \item\label[ass]{asm:mmlatmsviamonitor:typep} $\typechecks{x:nat}{e_p}{\nat}$
    \item\label[ass]{asm:mmlatmsviamonitor:type1} $\typechecks{y:nat}{e_1}{\nat}$
  \end{passumptions}

  By \Cref{tr:t-empty-store} and \Cref{asm:mmlatmsviamonitor:type1}, we have 
  \begin{equation}
    \typechecks{}{\hole{\cdot}\triangleright e_0}{\nat}\label{asm:mmlatmsviamonitor:storetypenil}
  \end{equation}

  Plugging \Cref{asm:mmlatmsviamonitor:type0} and \Cref{asm:mmlatmsviamonitor:exec0} into \Thmref{lem:steps-preservation} and inverting the result, we obtain
  \begin{passumptions}{G}
    \item $\typechecks{}{\Omega_0.\Delta}{\Gamma_0}$
    \item\label[ass]{asm:mmlatmsviamonitor:vtype} $\typechecks{\Gamma_0}{v_0}{\nat}$
  \end{passumptions}

  Note that $\src{\Gamma_0} = \src{\hole{\cdot}} \circ \src{\Gamma_0}$ which we'll use promptly.\MK{technical lemma needed}

  Using \Cref{asm:mmlatmsviamonitor:type1}, \Cref{asm:mmlatmsviamonitor:vtype}, and the above fact, we apply \Thmref{lem:substitution} to obtain:
  \begin{equation}
    \typechecks{\Gamma_0}{e_p[v_0/x]}{\nat}\label{asm:mmlatmsviamonitor:typesubstx}
  \end{equation}
  By \Thmref{lem:storeagree:emptyignore}:
  \begin{equation}
    \storeagreetms[\emptyset]{\emptyset}{\src{\Omega_0.\Delta^\diamond}}\label{asm:mmlatmsviamonitor:agree}
  \end{equation}
  What follows is $\typechecks{}{\Omega_0\triangleright e_p}{\nat}$, which equivalent to $\typechecks{}{\Omega_0^\diamond\triangleright e_p}{\nat}$.

  Now obtain witnesses $\overline{a_p}$, $\delta_{\text{TMS}}^{(p)}$, and $\tmsmonitor$ from supplying \Thmref{lem:generaltms:monitor} with \Cref{asm:mmlatmsviamonitor:typesubstx}, \Cref{asm:mmlatmsviamonitor:execp}, and \Cref{asm:mmlatmsviamonitor:agree}, such that:

  \begin{passumptions}{F}
    \item $\emptyset\subseteq\delta_{\text{TMS}}^{(p)}$
    \item\label[ass]{asm:mmlatmsviamonitor:traceagreeasm} $\tmstraceagree[\delta^{(p)}]{\overline{a_p}}{\src{\overline{a_p}}}$
    \item\label[ass]{asm:mmlatmsviamonitor:monitorcheckasm} $\monitorcheck{\emptyset}{\tmsmonitor}{\overline{a_p}}$
    \item $\storeagreetms[\delta^{(p)}]{\tmsmonitor}{\src{\Omega_p}.\src{\Delta}}$
  \end{passumptions}

  Now instantiate the existential in our goal with $\delta_{\text{TMS}}^{(p)}$, $\overline{a_p}$, and $\tmsmonitor$, so the remaining goals are:

  \begin{goals}
    \item\label[goal]{asm:mmlatmsviamonitor:traceagree} $\tmstraceagree[\delta^{(p)}]{\overline{a_p}}{\src{\overline{a_0^\diamond\cdot a_p\cdot a_1^\diamond}}}$
    \item\label[goal]{asm:mmlatmsviamonitor:monitorcheck} and $\monitorcheck{\emptyset}{\tmsmonitor}{\overline{a_p}}$
  \end{goals}

  For \Cref{asm:mmlatmsviamonitor:traceagree}, note that by \Cref{tr:tms-trans-auth-ignore}, we can reduce it to $\tmstraceagree[\delta^{(p)}]{\overline{a_p}}{\src{\overline{a_p}}}$\MK{needs a technical lemma}, which is fulfilled by \Cref{asm:mmlatmsviamonitor:traceagreeasm}.

  \Cref{asm:mmlatmsviamonitor:monitorcheck} follows immediately by \Cref{asm:mmlatmsviamonitor:monitorcheckasm}.

\end{proof}

\clearpage

\subsection{Target Language}
\subsubsection{Syntax}

%%%%
%% TARGET

\myfig{
	\vspace{-1em}
  \begin{gather*}
  \begin{aligned}
  \mi{Expressions}~\trg{e} \bnfdef&\ \trg{x} \mid \trg{v} \mid \trg{e_{1} \oplus e_{2}} \mid \trg{x[e]} \mid \trg{let\ x = e_{1}\ in\ e_{2}}\mid \trg{x[e_{1}]\leftarrow e_{2}} \\
    & \mid \trg{let\ x=new\ e_{1}\ in\ e_{2}} \mid \trg{delete\ x} \\
    & \mid \trg{if\ e_1 < e_2\ then\ e_3\ else\ abort()} \\
    & \mid \trg{\langle e_1;e_2\rangle} \mid \trg{\pi_1\ e} \mid \trg{\pi_2\ e}
  \hspace{0.5cm} \text{where } \trg{\oplus}\in\{\trg{+},\trg{-},\trg{\times}\}\\
  %
  \mi{Values}~\trg{v} \bnfdef&\ \trg{n}\in\trg{\nat} \hspace{0.5cm}
  \mi{References}~\trg{\loc}\in\trg{\nat} \\
  %
  \mi{Variables}~\ \trg{x} &\mid \trg{y} \mid \dots \hspace{0.5cm}
  %
  \mi{Poison}~\ \trg{\poison}~\bnfdef\ \trg{\poisonless} \mid \trg{\poisoned}\\
  %
  \mi{Store}~\trg{\Delta} \bnfdef&\ \trg{\hole{\cdot}} \mid \trg{x\mapsto\loc_\poison},\Deltat\\
  %
  \mi{Heaps}~\trg{H} \bnfdef&\ \trg{\hole{\cdot}} \mid \trg{H}::\trg{n} \hspace{0.5cm}
  %
  \mi{State}\ \configt \bnfdef\ \tconfig{H}{\Delta} \mid \trg{\lightning}\\
  %
  \mi{Contexts}\ &\trg{context\ e_0\ e_1} \hspace{0.5cm}
  \mi{Components}\ \trg{component\ e_p} \\
  \mi{Whole\ Programs}\ &\trg{prog\ e_0\ e_1\ e_2}\\ %todo
  \end{aligned}
  \end{gather*}
}{mmlat-syntax}{Syntax of $\mmlAt$}

\subsubsection{Dynamic Semantics}

\myfig{
  \begin{gather*}
    \begin{aligned}
      \trg{K}\bnfdef &\ \trg{\hole{\cdot}}\mid \trg{K\oplus e}\mid \trg{v\oplus E}\mid \trg{x[K]}\mid
      \trg{let\ x=K\ in\ e}\\
                     &\mid \trg{x[K]\leftarrow e}\mid \trg{x[v]\leftarrow K}\mid \trg{let\ x=new\ K\ in\ e} \mid \trg{\langle K; e\rangle} \mid \trg{\langle n; K\rangle}\\
                     &\mid \trg{if\ K < e_1\ then\ e_2\ else\ abort()} \mid \trg{if\ n < K\ then\ e\ else\ abort()}
    \end{aligned}
  \end{gather*}
}{tw-expr-eval-ectx}{Evaluation Contexts of $\mmlAt$.}

\myfig{
  \begin{center}
    $$
    \typerule{plugging}{
    }{
    \trg{context}\ (\trg{e_0})\ (\trg{e_1})\trg{\linker}{\trg{component\ e_p}} = \trg{prog\ (let\ y=let\ x=e_0\ in\ e_p\ in\ e_1)}
    }{trg-plugging}
    $$
  \end{center}
}{w-plugging-t}{$\mmlAt$ plugging of contexts and components.}


\myfig{
  \begin{gather*}
  \begin{aligned}
  \mi{Events}~\trg{a} \bnfdef& \trg{\emptyevent} \mid \trg{Alloc\ \loc\ n} \mid \trg{Dealloc\ \loc} \mid \trg{Read\ \loc\ n} \mid \trg{Set\ \loc\ n} \mid \trg{\lightning}
  \end{aligned}
  \end{gather*}
}{w-events}{Events of $\mmlAt$.}

\myfig{
  \judgbox{\exect[]{\configt}{K[e]}{\configt'}{K[e']}{a}}{,,Given an evaluation context $\trg{K}$ and an expression $\trg{e}$,\\it evaluates under configuration $\configt$ to $\trg{e'}$ and\\new configuration $\trg{\configt'}$ in context $\trg{K}$, emitting event $\trg{a}$.''}
  \judgbox{\exprevalt{\configt}{e}{\configt'}{e'}{a}}{,,Expression $\trg{e}$ evaluates under configuration $\configt$ to $\trg{e'}$ and\\new configuration $\trg{\configt'}$, emitting event $\trg{a}$.''}
  %
  \typerule{$e-\text{ctx}$}{
    \exprevalt{\configt}{e}{\configt'}{e'}{a}
  }{
    \exect[]{\configt}{K[e]}{\configt'}{K[e']}{a}
  }{tw-e-ectx}
  %
  \typerule{$e-\trg{\pi_1}$}{
  }{
    \exprevalt{\configt}{\pi_1\langle n_1;n_2\rangle}{\configt}{n_1}{\emptyevent}
  }{tw-e-proj1}
  %
  \typerule{$e-\trg{\pi_2}$}{
  }{
    \exprevalt{\configt}{\pi_2\langle n_1;n_2\rangle}{\configt}{n_2}{\emptyevent}
  }{tw-e-proj2}
  %
  \typerule{$e-\trg{if}-\trg{less}$}{
    \trg{n_1}<\trg{n_2}
  }{
    \exprevalt{\configt}{if\ n_1<n_2\ then\ e\ else\ abort()}{\configt}{e}{\emptyevent}
  }{tw-e-if-less}
  %
  \typerule{$e-\trg{if}-\trg{panic}$}{
    \trg{n_1}\ge\trg{n_2}
  }{
    \exprevalt{\configt}{if\ n_1<n_2\ then\ e\ else\ abort()}{\lightning}{stuck}{\lightning}
  }{tw-e-if-less}
  %
  \typerule{$e-\trg{\oplus}$}{
    \trg{n_1}+\trg{n_2}=\trg{n_3}
  }{
    \exprevalt{\configt}{n_1+n_2}{\configt}{n_3}{\emptyevent}
  }{tw-e-oplus}
  % TODO
  \typerule{$e-\trg{get}$}{
    \trg{\loc}\in\text{dom }\trg{H}\implies\trg{v}=\trg{H}(\trg{\loc+n}) &
    \trg{\loc}\not\in\text{dom }\trg{H}\implies\trg{v}=\trg{1729}
  }{
    \exprevalt{\tconfig{H}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{x[n]}{\tconfig{H}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{v}{Read\ \loc\ n}
  }{tw-e-get}
  %
  \typerule{$e-\trg{set}$}{
    \trg{H'} = \trg{H}(\trg{\loc+n}\mapsto \trg{v})
  }{
    \exprevalt{\tconfig{H}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{x[n]\leftarrow v}{\tconfig{H'}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{v}{Set\ \loc\ n\ v}
  }{tw-e-set}
  %
  \typerule{$e-\trg{let}-\trg{x}$}{
  }{
    \exprevalt{\tconfig{H}{\Delta}}{let\ x=y\ in\ e}{\tconfig{H}{\Delta}}{e[y/x]}{\emptyevent}
  }{tw-e-let-x}
  %
  \typerule{$e-\trg{let}-\trg{v}$}{
  }{
    \exprevalt{\tconfig{H}{\Delta}}{let\ x=v\ in\ e}{\tconfig{H}{\Delta}}{e[v/x]}{\emptyevent}
  }{tw-e-let-v}
  %
  \typerule{$e-\trg{delete}$}{
  }{
    \exprevalt{\tconfig{H}{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{delete\ x}{\tconfig{H}{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}{0}{Dealloc\ \loc}
  }{tw-e-let-new}
  %
  \typerule{$e-\trg{new}$}{
    \text{fresh}\ \trg{\loc}&
    \text{fresh}\ \trg{z} &
    \trg{H'} = \trg{H} \ll \trg{n} &
  }{
  \exprevalt{\tconfig{H}{\Delta}}{let\ x=new\ n\ in\ e}{\tconfig{H'}{z\mapsto \loc_\poisonless,\Delta}}{e[z/x]}{Alloc\ \loc\ n}
  }{tw-e-let-new}
  %
}{tw-expr-eval}{Evaluation of $\mmlAt$ expressions.}

\subsubsection{\gls*{sms} Monitor}

\myfig{
  \begin{gather*}
    \begin{aligned}
      \mi{Abstract\ References}~L \subseteq&\ \nat \hspace{0.5cm}
      \mi{Abstract\ Store}~\smsmonitor =\ L\times\nat \\
      \mi{Abstract\ Events}~a \bnfdef&\ \emptyevent \mid \text{Alloc}\ \loc\ n \mid \text{Dealloc}\ \loc \mid \text{Use}\ \loc\ n \\
    \mi{References\ Agreement}~\delta_{\text{sms}} :&\ \trg{L}\to L \\[0.6cm]
    \end{aligned}
  \end{gather*}
}{sms-monitor}{\gls{sms} Monitor.}

\myfig{
  \begin{center}
    \typerule{sms-Empty}{
    }{
    \monitorcheck[]{\smsmonitor}{\smsmonitor}{\varepsilon}
    }{sms-empty}
    %
    \typerule{sms-Use}{
      (\loc,m)\in \smsmonitor[.A]&
      n<m&
    }{
    \monitorcheck[]{\smsmonitor}{\smsmonitor}{\text{Use}\ \loc\ n}
    }{sms-use}
    %
    \typerule{sms-Alloc}{
      \forall m,(\loc,m)\not\in \smsmonitor&
      \smsmonitor[']=\smsmonitor\cup\left\{(\loc,n)\right\}&
    }{
    \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\text{Alloc}\ \loc\ n}
    }{sms-alloc}
    %
    \typerule{sms-Dealloc}{
      (\loc,m)\in \smsmonitor[.A] &
      \smsmonitor[']=\smsmonitor\setminus\left\{(\loc,m)\right\}
    }{
    \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\text{Dealloc}\ \loc}
    }{sms-dealloc}
    %
    \typerule{sms-Refl}{
    }{
    \monitorcheck{\smsmonitor}{\smsmonitor}{\hole{\cdot}}
    }{sms-refl}
    %
    \typerule{sms-Trans}{
      \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{a}&
      \monitorcheck{\smsmonitor[']}{\smsmonitor['']}{\bar{a}}&
    }{
    \monitorcheck{\smsmonitor}{\smsmonitor['']}{a\cdot\bar{a}}
    }{sms-trans}
  \end{center}
}{sms-step}{Steps of \gls{sms} Monitor.}

\myfig{
  \begin{center}
    \typerule{SMS-Internal-Authentic}{
    }{
      \smstraceagree{\trg{\varepsilon}}{\varepsilon}
    }{sms-internal-auth}
    %
    \typerule{SMS-Alloc-Authentic}{
      \delta_{\text{sms}}(\trg{\loc})=\loc
    }{
      \smstraceagree{\trg{Alloc\ \loc\ n}}{\text{Alloc}\ \loc\ n}
    }{sms-alloc-auth}
    %
    \typerule{SMS-Dealloc-Authentic}{
      \delta_{\text{sms}}(\trg{\loc})=\loc
    }{
    \smstraceagree{\trg{Dealloc\ \loc}}{\text{Dealloc}\ \loc}
    }{sms-dealloc-auth}
    %
    \typerule{SMS-Get-Authentic}{
      \delta_{\text{sms}}(\trg{\loc})=\loc
    }{
    \smstraceagree{\trg{Get\ \loc\ n}}{\text{Use}\ \loc\ n}
    }{sms-get-auth}
    %
    \typerule{SMS-Set-Authentic}{
      \delta_{\text{sms}}(\trg{\loc})=\loc
    }{
      \smstraceagree{\trg{Set\ \loc\ n\ v}}{\text{Use}\ \loc\ n}
    }{sms-set-auth}
    %
    \typerule{SMS-Refl-Authentic}{
    }{
    \smstraceagree{\trg{\hole{\cdot}}}{\hole{\cdot}}
    }{sms-refl-auth}
    %
    \typerule{SMS-Trans-Authentic}{
      \smstraceagree{\trg{a}}{a} &
      \smstraceagree{\trg{\bar{a}}}{\bar{a}}
    }{
      \smstraceagree{\trg{a}\cdot\trg{\bar{a}}}{a\cdot\bar{a}}
    }{sms-trans-auth}
    %
    \typerule{SMS-Trans-Authentic-Ignore}{
      \smstraceagree{\trg{\bar{a}}}{\bar{a}}
    }{
      \smstraceagree{\trg{a^\diamond}\cdot\trg{\bar{a}}}{\bar{a}}
    }{sms-trans-auth-ignore}
  \end{center}
}{sms-trace-agreement}{Trace Agreement.}


\myfig{
  \begin{center}
    \typerule{abstract-agree-dealloc}{
    }{
    \text{Dealloc}\ \loc \prec \text{Dealloc}\ \loc
    }{aagree-dealloc}
    %
    \typerule{abstract-agree-alloc}{
    }{
    \text{Alloc}\ \loc\ n \prec \text{Alloc}\ \loc
    }{aagree-alloc}
    %
    \typerule{abstract-agree-use}{
    }{
    \text{Use}\ \loc\ n \prec \text{Use}\ \loc
    }{use-dealloc}
    %
    \typerule{tms-sms-E}{
    \monitorcheck[]{\smsmonitor}{\smsmonitor}{a} & 
    a\prec a' &
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{a'} &
    T = \tmsmonitor\times\smsmonitor
    }{
    \monitorcheck[]{T}{T}{a}
    }{tms-sms-empty}
    %
    \typerule{tms-sms-Refl}{
    }{
    \monitorcheck{T}{T}{\hole{\cdot}}
    }{tms-sms-refl}
    %
    \typerule{tms-sms-Trans}{
      \monitorcheck[]{T}{T'}{a}&
      \monitorcheck{T'}{T''}{\bar{a}}&
    }{
    \monitorcheck{T}{T''}{a\cdot\bar{a}}
    }{tms-sms-trans}
  \end{center}
}{sms-step}{Steps of combined \gls{tms} + \gls{sms} Monitor.}

\clearpage

\begin{definition}[Trace is temporal memory safe via monitor.]\label{def:trg:trace:tms}
  We say $\texttt{TMS}(\trg{\bar{a}})$ iff $\exists \delta\ \bar{a}\ \tmsmonitor$ such that:
  \begin{itemize}
    \item $\tmstraceagree{\bar{a}}{\trg{\bar{a}}}$
    \item and $\monitorcheck{\emptyset}{\tmsmonitor}{\bar{a}}$
  \end{itemize}
\end{definition}


\subsection{Robust \gls*{tms} Preserving Compiler}

\subsubsection{Compiler}

\myfig{
  \begin{center}
    $$
    \begin{array}{rll}
    \mmlAmmlAtcomp{x} &\ = & \trg{x} \\
    \mmlAmmlAtcomp{v} &\ = & \trg{v} \\
    \mmlAmmlAtcomp{e_1\oplus e_2} &\ = & \trg{e_1\oplus e_2} \\
    \mmlAmmlAtcomp{x[e]} &\ = & \trg{x[e]} \\
    \mmlAmmlAtcomp{let\ x=new\ e_1\ in\ e_2} &\ = & \trg{let\ x=new\ e_1\ in\ e_2} \\
    \mmlAmmlAtcomp{x[e_1]\leftarrow e_2} &\ = & \trg{x[e_1]\leftarrow e_2} \\
    \mmlAmmlAtcomp{let\ x= e_1\ in\ e_2} &\ = & \trg{let\ x= e_1\ in\ e_2} \\
    \mmlAmmlAtcomp{delete\ x} &\ = & \trg{delete\ x} \\
    \end{array}
    $$
  \end{center}
}{tms-pres-compiler}{Compiler from $\mmlAs$ to $\mmlAt$.}

\subsubsection{Partial Trace-based Backtranslation}

\myfig{
  \begin{center}
    \typerule{backtrans-create-symb}{
      \trg{\loc}\not\in\operatorname{dom}\Game &
      \text{fresh}\ \src{x} &
    }{
      \Game'=\Game\cup\left\{\trg{\loc}\mapsto\src{x}\right\}
    }{backtrans-create-symb}
    \typerule{backtrans-nocreate-symb}{
      \trg{\loc}\in\operatorname{dom}\Game &
    }{
      \Game'=\Game
    }{backtrans-nocreate-symb}
    %
    \typerule{backtrans-lookup-symb}{
      \trg{\loc}\in\operatorname{dom}\Game
    }{
      \Game(\trg{\loc}) = \src{x}
    }{backtrans-lookup-symb}
    $$
    \begin{array}{rll} 
      \mmlAmmlAtbackv{v} &\ = & \src{v} \\[0.5cm]
      %
      \mmlAmmlAtbackdetail{\hole{\cdot}} &\ = & \Game,\src{42} \\
      %
      \mmlAmmlAtbackdetail{(Alloc\ \loc\ n)^\diamond\cdot\overline{a}} &\ = & \text{let }\Game'=\Game[\trg{\loc}]\text{\ in}\\
                                                                       &&\text{let }\Game'',\src{e}=\mmlAmmlAtbackdetail[\Game']{\overline{a}}\text{\ in}\\
                                                                       &&\Game'',\src{let\ }\Game'(\trg{\loc})\src{ = new\ }\mmlAmmlAtbackv{n}\src{\ in\ e} \\
      %
      \mmlAmmlAtbackdetail{(Dealloc\ \loc)^\diamond\cdot\overline{a}} &\ = & \text{let }\Game'=\Game[\trg{\loc}]\text{\ in}\\
                                                                      &&\text{let }\Game'',\src{e}=\mmlAmmlAtbackdetail[\Game']{\overline{a}}\text{\ in}\\
                                                                      &&\Game'',\src{delete\ }\Game'(\trg{\loc})\src{; e}\\
      %
      \mmlAmmlAtbackdetail{(Get\ \loc\ n)^\diamond\cdot\overline{a}} &\ = &\text{let }\Game'=\Game[\trg{\loc}]\text{\ in}\\
                                                                     &&\text{let }\Game'',\src{e}=\mmlAmmlAtback{\overline{a}}\text{\ in}\\
                                                                     &&\Game'(\trg{\loc})\src{[}\mmlAmmlAtbackv{n}\src{];e} \\
      %
      \mmlAmmlAtbackdetail{(Set\ \loc\ n\ v)^\diamond\cdot\overline{a}} &\ = & \text{let }\Game'=\Game[\trg{\loc}]\text{\ in}\\
                                                                        &&\text{let }\Game'',\src{e}=\mmlAmmlAtbackdetail[\Game']{\overline{a}}\\
                                                                        &&\Game'',\Game'(\trg{\loc})\src{[}\mmlAmmlAtbackv{n}\src{]\leftarrow }\mmlAmmlAtbackv{v}\src{; e} \\
      \mmlAmmlAtbackdetail{a\cdot\overline{a}} &\ = & \Game,\src{42}\\[0.5cm]
      %
      \mmlAmmlAtbackdetailz{\hole{\cdot}} &\ = & \trg{\hole{\cdot}}\\ 
      \mmlAmmlAtbackdetailz{a^\diamond\cdot\overline{a}} &\ = & \mmlAmmlAtbackdetailz{\overline{a}}\\ 
      \mmlAmmlAtbackdetailz{a\cdot\overline{a}} &\ = & \trg{a\cdot\overline{a}}\\[0.5cm]
      %
      \mmlAmmlAtbackdetailo{\hole{\cdot}} &\ = & \trg{\hole{\cdot}}\\ 
      \mmlAmmlAtbackdetailo{a^\diamond\cdot\overline{a}} &\ = & \trg{a^\diamond\cdot\overline{a}}\\ 
      \mmlAmmlAtbackdetailo{a\cdot\overline{a}} &\ = & \mmlAmmlAtbackdetailo{\overline{a}}\\[0.5cm]
      %
      \mmlAmmlAtback{\overline{a}} &\ = & \text{let }\Game,\src{e_1}=\mmlAmmlAtbackdetail[\emptyset]{\overline{a}}\text{\ in}\\
                                   &&\text{let }\_,\src{e_2}=\mmlAmmlAtbackdetail{ \mmlAmmlAtbackdetailo{\mmlAmmlAtbackdetailz{\overline{a}}} }\text{\ in}\\
                                   &&\src{context\ e_1\ e_2} \\
    \end{array}
    $$
  \end{center}
}{tms-pres-backtrans}{Partial Trace-Based Backtranslation from }%$\mmlAs$ to $\mmlAt$.}
The trace-based backtranslation is partial since we leave the translation undefined for the event $\trg{\lightning}$.
This is fine, because where we use the backtranslation, we know the trace won't contain $\trg{\lightning}$.
We use the syntactic sugar $\src{e_1;e_2}$ for $\src{let\ \_ = e_1\ in\ e_2}$.

\subsubsection{Proofs and Auxiliary Lemmas}

\begin{definition}[Cross-Language Trace Agreement]
  We say $\tmstraceagree{\src{\overline{a}}}{\trg{\overline{a}}}$ iff
  $$
  \exists \overline{a}, \tmstraceagree[\delta^{\color{\stlccol}\bullet}]{\overline{a}}{\src{\overline{a}}}
                  \wedge\tmstraceagree[\delta^{\color{\ulccol}\bullet}]{\overline{a}}{\trg{\overline{a}}}
  $$
  where $\delta_{tms}={\delta^{\color{\stlccol}\bullet}}_{tms}\cup{\delta^{\color{\ulccol}\bullet}}_{tms}$ such that ${\delta^{\color{\stlccol}\bullet}}_{tms}:\src{L}\to L$ and ${\delta^{\color{\ulccol}\bullet}}_{tms}:\trg{L}\to L$.
\end{definition}

\begin{definition}[Cross-Language Store Agreement]
  We say $\storeagreetms{\src{\Omega}}{\trg{\Omega}}$ iff
  $$
  \exists \tmsmonitor, \storeagreetms[\delta^{\color{\stlccol}\bullet}]{\tmsmonitor}{\src{\Omega}.\src{\Delta}}
                 \wedge\storeagreetms[\delta^{\color{\ulccol}\bullet}]{\tmsmonitor}{\trg{\Omega}.\trg{\Delta}}
  $$
  where $\delta_{tms}={\delta^{\color{\stlccol}\bullet}}_{tms}\cup{\delta^{\color{\ulccol}\bullet}}_{tms}$ such that ${\delta^{\color{\stlccol}\bullet}}_{tms}:\src{L}\to L$ and ${\delta^{\color{\ulccol}\bullet}}_{tms}:\trg{L}\to L$.

  For convenience, we may also use $\storeagreetms{\src{\Delta}}{\trg{\Delta}}$ or $\storeagreetms{\src{\Omega}.\src{\Delta}}{\trg{\Omega}.\trg{\Delta}}$ with the obvious meaning.
\end{definition}

\begin{lemma}[Backtranslation correct]\label{lem:backtranslation:correct}
  If
  \begin{assumptions}
  \item $\wexec{\trg{prog\ e_1}\ \mmlAmmlAtcomp{e_p}\ \trg{\ e_2}}{\trg{\configt}}{\trg{v}}{\trg{\overline{a}}}$
  \item $\src{context\ e_1\ e_2}=\mmlAmmlAtback{\overline{a}}$
  \end{assumptions}
  then $\exists \configs\ \src{v}\ \src{\overline{a}}\ \delta_{tms}$
  \begin{goals}
  \item $\wexecs{prog\ e_1\ e_p\ e_2}{\configs}{v}{\overline{a}}$
  \item $\tmstraceagree{\src{\overline{a}}}{\trg{\overline{a}}}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\refstepcounter{theoremcounter}
\begin{theorem}[Robust \gls{tms} Preservation]
  If
  \begin{assumptions}
  \item\label[ass]{asm:rtmsp:srctms} $\forall \src{e_1}\ \src{e_2}\ \src{\overline{a}}\ \src{\Omega}\ \src{v},\wexecs{prog\ e_1\ e_p\ e_2}{\configs}{v}{\overline{a}}\rightarrow\texttt{TMS}(\src{\bar{a}})$
  \item\label[ass]{asm:rtmsp:trgexec} $\wexec{\trg{prog\ e_1}\ \mmlAmmlAtcomp{e_p}\ \trg{e_2}}{\trg{\configt}}{\trg{v}}{\trg{\overline{a}}}$
  \end{assumptions}
  then
  \begin{goals}
  \item $\texttt{TMS}(\trg{\bar{a}})$
  \end{goals}
\end{theorem}
\begin{proof}
  We backtranslate the trace $\mmlAmmlAtback{\overline{a}} = \src{context\ e_1\ e_2}$ and immediately use it together with \Cref{asm:rtmsp:trgexec} to apply \thmref{lem:backtranslation:correct}:
  \begin{passumptions}{H}
  \item\label[ass]{asm:rtmsp:srcexec} $\wexecs{prog\ e_1\ e_p\ e_2}{\configs}{v}{\overline{a}}$
  \item $\tmstraceagree{\src{\overline{a}}}{\trg{\overline{a}}}$
  \end{passumptions}

  We can specialize \Cref{asm:rtmsp:srctms} using $\src{e_1}$, $\src{e_2}$, $\src{\overline{a}}$, $\src{\Omega}$, $\src{v}$, and \Cref{asm:rtmsp:srcexec} to get:

  \begin{passumptions}{H'}
  \item\label[ass]{asm:rtmsp:srctms} $\texttt{TMS}(\src{\bar{a}})$
  \end{passumptions}

  By \Cref{def:src:trace:tms}, \Cref{asm:rtmsp:srctms} can be destructured as:
  \begin{passumptions}{F}
    \item $\tmstraceagree[\delta']{\overline{a}}{\src{\overline{a}}}$
    \item $\monitorcheck{\emptyset}{\tmsmonitor}{\overline{a}}$
  \end{passumptions}

  We split $\delta_{tms}$ into ${\delta^{\color{\stlccol}\bullet}}_{tms}$ and ${\delta^{\color{\ulccol}\bullet}}_{tms}$.
  By \Cref{def:trg:trace:tms}, our goal can be instantiated with ${\delta^{\color{\stlccol}\bullet}}_{tms}$, $\overline{a}$, and $\tmsmonitor$, so what is left to show is:
  \begin{goals}
    \item $\tmstraceagree[{\delta^{\color{\ulccol}\bullet}}]{\overline{a}}{\trg{\overline{a}}}$
    \item $\monitorcheck{\emptyset}{\tmsmonitor}{\overline{a}}$
  \end{goals}

  Both follow easily from existing assumptions. (note that ${\delta^{\color{\ulccol}\bullet}}_{tms}\subseteq\delta_{tms}$)
\end{proof}

\clearpage
\cleardoublepage

\bibliographystyle{plain}
\bibliography{library}

\end{document}
