\documentclass[a4paper,names,dvipsnames]{article}

\usepackage[T1]{fontenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{glossaries}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{marvosym}
\usepackage[capitalize]{cleveref}
\usepackage{bm}
\usepackage{xspace}
\usepackage{etoolbox}
\usepackage{natbib}
\usepackage{xfrac}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{scontents}

% workaround to use extpfeil and stmaryrd together.
% see https://tex.stackexchange.com/questions/297108/
\expandafter\def\csname opt@stmaryrd.sty\endcsname
{only,shortleftarrow,shortrightarrow}
\usepackage{extpfeil}

\usepackage{tikz}
\usetikzlibrary{positioning,calc}

\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newcounter{theoremcounter}
\newtheorem{theorem}[theoremcounter]{Theorem}

\input{includes}
\makeglossaries

\newcommand{\MK}[1]{\todo[color=orange!30]{TODO: #1}}
\newcommand{\MP}[1]{\todo[color=blue!30]{TODO: #1}}

% Definition of Ddots
\makeatletter
\def\Ddots{\mathinner{\mkern1mu\raise\p@
\vbox{\kern7\p@\hbox{.}}\mkern2mu
\raise4\p@\hbox{.}\mkern2mu\raise7\p@\hbox{.}\mkern1mu}}
\makeatother

\begin{document}
\tableofcontents
\clearpage

\section{Preliminaries}

\begin{definition}[Events]\label{def:events}
  $\events$ is the set of atomic propositions hereby called events or actions.
  The internal action is $\emptyevent$.
  The action $\terminationevent$ is program termination.
\end{definition}


We assume that any programming language can be enriched with a self-composition operator in the style of \citet{barthe11}.
Furthermore, we also assume the existence of a low-equivalence relation that distinguishes program states only by their public memory.
Two traces $\trace_{1}$,$\trace_{2}$ are low-equivalent $\loweq{\trace_{1}}{\trace_{2}}$ iff all their public events coincide.

\begin{definition}[Programming Languages]\label{def:pl}
A programming language is a tuple $\left(\partials,\wellf,\singlestep,\linker\right)$ s.t.:

\begin{itemize}
  \item[$\partials$] : Set - is a set of admissible, partial programs.
  \item[$\wellf$] : $\partials$ - a judgement that holds iff a program is not partial.
  \item[$\singlestep$] : $\wholes\to\events\to\wholes$ - a step relation, where $\wholes=\{w\in\partials\ |\ \wellf w\}$.
        For $e\in\events$ and $p,p'\in\wholes$ we say for $\estep{p}{e}{p'}$ that program $p$ performs a step with action $e$ to program $p'$.
        If $e=\emptyevent$, we write $\step{p}{p'}$.
        In case $e=\terminationevent$, we write $\terminates{p}$.
  \item[$\linker$] : $\partials\to\partials\to\partials$ - links two partial programs together in some way, resulting in a new partial program.
\end{itemize}
\end{definition}
Let $\src{S},\irl{I},$ and $\trg{T}$ be any programming language.

% if we get τ1 and τ2, then there is aontehr program that does τ3 which does τ1 and τ2 in parallel
% define self-composition. and then define it with respect to low-equivalent programs
%

\begin{definition}[Notation for Sequences]
  For any sequence of events, let $\seqnil$ denote the empty sequence and $\seqcons{e}{\bar{t}}$ the sequence that starts with $e$ and continues with $\bar{t}$.
  Hereby, it does not matter whether $\bar{t}$ is finite or infinite, it's merely syntactic sugar to work on sequences of events.
\end{definition}

\begin{definition}[Traces]
  A trace $\trace$ is an infinite sequence of events that results from the relation $\singlestep$.
  That is, we obtain the trace $\trace=\seqcons{e_{0}}{\seqcons{e_{1}}{\dots}}$ for the execution sequence $\estep{p}{e_{0}}{\estep{p'}{e_{1}}{\dots}}$ and write $\mktrace{p}{\trace}$.
  The set of all traces is $\traces$.
\end{definition}
\noindent
We assume $\lightning$ to occur in traces representing terminating programs such that it occurs infinitely often in a one-by-one sequence.

\begin{definition}[Finite Trace Prefixes]
  A finite sequence of events $m$ is a finite trace prefix of $\trace$ iff it satisfies the following judgement.

  $$
    \inference{}{\cdot\le\trace}\hspace{2em}\inference{m\le\trace}{\seqcons{e}{m}\le \seqcons{e}{\trace}}
  $$
\end{definition}

\begin{definition}[Behavior]
  The behavior of a whole program $p$ is a set of all traces it produces, i.e. $\behav{p}=\{\trace\ |\ \mktrace{p}{\trace}\}$.
\end{definition}

\begin{definition}[Observation]
  An observation is a finite set of finite trace prefixes.
  We say that an observation $o$ is the prefix of a behavior $b$ iff $$\forall m\in o.\exists \trace\in b.m\le t$$.
\end{definition}

\begin{definition}[Properties]
  A property $\prop$ is a set of admissible traces. For a program $p$ to satisfy $\prop$ it must not produce a trace that is not part of $\prop$. Thus, $p$ satisfies $\prop$ iff $\behav{p}\subseteq\prop$ and we write $\sat{p}{\prop}$.
\end{definition}

\begin{definition}[Hyperproperties]
  A hyperproperty $H$ is a set of admissible sets of traces. Thus, if $p$ satisfies $H$ (also written $\sat{p}{H}$), then $\behav{p}\in H$.
\end{definition}

\begin{lemma}[Lifting Properties]
  Given a property $\pi$, there exists a unique hyperproperty $\lift{\pi}$ that satisfies the exact same policy.
\end{lemma}
\begin{proof}
  We want $\forall p \in\partials, \sat{p}{\prop}\equiv\sat{p}{\lift{\prop}}$.
  Henceforth, given a $p\in\partials$, we have $\behav{p}\subseteq\prop$ iff $\behav{p}\in\lift{\prop}$.
  Note that if $\behav{p}\subseteq\prop$, we have $\behav{p}\in\left\{\Pi\ |\ \Pi=\behav{p}\subseteq\prop\right\}$.
  Thus, $\lift{\prop}$ is the set of all possible program behaviors that are a subset of $\prop$.
  This is exactly the powerset of $\prop$ and we conclude $\lift{\prop}=\powerset{\prop}$.
\end{proof}
\noindent
The lifting of properties to a singleton set does not suffice, since the empty behavior trivially satisfies any property $\emptyset\subseteq\prop=\{\trace\}$, but if we would define $\lift{\trace}=\{\{\trace\}\}$, then $\emptyset\not\in\lift{\trace}$.

\begin{lemma}[Property Satisfaction Refinement]
  For a property $\prop$ that refines $\prop'$, i.e. $\prop\subseteq\prop'$, if any $p\in\partials$ satisfies $\sat{p}{\prop'}$, then $\sat{p}{\prop}$.
\end{lemma}
\begin{proof}
  Pick any property $\prop'$ and $p\in\partials$ such that $\sat{p}{\prop}$ and assume $\prop\subseteq\prop'$.
  Simple unfolding reveals $\behav{p}\subseteq\prop\implies\behav{p}\subseteq\prop'$.
\end{proof}
\noindent
For lifted properties, this refinement property also holds on the hyperproperty level.
However, it does not work for any hyperproperty~\cite{clarkson08}.

\begin{definition}[Robust Property Satisfaction]
  A program $p$ robustly satisfies a property $\prop$, written $\rsat{p}{\prop}$, iff $\forall C\in\partials,\sat{C\linker p}{\prop}$. The same notation is used for robust hyperproperty satisfaction.
\end{definition}

\begin{lemma}[Weakening Robust Satisfaction]\label{lem:weaken-rsat}
  Given classes $\cC_{1}, \cC_{2}$ and any program $p$ such that
  \begin{assumptions}
    \item\label{lem:weaken-rsat:ass:a} $\cC_{1}\subseteq\cC_{2}$
    \item\label{lem:weaken-rsat:ass:b} $\rsat{p}{\cC_{2}}$
  \end{assumptions}
  We show
  \begin{goals}
    \item\label{lem:weaken-rsat:goal:i} $\rsat{p}{\cC_{1}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Unfolding \Thmref{lem:weaken-rsat:goal:i}, let $\Pi\in\cC_{2}$ and $p$ be a program, we want to show that $\rsat{p}{\Pi}$.
  By \Thmref{lem:weaken-rsat:ass:a}, we also know that $\Pi\in\cC_{1}$.
  Thus, we can use \Thmref{lem:weaken-rsat:ass:b} to conclude.
\end{proof}

\begin{definition}[Classes]
  A class of hyperproperties $\cC$ is a set of hyperproperties.
  Likewise, a class of properties $\cC$ is a set of hyperproperties, where every property is lifted to the hyperproperty level.
  From now on, we use $\Pi$ for elements of any class $\cC$ in case it does not matter whether it is a lifted property or any hyperproperty.
\end{definition}

\begin{definition}[Compilers]
  A compiler between languages $\S$ and $\T$ is a partial function $\stcomp{\bullet}$ from $\src{\partials}$ to $\trg{\partials}$.
\end{definition}

\section{Compositionality of Secure Compilers}

\begin{definition}[Robust Trace-Hyperproperty Preservation]\label{def:rtp}
  For a given class $\cC$, a compiler from languages $\S$ to $\T$ robustly preserves $\cC$ iff
  $$
  \forall\Pi\in\cC,\forall\src{p}\in\src{\partials},\rsat{\src{p}}{\Pi}\implies\rsat{\stcomp{\src{p}}}{\Pi}
  $$
  We write $\rtp{\stcomp{\bullet}}{\cC}$.
  In case we write $\rtp{\stcomp{\bullet}}{\collapse{\cC}}$, substitute the $\cC$ in above definition with $\left\{ \collapse{\cC} \right\}$.
\end{definition}

\begin{definition}[Sequential Composition of Compilers]
  Given two compilers $\sicomp{\bullet}$ and $\itcomp{\bullet}$, their sequential composition is $\sitcomp{\bullet}=\itcompN{\sicomp{\bullet}}$.
\end{definition}
% we can propagate through the assumptions from src langs to intermediate langs
%

\begin{lemma}[Weakening RTP]\label{lem:weaken}
  Given classes $\cC_{1}, \cC_{2}$ such that
  \begin{assumptions}
    \item $\cC_{1}\subseteq\cC_{2}$
    \item $\rtp{\stcomp{\bullet}}{\cC_{2}}$
  \end{assumptions}
  We show
  \begin{goals}
    \item $\rtp{\stcomp{\bullet}}{\cC_{1}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Using \Cref{def:rtp} on the goal, let $\Pi\in\cC_{1}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$, so what's left to prove is $\rsat{\stcomp{p}}{\Pi}$.
  Since $\cC_{1}\subseteq\cC_{2}$ and $\Pi\in\cC_{1}$, we know that $\Pi\in\cC_{2}$.
  Thus, we can apply the assumption $\rtp{\stcomp{\bullet}}{\cC_{2}}$ to our goal, leaving us with $\rsat{\src{p}}{\Pi}$ to show, which was an assumption we made.
\end{proof}

\begin{definition}[Safety Properties]
  The class of safety properties contains the lifting of all properties that can be refuted with a finite trace prefix:
  $$
  \cSafety = \left\{\lift{\prop}\ |\ \forall \trace\in\traces, t\not\in\lift{\prop} \text{ iff } \exists m\ge\trace,\forall \trace'\in\traces,m\le\trace'\implies\trace'\not\in\lift{\prop}\right\}
  $$
\end{definition}

\begin{definition}[Hypersafety Properties]\label{def:hsafety}
  The class of hypersafety properties contains all hyperpropert that can be refuted with an observation:
  $$
  \cHSafety = \left\{\Pi\ |\ \forall b\in 2^{\traces},b\not\in\Pi\text{ iff  }\exists o\ge b,\forall b'\in 2^{\traces},o\le b'\implies b'\not\in\Pi\right\}
  $$
\end{definition}

\begin{lemma}[Safety is entailed in Hypersafety]
  $\cSafety\subseteq\cHSafety$.
\end{lemma}

\begin{definition}[Subset Closed Hyperproperties]
  The class of hyperproperties that are closed with respect to the subset relation is
  $$
  \cSS = \left\{H\ |\ \forall X\in H, \forall Y\subseteq X, Y \in H\right\}
  $$
\end{definition}

\begin{lemma}[Hypersafety is entailed in SSC]
  $\cHSafety\subseteq\cSS$.
\end{lemma}

\begin{definition}[K-Hypersafety]
  Exactly the same as \Cref{def:hsafety}, but the observations $o$ are restricted to cardinality $k$.
  2-Hypersafety is simply $k=2$. \Cref{def:ni} gives an example instance of a classic 2-hypersafe property.
\end{definition}

\begin{definition}[Nontermination]
  Nontermination is a safety property: Any finite trace prefix with $\terminationevent$ violates this property.
\end{definition}

\begin{definition}[Mutual Exclusion]
  Mutual Exclusion (MutEx) means that no two processes during a program execution enter the same critical section.
\end{definition}

\begin{definition}[Determinism]
  Determinism is a 2-hypersafety property, since any two program executions with the same input must yield the same output.
\end{definition}

\begin{definition}[Non-Interference ($\Ni$)]\label{def:ni}
  We define the class containing the non-interference hyperproperty as:
  $$
  \Ni = \left\{ H | \forall \trace_{1},\trace_{2}\in H. \loweq{\trace_{1}}{\trace_{2}}\implies\trace_{1}=\trace_{2} \right\}
  $$
\end{definition}
Note that $=$ may not be strict equality, but some suitable trace equivalence that checks both public and private actions, instead of just public.

\begin{definition}[Average Response Time (ART)]
  The average response time over all executions less than some arbitrary constant~\cite{clarkson08} is a practically useful hyperproperty that is not subset closed.
\end{definition}
Consider the behavior $\{\trace_{1},\trace_{2},\trace_{3}\}$ where $\trace_{1},\trace_{2}$ each take 1 second and $\trace_{3}$ 4 seconds to run.
If the chosen constant is 2, the hyperproperty would be fulfilled. However, the subset behavior $\{\trace_{3}\}$ has an average time of 4, double the bound set by the property.

\begin{lemma}[Classes Lattice]
  Classes with $\subseteq$ form a lattice.
\end{lemma}
\begin{proof}
  The class with all hyperproperties is the top element $\top=\powerset{\traces}$, while the class with no hyperproperties whatsoever is $\bot=\{\}$.
  Obviously, a partial order due to set inclusion.
  $\cap$ is least upper and $\cup$ greatest lower bound of any given pair of subsets of a given class.
\end{proof}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance=4mm,every node/.style={align=center}]
    \node (top) {$\top$};
    \node[below = of top.south] (SSC) {$\cSS$};
    \node[below = of SSC.south] (HSafe) {$\cHSafety$};
    \node[below = of HSafe.south] (HKSafe) {$\cKHSafety$};
    \node[below = of HKSafe.south] (H2Safe) {$\cTwoHSafety$};
    \node[below = of H2Safe.south] (Safe) {$\cSafety$};

    % Specialized classes
    \node[below right = of Safe.south] (Mutex) {$\mutex$};
    \node[below left = of Safe.south,xshift = 0.75em] (NonTerm) {$\nonterm$};

    \node[below left = of H2Safe.south west] (Determ) {$\determ$};
    \node[below right = of H2Safe.south east] (NI) {$\Ni$};

    \node[below = of Safe.south] (emptyspace) {};
    \node[below = of emptyspace.south] (Bot) {$\bot$};

    % edges
    \draw[-] (top.south) -- (SSC.north);
    \draw[-] (SSC.south) -- (HSafe.north);
    \draw[-] (HSafe.south) -- (HKSafe.north);
    \draw[-] (HKSafe.south) -- (H2Safe.north);
    \draw[-] (H2Safe.south) -- (Safe.north);
    \draw[-] (H2Safe.south) -- (Determ.north);
    \draw[-] (H2Safe.south) -- (NI.north);
    \draw[-] (Safe.south) -- (Mutex.north);
    \draw[-] (Safe.south) -- (NonTerm.north);
    \draw[-] (Determ.south) |- (Bot.west);
    \draw[-] (NI.south) |- (Bot.east);
    \draw[-] (Mutex.south) -- (Bot.north);
    \draw[-] (NonTerm.south) -- (Bot.north);
  \end{tikzpicture}
  \caption{Sketch of a fraction of the infinitely sized lattice of classes. The diagram should be read from top to bottom. A connecting edge between two nodes means that the bottom one is a subset of the top one.}
\end{figure}

\begin{lemma}[Sequential Composition with RTP]\label{lem:seqcompo}
  Given $\rtp{\sicomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  We need to show $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
  By definition, assume $\Pi\in\cC_{1}\cap\cC_{2}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$.
  What is left to show is $\rsat{\sitcomp{\src{p}}}{\prop}$.
  Note that $\Pi\in\cC_{2}$ and that $\sicomp{\src{p}}\in\irl{\partials}$, allowing us to apply $\rtp{\itcomp{\bullet}}{\cC_{2}}$ changing our goal to $\rsat{\sicomp{\src{p}}}{\Pi}$.
  Since $\Pi\in\cC_{1}$ also holds, we can this time apply $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
  What is left to show is $\rsat{\src{p}}{\Pi}$, which is an assumption of ours.
\end{proof}

\begin{definition}[Upper Composition]
  Given two compilers $\stcomp{\bullet}$ and $\itcomp{\bullet}$, their upper composition is

  $$\uhcsitcomp{\bullet}=\lambda p.\begin{cases}\stcomp{p} &\text{if }p\in\src{\partials}\\
                                                \itcomp{p} &\text{if }p\in\irl{\partials}\end{cases}$$.
\end{definition}

\begin{lemma}[Upper Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\uhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Analogous argument as in \Thmref{lem:seqcompo}, but with a case distinction on whether the source program is element of $\S$ or $\I$.
\end{proof}
% S = while,    I = while with exceptions           => modularization

% another idea: certified nugget -> minimal RSP compiler

\begin{definition}[Lower Composition]
  Given two compilers $\stcomp{\bullet}$ and $\sicomp{\bullet}$, their lower composition is $\lhcsitcomp{\bullet}$.
\end{definition}

\begin{lemma}[Lower Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\sicomp{\bullet}}{\cC_{2}}$, then $\rtp{\lhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Analogous argument as in \Thmref{lem:seqcompo}, but with a case distinction on whether the compiled source program is element of $\I$ or $\T$.
\end{proof}

\begin{lemma}[Diamond]\label{lem:diamond}
  Given $\rtp{\lhcsiocomp{\bullet}}{\cC_{1}}$ and $\rtp{\uhciotcomp{\bullet}}{\cC_{2}}$ with $\stcomp{\bullet} = \lambda\src{p}.\uhciotcomp{\lhcsiocomp{p}}$, then $\rtp{\stcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Straightforward using \Thmref{lem:seqcompo}.
\end{proof}

\begin{lemma}[Swappable]\label{lem:swappable}
  Given $\rtp{\ttcomp{\bullet}_{(1)}}{\cC_{1}}$ and $\rtp{\ttcomp{\bullet}_{(2)}}{\cC_{2}}$, then $\rtp{\ttcompN{\ttcomp{\bullet}_{(2)}}_{(1)}}{\cC_{1}\cap\cC_{2}}$ and $\rtp{\ttcompN{\ttcomp{\bullet}_{(1)}}_{(2)}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Both follow from \Thmref{lem:seqcompo}.
\end{proof}

\begin{lemma}[Mingle]
  Given
  \begin{assumptions}
  \item\label[ass]{lem:sandwich:ass:a} $\forall\Pi\in\cC_{2}.\forall\src{p}\in\src{\partials}.\rsat{\src{p}}{\Pi}\implies \Pi\in\cC_{1}$
  \item\label[ass]{lem:sandwich:ass:b} $\forall\Pi\in\cC_{1}.\forall\trg{p}\in\trg{\partials}.\rsat{\trg{p}}{\Pi}\implies \Pi\in\cC_{2}$ (not needed)
  \item\label[ass]{lem:sandwich:ass:c} $\rtp{\stcomp{\bullet}}{\cC_{1}}$
  \end{assumptions}
  we have
  \begin{goals}
  \item\label[goal]{lem:sandwich:goal:i} $\rtp{\stcomp{\bullet}}{\cC_{2}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Unfolding \Cref{lem:sandwich:goal:i}; Let $\Pi\in\cC_{2}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$, leaving us with $\rsat{\stcomp{\src{p}}}{\Pi}$ to prove.

  Apply \Cref{lem:sandwich:ass:c}, giving us as new goals $\Pi\in\cC_{1}$ and $\rsat{\src{p}}{\Pi}$, the latter following easily by the exact same assumption made before.

  However, we still need to argue that $\Pi\in\cC_{1}$.

  Instatiate the universal quantifications in \Cref{lem:sandwich:ass:a} with $\Pi$ and $\src{p}$. Apply that to our goal.
  What is left to show is $\rsat{\src{p}}{\Pi}$, which we've proven before already.
\end{proof}

\begin{lemma}[RSP may imply k-RSHP]
  Given
  \begin{assumptions}
  \item\label[ass]{lem:rspimplkrshp:ass:a} $\S$ and $\T$ have $\loweq{}{}$ and $\selfcompo{}{}$ operators
  \item\label[ass]{lem:rspimplkrshp:ass:b} $\Pi\in\cSafety$
  \item\label[ass]{lem:rspimplkrshp:ass:c} $\src{p}\in\src{\partials}$ with $\rsat{\src{p}}{\Pi}$
  \item\label[ass]{lem:rspimplkrshp:ass:d} $\rtp{\stcomp{\bullet}}{\cSafety}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{lem:rspimplkrshp:goal:i} $\exists\stcomp{\bullet}.\sat{\stcomp{\src{p}}}{\text{k-RSHP}}$
  \end{goals}
\end{lemma}
\begin{proof}
  (intuition)

  Take $\src{p}\in\src{\partials}$ and construct the k-product program according to \citet{barthe11}.
  Feed the input into the compiler from \Cref{lem:rspimplkrshp:ass:d}.
  Instantiate the existential in \Cref{lem:rspimplkrshp:goal:i} with the modified compiler.
  Since the product program reflects the behavior of $\src{p}$, the transformation does not interfere with robust property satisfaction.
  Furthermore, \Cref{lem:rspimplkrshp:ass:d} guarantees us that the compiled k-product program of $\src{p}$ is safe.
  Since the k-product construction soundly embeds $k-RSHP$ properties into $\cSafety$, the claim follows.
\end{proof}


\begin{definition}[Instrumentation]\label{def:instrumentation}
  A source code instrumentation done by a compiler takes a program in language $\T$ and emits an altered version of the same program in $\T$ such that it does not go wrong for some class of security relevant (hyper-)properties.
  Formally, given a $\cC$ a compiler $\ttcomp{\bullet}$ is an instrumentation for $\cC$ iff:

  $$
  \forall \trg{p}\in\trg{\partials}, \rsat{\ttcomp{p}}{\cC}
  $$

  We write $\instr{\ttcomp{\bullet}}{\cC}$.
\end{definition}
% S -> I and I -> T
% I -> T preserves memory safety


% enrich pipeline from source to target to see how to do the preservation from source in intermediate/target lang

\begin{definition}[Secure Instrumentation with Respect to $\cC$]\label{def:secure-instrumentation}
  A secure instrumentation with respect to some class $\cC$ ensures (hyper-)properties described by some class $\cC'$ without violating $\cC$-satisfying programs. We write $\sinstr{\ttcomp{\bullet}}{\cC}{\cC'}$.
  Thus, a compiler $\ttcomp{\bullet}$ is a secure instrumentation for $\cC'$ respecting $\cC$ iff:

  $$
  \rtp{\ttcomp{\bullet}}{\cC}\text{ and } \instr{\ttcomp{\bullet}}{\cC'}
  $$

\end{definition}

\begin{lemma}[Sequential Composition with a Secure Instrumentation]\label{lem:seqcompsecinstr}
  Given compilers $\sicomp{\bullet}$, $\itcomp{\bullet}$ and classes $\cC_{0},\cC_{1}$ such that
  \begin{assumptions}
  \item\label[ass]{lem:seqcompsecinstr:ass:a} $\rtp{\sicomp{\bullet}}{\cC_{0}}$
  \item\label[ass]{lem:seqcompsecinstr:ass:b} $\sinstr{\itcomp{\bullet}}{\cC_{1}}{\cC_{0}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{lem:seqcompsecinstr:goal:i} $\rtp{\sitcomp{\bullet}}{\cC_{0}\cup\cC_{1}}$
  \end{goals}
\end{lemma}

%\begin{definition}[No-v* Classes]
%  Let $\nvOne$ denote the singleton-class such that no SPECTRE v1 attack can happen.
%  Analgously, define $\nvFour$ as a singleton-class that disallows SPECTRE v4 attacks and $\nvOneFour$ as the class that disallows both v1 and v4 attacks, i.e. $\nvOneFour=\nvOne\cap\nvFour$.
%\end{definition}

% \begin{example}
%   Consider a compiler $\ttcomp{\bullet}_{1}$ such that $\sinstr{\ttcomp{\bullet}_{1}}{\nvOne}{\nvFour}$ and, similarily,
%   $\ttcomp{\bullet}_{4}$ such that $\sinstr{\ttcomp{\bullet}_{4}}{\nvFour}{\nvOne}$.

%   \begin{lemma}\label{lem:vOnevFourSafe}
%     Using above compilers, we now show that $\rtp{\ttcompN{\ttcomp{\bullet}_{1}}_{4}}{\nvOneFour}$.
%   \end{lemma}
%   \begin{proof}
%     By \Cref{lem:seqcompo} we get two goals, $\rtp{\ttcomp{\bullet}_{1}}{\nvOneFour}$ and $\rtp{\ttcomp{\bullet}_{4}}{\nvOneFour}$.

%     Since both cases are symmetrical, we only consider $\rtp{\ttcomp{\bullet}_{1}}{\nvOneFour}$ now.

%     Unfolding the definition of the goal, suppose there is a $\Pi\in\nvOneFour$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, while our new goal is $\rsat{\ttcomp{p}_{1}}{\Pi}$.

%     Strengthen the goal so that we need to show $\rsat{\ttcomp{p}_{1}}{\Pi}\wedge\Pi\in\nvOneFour$. Now, apply \Cref{def:secure-instrumentation}, so the only things left to show are $\Pi\in\nvOne$ and $\rsat{\trg{p}}{\Pi}$.
%     Both follow easily from our assumptions.
%   \end{proof}
%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{4}}_{1}}{\nvOneFour}$
%   \end{lemma}
%   \begin{proof}
%     By \Cref{lem:vOnevFourSafe} and \Cref{lem:swappable}.
%   \end{proof}

%   We now consider what happens if one of the two instrumentations is not secure with respect to the respective other class.
%   However, we focus on the case where the v1-instrumentation is insecure with respect to v4, due to symmetry.

%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{1}}_{4}}{\nvOneFour}$
%   \end{lemma}
%   \begin{proof}
%     Note that $\ttcomp{p}_{1}$ is a secure $\T$ program with respect to SPECTRE v1 attacks, given any $\trg{p}\in\trg{\partials}$.

%     Unfolding, let $\Pi\in\nvOneFour$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, our goal changes to $\rsat{\ttcompN{\ttcomp{\trg{p}}_{1}}_{4}}{\Pi}$.

%     Strengthen what we want to prove to $\rsat{\ttcompN{\ttcomp{\trg{p}}_{1}}_{4}}{\Pi}\wedge\Pi\in\nvOneFour$.
%     Apply \Cref{def:secure-instrumentation}, giving us proof-obligations that are already part of our assumptions.
%   \end{proof}

%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{4}}_{1}}{\nvOne}$
%   \end{lemma}
%   \begin{proof}
%     Let $\trg{p}=\ttcomp{p'}_{4}$ be some program that is the result of plugging $\trg{p'}\in\trg{\partials}$ into $\ttcomp{\bullet}_{4}$.

%     Our goal becomes $\rtp{\ttcomp{p}_{1}}{\nvOne}$. Unfolding it, let $\Pi\in\nvOne$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, where what is left to prove is $\rsat{\ttcomp{p}_{1}}{\nvOne}$.

%     The goal follows immediately by \Cref{def:instrumentation}, since $\ttcomp{p}_{1}$ is an instrumentation for $\nvOne$.
%   \end{proof}

%   Finally, if both are insecure instrumentations, the strongest result one can get is either the robust preservation of $\nvOne$ or $\nvFour$, depending on which compiler is run last.
% \end{example}

We have seen that we can already swap robust compilers with same input and output language in a compilation pipeline.
Now, we want to formalize this idea of ``being able to swap things around'' for source code instrumentations.

\begin{definition}[Swappable Instrumentations]
  We define vertical compositionality as follows.
  Let $\bar{\cC}$ be a set of classes that are eventually used in the compilation pipeline.
  Given a class $\cC\in\bar{\cC}$ the particular instrumentation $\ttcomp{\bullet}$ ensures any program to robustly satisfy, we can swap the instrumentation in the pipeline \textit{freely} around iff:

  $$
  \forall\cC'\in\bar{\cC}. \sinstr{\ttcomp{\bullet}}{\cC}{\cC'}
  $$
\end{definition}
\MK{it'd be nice to have a property-free version of this, since this here is TEDIOUS to prove in real-world}

\clearpage
Experimental
\begin{definition}[Encoders]
  An encoder $\tenc{\src{\bullet}}$ from language $\S$ to $\T$ is a function that constructs an abstract representation of the given $\S$ program as a $\T$ program.
\end{definition}
\noindent
Think of encoders as parsers.

\begin{definition}[Interpreters]
  An interpreter $\stinterp$ is a $\T$ program that faithfully implements the semantics of $\S$.
  That is, given $\src{p}\in\src{\partials}$ and some encoding function $\tenc{\src{\bullet}}$, then $\mktrace{\stinterp \trg{\linker} \tenc{\src{p}}}{\type} \Leftrightarrow \mktrace{\src{p}}{\type}$.
\end{definition}
Note: For an interpreter to \textit{faithfully} realize the semantics of $\S$, we really need the equivalence.
Say we only consider the $\Leftarrow$ direction as defining characteristic, then an interpreter that e.g. tosses a coin and thus $\behav{\stinterp\trg{\linker}\tenc{\src{p}}}=\{\trace_{1},\trace_{2}\}$ given $\behav{\src{p}}=\{\trace_{1}\}$ would be acceptable.
However, an interpreter that 99\% of the time emits $\trace_{2}$ is certainly not what we want.
Consider the converse, so $\Rightarrow$ as defining characteristic.
Then, swapping the behaviors from the previous example, the interpreter does not \textit{faithfully} simulate non-determinism that is present in the source language.
% Due to this, interpreters in our world always robustly satisfy relational hyperproperties

\begin{definition}[Specializers]
  A specializer $\ttspec{\bullet}$ is a $\T$ program that, given an encoding of another $\T$ program as input, emits a specialized version of that $\T$ program.
  So, given a partial program $\trg{p}$ and some set of inputs $\trg{x}\in\trg{\partials}$, $\ttspec{\tenc{p \linker x}}$ always terminates with a residual program $\trg{p'}$ such that $\behav{\trg{p\linker x}}=\behav{\trg{p'}}$.
\end{definition}
\noindent

\begin{definition}[2nd Futamura Projection]
  Given a specializer $\ttspec{\bullet}$, an interpreter $\stinterp$, and an encoding $\tenc{\src{\bullet}}$, we can compose them to a compiler $\stcomp{\bullet} = \ttspec{\stinterp \tenc{\src{\bullet}}}$.~\cite{Futamura1999}
\end{definition}

\clearpage

\section{Case Study}

\subsection{Source Language}
\subsubsection{Syntax}

\myfig{
	\vspace{-1em}
  \begin{gather*}
  \begin{aligned}
  \mi{Final\ Result}\ \src{\finalexprnoerr} \bnfdef&\ \src{\valueexpr} \mid \src{x} \hspace{0.5cm}
  \mi{May\ be\ a\ Result}\ \src{\finalexpr} \bnfdef\ \src{\finalexprnoerr} \mid \src{stuck} \\
  %
  \mi{Expressions}~\src{e} \bnfdef&\ \src{\finalexpr} \mid \src{e_{1} \oplus e_{2}} \mid \src{x[e]} \mid \src{let\ x = e_{1}\ in\ e_{2}}\mid \src{x[e_{1}]\leftarrow e_{2}} \\
  & \mid \src{let\ x=new\ e_{1}\ in\ e_{2}} \mid \src{delete\ x} \mid \src{return\ e} \mid \src{call\ foo\ e} \\
  & \mid \src{ifz\ e_1\ then\ e_2\ else\ e_3} \hspace{0.5cm} \text{where } \src{\oplus}\in\{\src{+},\src{-},\src{\times},\src{<}\}\\
  %
  \mi{Functions}~\src{\asymbol} \bnfdef&\ \src{let\ foo\ x : \type}_{\lambda}\src{:= e} \\
  %
  \mi{Expr.\ Types}~\types_{\src{e}} \bnfdef&\ \src{\nat} \mid \src{ref_q\ \nat} \hspace{0.25cm}
  %
  \mi{Qualifier}~\src{q} \bnfdef\ \full \mid \half\hspace{0.25cm}
  \mi{Values}~\src{\valueexpr} \bnfdef\ \src{n}\in\src{\nat} \\
  %
  \mi{Ectx\ Types}~\types_{\lambda}\ \bnfdef& \types_{\src{e}}\to\types_{\src{e}} \hspace{0.25cm}
  \mi{Types}~\types \bnfdef \types_{\src{e}}\mid\types_{\lambda}\mid\types_{\src{e}}\src{\to\bot} \hspace{0.25cm}
  %
  \mi{References}~\src{\loc}\in\src{\nat} \\
  \mi{Eval. Ctx.}~\src{K}\bnfdef &\ \src{\hole{\cdot}}\mid \src{K\oplus e}\mid \src{v\oplus K}\mid \src{x[K]}\mid \src{let\ x=K\ in\ e}\\
                     &\ \mid\src{x[K]\leftarrow e}\mid \src{x[v]\leftarrow K}\mid \src{let\ x=new\ K\ in\ e} \\
                     &\ \mid\src{ifz\ K\ then\ e_1\ else\ e_2} \mid \src{call\ foo\ K}\mid \src{return\ K} \\
  %
  \mi{Variables}~\ &\src{x} \mid \src{y} \mid \src{foo} \mid \dots \hspace{0.5cm}
  %
  \mi{Poison}~\ \src{\poison}~\bnfdef\ \src{\poisonless} \mid \src{\poisoned}\\
  %
  \mi{Typing. Env.}~\src{\Gamma} \bnfdef&\ \src{\hole{\cdot}} \mid \Gammas,\src{x:\type}\hspace{0.5cm}
  \mi{Store}~\src{\Delta} \bnfdef\ \src{\hole{\cdot}} \mid \src{x\mapsto\loc_\poison},\Deltas\\
  %
  \mi{Communication}~\src{\comm} \bnfdef&\ \src{\ctxtocomp} \mid \src{\comptoctx} \mid \src{\nocomm} \hspace{0.5cm}
  \mi{Heaps}~\src{H} \bnfdef\ \src{\hole{\cdot}} \mid \src{H}::\src{n} \\
  %
  \mi{Cont.\ Stack}~\src{\kontstack} \bnfdef&\ \src{\hole{\cdot}} \mid \src{K}^{\src{foo}}_{\src{\comm}},\src{\kontstack} \hspace{0.5cm}
  \mi{Library}~\src{\library} \bnfdef\ \src{\hole{\cdot}} \mid \src{\asymbol},\src{\library} \\
  \mi{Relevant}\ \src{\commlib} \bnfdef& \src{\hole{\cdot}} \mid \src{foo},\src{\commlib}\hspace{0.5cm}
  \mi{State}~\configs\ \bnfdef\ \src{\cfstate;\memstate}\\
  \mi{Flow\ State}~\src{\cfstate}\bnfdef&\ \src{\commlib;\library;\kontstack}\hspace{0.5cm}
  \mi{Memory\ State}~\src{\memstate}\bnfdef\ \src{H;\Delta} \\
  %
  \mi{Programs}\ &\src{prog\ \library_{ctx}\ \library_{comp}} \\
  \end{aligned}
  \end{gather*}
}{mmla-syntax}{Syntax of $\mmlAs$}

Most of the syntax is more or less standard.
Qualifiers $\src{q}$ can be attached to pointers to signal ownership.
Hereby, the qualifier $\src{\full}$ means "fully owned", meaning we may and also must delete the pointer at some point, while we cannot do the same for $\src{\half}$, which forbids us to delete.
Poison $\src{\poison}$ marks locations in the execution-context $\src{\Omega}$ as ,,to-be-deleted'' ($\src{\poisonless}$) or ,,deleted'' ($\src{\poisoned}$).
We chose to distinguish between successful final results ($\src{\finalexprnoerr}$) and potentially crashed results ($\src{\finalexpr}$).
Note that a final result may also be an identifier, which we keep around as abstract representation for locations of pointers.
However, we still distinct them from ordinary values ($\src{\valueexpr}$), since they don't behave like normal values.
For example, we cannot make canonical typing lemmas for them without the additional information contained in a non-empty typing-context.
When discussing secure compilation, there is a notion of ,,context'' and ,,component'', where the latter is usually the part one cares about.
We use the term ,,context-switching'' with its usual meaning, i.e. change in control flow to some other procedure.
For $\src{\comm}$, the representation $\src{\ctxtocomp}$ signalizes a context switch from context to component, $\src{\comptoctx}$ from component to context, and $\src{\nocomm}$ signals an internal change, either inside the context or inside the component.
The state $\configs$ carries information on what the current context is and the continuation stack $\src{\kontstack}$ is used in the semantics to mark events with above policy accordingly.
Continuations $\src{K}$ in the stack are annotated with the symbol of communication $\src{\comm}$ that was used when the continuation was being pushed on the stack and with the name of the function $\src{foo}$ the continuation originates from.
Programs $\src{prog\ \library_{ctx}\ \library_{comp}}$ contain two lists of top-level definitions $\src{\library_{ctx}}$ and $\src{\library_{comp}}$.
$\src{\library_{ctx}}$ takes the role as attacker code.

\subsubsection{Static Semantics}
\begin{definition}[NoOwnedPtr]
  We write $\src{\noptr{\Gamma}}$ iff for any $\src{x}, \src{\type}$, if $\src{x} : \src{\type}\in\src{\Gamma}$, then $\types\not=\ptr$.
\end{definition}
\myfig{
  \begin{center}
    \judgbox{\vdash\src{\tau}\operatorname{int}}{,,$\src{\tau}$ is an interface type.''}$\;$\\
  \typerule{int-$\src{\nat}$}{
  }{
    \vdash\src{\nat}\operatorname{int}
  }{src-int-type-nat}
  \typerule{int-$\src{\wptr}$}{
  }{
    \vdash\src{\wptr}\operatorname{int}
  }{src-int-type-wptr}
  \end{center}
}{src-int-types}{Interface types of $\mmlAs$.}

We introduce interface types to explicitly disallow passing owned pointers.

\myfig{
  \begin{center}
  \judgbox{\Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}}{,,Environment $\Gammas$ can be split into $\src{\Gamma_1}$ and $\src{\Gamma_2}$.''}
  %
  $\;$\\
  \typerule{splitEmpty}{
  }{
    \src{\hole{\cdot}} \equiv \src{\hole{\cdot}}\circ\src{\hole{\cdot}}
  }{t-empty-split}
  %
  \typerule{splitEmptyL}{
  }{
    \src{\Gamma} \equiv \src{\hole{\cdot}}\circ\src{\Gamma}
  }{t-empty-splitL}
  %
  \typerule{splitEmptyR}{
  }{
    \src{\Gamma} \equiv \src{\Gamma}\circ\src{\hole{\cdot}}
  }{t-empty-splitR}
  %
  \typerule{$\nat$split}{
    \Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\nat},\Gammas \equiv \src{x:\nat},\src{\Gamma_1}\circ\src{x:\nat},\src{\Gamma_2}
  }{t-nat-split}
  %
  \typerule{weakPtrSplit}{
    \Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\wptr},\Gammas \equiv \src{x:\wptr},\src{\Gamma_1}\circ\src{x:\wptr},\src{\Gamma_2}
  }{t-wptr-split}
  %
  \typerule{ptrLSplit}{
    \Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\ptr},\Gammas \equiv \src{x:\ptr},\src{\Gamma_1}\circ\src{\Gamma_2}
  }{t-ptr-l-split}
  %
  \typerule{ptrRSplit}{
    \Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\ptr},\Gammas \equiv \src{x:\wptr,\Gamma_1}\circ\src{x:\ptr},\src{\Gamma_2}
  }{t-ptr-r-split}
  %
  \typerule{arrowSplit}{
    \vdash\src{\type_e^{(1)}}\ \operatorname{int} &
    \vdash\src{\type_e^{(2)}}\ \operatorname{int} &
    \src{\Gamma}\equiv\src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{foo:\type_e^{(1)}\to\type_e^{(2)}},\Gammas \equiv \src{foo:\type_e^{(1)}\to\type_e^{(2)}},\src{\Gamma_1}\circ\src{foo:\type_e^{(1)}\to\type_e^{(2)}},\src{\Gamma_2}
  }{t-arrow-split}
  \end{center}
}{w-ctx-split}{Context Splitting of $\mmlAs$ typing contexts.}

The splitting of contexts takes care to propagate owned-pointers towards the end.
This way, no non-owned pointer occurs in the context after an owned one, where both have the same identifier.
Note that non-owned pointers and values may be freely duplicated and that we can generate non-owned pointers if we have ownership.

\myfig{
  \judgbox{\typechecks{\Gamma}{e}{\types}}{,,Under environment $\Gammas$ the expression $\src{e}$ has type $\types$.''}

  \begin{center}
  \typerule{$t-\src{var}$}{
  \src{\noptr{\Gamma_1}}&
  \src{\noptr{x:\type,\hole{\cdot}}}&
  \src{\noptr{\Gamma_2}}
	}{
    \typechecks{\Gamma_1,x:\type,\Gamma_2}{x}{\type}
	}{t-var}
  %
  \typerule{$t-\src{\nat}$}{
    \src{\noptr{\Gamma}}
  }{
    \typechecks{\Gamma}{n}{\nat}
  }{t-nat}
  %
  \typerule{$t-\src{\oplus}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{e_1\oplus e_2}{\nat}
  }{t-binop}
  %
  \typerule{$t-$get}{
    \typechecks{\Gamma_2}{x}{\wptr} &
    \typechecks{\Gamma_1}{e}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{x[e]}{\nat}
  }{t-get}
  %
  \typerule{$t-$set}{
    \typechecks{\Gamma_3}{x}{\wptr} &
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{(\Gamma_1\circ\Gamma_2)\circ\Gamma_3}{x[e_1]\leftarrow e_2}{\nat}
  }{t-set}
  %
  \typerule{$t-\src{let}$}{
    \typechecks{\Gamma_1}{e_1}{\type_{e}^{(1)}} &
    \typechecks{x:\type_{e}^{(1)},\Gamma_2}{e_2}{\type^{(2)}}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{let\ x=e_1\ in\ e_2}{\type^{(2)}}
  }{t-let}
  %
  \typerule{$t-\src{new}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{x:\ptr,\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{let\ x=new\ e_1\ in\ e_2}{\nat}
  }{w-t-new}
  %
  \typerule{$t-\src{delete}$}{
    \src{\noptr{\Gamma_1}} & \src{\noptr{\Gamma_2}}
  }{
    \typechecks{\Gamma_1,x:\ptr,\Gamma_2}{delete\ x}{\nat}
  }{w-t-delete}
  %
  \typerule{$t-\src{call}$}{
    \vdash\src{\type_e^{(1)}}\ \operatorname{int} &
    \vdash\src{\type_e^{(2)}}\ \operatorname{int} \\
    \typechecks{\Gamma}{foo}{\type_e^{(1)}\to\type_e^{(2)}} &
    \typechecks{\Gamma}{e}{\type_e^{(1)}}
  }{
    \typechecks{\Gamma}{call\ foo\ e}{\type_e^{(2)}}
  }{t-call}
  %
  \typerule{$t-\src{return}$}{
    \src{\type_e}\ \operatorname{int} &
    \typechecks{\Gamma}{e}{\type_e}
  }{
    \typechecks{\Gamma}{return\ e}{\type_e\to\bot}
  }{t-return}
  %
  \typerule{$t-\src{ifz}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{\Gamma_2}{e_2}{\type} &
    \typechecks{\Gamma_2}{e_3}{\type}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{ifz\ e_1\ then\ e_2\ else\ e_3}{\type}
  }{w-t-if}
  \end{center}
}{w-expr-ty}{Checking of $\mmlAs$ expressions.}
The context splitting takes care that for e.g. \Cref{tr:t-binop} it cannot happen that we do something like $\src{(delete\ x) + x[0]}$.
For \Cref{tr:t-var,tr:t-nat} we require that the contexts do not contain any owned pointer.
Intuitively, an owned pointer is useless upto getting a non-owned version from context splitting, because we cannot do anything with it besides deleting.
This is inspired by linear logic.

\myfig{
  \judgbox{\typechecks{\Gamma}{K}{\types^{(1)}\to\types^{(2)}}}{,,Under environment $\Gammas$ the evaluation context $\src{K}$ requires an\\object of type $\src{\type^{(1)}}$ and yields one of type $\src{\type^{(2)}}$.''}
  \begin{center}
    \typerule{et-$\src{\hole{\cdot}}$}{
    }{
      \typechecks{\Gamma}{\hole{\cdot}}{\type\to\type}
    }{w-te-hole}
    %
    \typerule{et-$\src{\oplus}$R}{
      \typechecks{\Gamma}{\valueexpr}{\nat} &
      \typechecks{\Gamma}{K}{\type\to\nat}
    }{
      \typechecks{\Gamma}{\valueexpr\oplus K}{\type\to\nat}
    }{w-te-bionpR}
    %
    \typerule{et-$\src{\oplus}$L}{
      \typechecks{\Gamma}{K}{\type\to\nat} &
      \typechecks{\Gamma}{e}{\nat}
    }{
      \typechecks{\Gamma}{K\oplus e}{\type\to\nat}
    }{w-te-bionpL}
    %
    \typerule{et-get}{
      \typechecks{\Gamma}{x}{\wptr} &
      \typechecks{\Gamma}{K}{\type\to\nat}
    }{
      \typechecks{\Gamma}{x[K]}{\type\to\nat}
    }{w-te-get}
    %
    \typerule{et-setR}{
      \typechecks{\Gamma}{v}{\nat} &
      \typechecks{\Gamma}{K}{\type\to\nat}
    }{
      \typechecks{\Gamma}{x[\valueexpr]\leftarrow K}{\type\to\nat}
    }{w-te-setR}
    %
    \typerule{et-setL}{
      \typechecks{\Gamma}{K}{\type\to\nat} &
      \typechecks{\Gamma}{e}{\nat}
    }{
      \typechecks{\Gamma}{x[K]\leftarrow e}{\type\to\nat}
    }{w-te-setL}
    %
    \typerule{et-let}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\type_{e}'} &
      \typechecks{x:\type_{e}',\Gamma}{e}{\type^{(2)}}
    }{
      \typechecks{\Gamma}{let\ x=K\ in\ e}{\type^{(1)}\to\type^{(2)}}
    }{w-te-let}
    %
    \typerule{et-new}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\nat} &
      \typechecks{x:\ptr,\Gamma}{e}{\type^{(2)}}
    }{
      \typechecks{\Gamma}{let\ x=new\ K\ in\ e}{\type^{(1)}\to\type^{(2)}}
    }{w-te-new}
    %
    \typerule{et-ifz}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\nat} &
      \typechecks{\Gamma}{e_2}{\type^{(2)}}&
      \typechecks{\Gamma}{e_3}{\type^{(2)}}&
    }{
      \typechecks{\Gamma}{ifz\ K\ then\ e_2\ else\ e_3}{\type^{(1)}\to\type^{(2)}}
    }{w-te-ifz}
    %
    \typerule{et-call}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\type'} &
      \typechecks{\Gamma}{foo}{\type'\to\type^{(2)}}
    }{
      \typechecks{\Gamma}{call\ foo\ K}{\type^{(1)}\to\type^{(2)}}
    }{w-te-call}
    %
    \typerule{et-ret}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\type^{(2)}}
    }{
      \typechecks{\Gamma}{return\ K}{\type^{(1)}\to(\type^{(2)}\to\bot)}
    }{w-te-ret}
  \end{center}
}{w-ectx-ty}{Checking of $\mmlAs$ evaluation contexts.}

\myfig{
  \judgbox{\src{\library}\downarrow=\src{\Gamma}}{,,Project $\mmlAs$ library to static typing context.''}$\;$\\
  \begin{center}
    \typerule{$\src{\library}$-proj-$\src{\hole{\cdot}}$}{
    }{
      \src{\hole{\cdot}}\downarrow = \src{\hole{\cdot}}
    }{w-lib-proj-empty}
    %
    \typerule{$\src{\library}$-proj-cons}{
      \src{\library}\downarrow = \src{\Gamma}
    }{
      (\src{let\ foo\ x : \type}_\lambda\src{:= e})\src{,\library}\downarrow = (\src{foo \mapsto \type}_\lambda),\src{\Gamma}
    }{w-lib-proj-cons}
  \end{center}
  %
  \judgbox{\operatorname{dom}\ \src{\library}=\src{foo},\dots,\src{bar}}{,,Collect function names.''}$\;$\\
  \begin{center}
    \typerule{$\src{\library}$-dom-$\src{\hole{\cdot}}$}{
    }{
      \operatorname{dom}\ \src{\hole{\cdot}} = \src{\hole{\cdot}}
    }{w-lib-dom-empty}
    %
    \typerule{$\src{\library}$-dom-cons}{
      \operatorname{dom}\ \src{\library} = \src{D}
    }{
      \operatorname{dom}\ (\src{let\ foo\ x : \type}_\lambda\src{:= e})\src{,\library} = \src{foo},\src{D}
    }{w-lib-dom-cons}
  \end{center}
}{w-gamma-of-symbols}{Extracting type annotations and function names.}

\myfig{
  \begin{center}
    \judgbox{\src{\library}\equiv\src{\library_1}\cup\src{\library_2}}{,,Merging $\mmlAs$ libraries.''}$\;$\\
    \typerule{lib-merge-empty}{
      \src{\library}=\src{\library_1}
    }{
      \src{\library}\equiv\src{\library_1}\cup\src{\hole{\cdot}}
    }{src-lib-merge-empty}
    %
    \typerule{lib-merge-cons}{
      \src{\library}\equiv\src{\library_1}\cup\src{\library_2}
    }{
      \src{\asymbol,\library}\equiv\src{\library_1}\cup\src{\asymbol,\library_2}
    }{src-lib-merge-cons}

    \judgbox{\src{\library_1\linker\library_2}=\src{\library}}{,,Syntactically linking $\mmlAs$ libraries.''}$\;$\\
    \typerule{syntactic-plugging}{
      \operatorname{dom}\src{\library_1}\cap\operatorname{dom}\src{\library_2} = \emptyset &
      \src{\library}\equiv\src{\library_1}\cup\src{\library_2}
    }{
      \src{\library_1\linker\library_2} = \src{\library}
    }{src-plugging}
  \end{center}
}{w-plugging-s}{$\mmlAs$ plugging of libraries.}

\myfig{
  \begin{center}
    \judgbox{\src{\Gamma}\vdash\src{\library}\ \operatorname{ok}}{,,$\mmlAs$ library typechecks.''}$\;$\\
    %
    \typerule{t-$\src{\library}$-empty}{
    }{
      \src{\Gamma}\vdash\src{\hole{\cdot}}\ \operatorname{ok}
    }{w-t-lib-empty}
    %
    \typerule{t-$\src{\library}$-cons}{
      \src{\type_e^{(1)}}\ \operatorname{int} &
      \src{\type_e^{(2)}}\ \operatorname{int} &
      \src{\Gamma}\vdash\src{\library}\ \operatorname{ok} &
      \typechecks{x:\type_e^{(1)},\Gamma}{e}{\type_{e}^{(2)}\to\bot}
    }{
      \src{\Gamma}\vdash(\src{let\ foo\ x : \type_e^{(1)}}\to\src{\type_e^{(2)}:= e}),\src{\library}\ \operatorname{ok}
    }{w-t-lib-cons}\\[0.33cm]
    %
    \judgbox{\vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv\src{\library},\src{\commlib}}{,,$\mmlAs$ program $\src{prog\ \library_{ctx}\ \library_{comp}}$ typechecks. $\src{\library}$ is the\\result of linking $\src{\library_{ctx}}$ and $\src{\library_{comp}}$. $\src{\commlib}$ is $\operatorname{dom}\ \src{\library_{comp}}$.''}$\;$\\
    %
    \typerule{$t-\text{prog}$}{
      \src{\library}=\src{\library_{ctx}\linker\library_{comp}} &
      \src{\library}\downarrow = \src{\Gamma_0} &
      \src{main}\in\operatorname{dom} \src{\Gamma_0} &
      \src{\Gamma_0}\vdash\src{\library}\ \operatorname{ok}
    }{
      \vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv \src{\library},\operatorname{dom}\ \src{\library_{comp}}
    }{w-t-wprog}
    %
    \judgbox{\typechecks{}{\configs\triangleright e}{\type}}{,,$\mmlAs$ runtime program $\src{\configs\triangleright e}$ typechecks.''}$\;$\\
    \typerule{$t-\text{prog}$}{
      \typechecks{\library}{\Delta}{\Gamma}&
      \typechecks{\Gamma}{e}{\type}
    }{
      \typechecks{}{\commlib;\library;\kontstack;H;\Delta\triangleright e}{\type}
    }{w-t-prog}
  \end{center}
}{w-program-ty}{Checking of $\mmlAs$ contexts, components, programs, and whole programs.}
Perhaps most interesting is \Cref{tr:w-t-prog} which generates a suitable typing context from the execution context.
\Cref{fig:store-ty} shows how this works exactly.

\myfig{
  \begin{center}
    \judgbox{\typechecks{\library}{\Delta}{\Gamma}}{,,$\mmlAs$ location map $\Deltas$ yields static typing environment $\Gammas$.''}
    \typerule{$T\text{empty}\src{\Delta}$}{
      \src{\library}\downarrow=\src{\Gamma}
    }{
      \typechecks{\library}{\hole{\cdot}}{\Gammas}
    }{t-empty-store}
    %
    \typerule{$T\ptr$}{
    \typechecks{\library}{\Delta}{\Gamma}
    }{
    \typechecks{\library}{x\mapsto\loc_\poisonless,\Delta}{x:\ptr,\Gamma}
    }{t-ptr-store}
    %
    \typerule{$T\ptr\text{poison}$}{
    \typechecks{\library}{\Delta}{\Gamma}
    }{
    \typechecks{\library}{x\mapsto\loc_\poisoned,\Delta}{\Gamma}
    }{t-poison-store}
  \end{center}
}{store-ty}{$\mmlAs$ store typing.}
Here, we want to populate the typing context with all {\em valid} pointers, which are those that are not poisoned.
Pointers of type $\src{\wptr}$ are implicitly generated during elaboration, see \Cref{fig:w-ctx-split}.

\subsubsection{Dynamic Semantics}

\myfig{
  \begin{gather*}
  \begin{aligned}
  \mi{Interface\ Value}~\src{\interfacevalue} \bnfdef&\ \src{\valueexpr} \mid \src{\loc} \\
  \mi{Events}~\src{\event} \bnfdef&\ \src{\emptyevent} \mid \src{Alloc\ \loc\ n} \mid \src{Dealloc\ \loc} \mid \src{Get\ \loc\ n} \mid \src{Set\ \loc\ n} \mid \src{\lightning} \\
                                  & \mid \src{Call\ \comm\ foo\ \interfacevalue} \mid \src{Ret\ \comm\ \interfacevalue} \mid \src{Start} \mid \src{End\ \interfacevalue}\\
  \end{aligned}
  \end{gather*}
}{w-events}{Events of $\mmlAs$.}

We add the syntactic category of {\em interface values} $\src{\interfacevalue}$, because we want call and return events to allow for values and for locations, which are not values.
They do not have any other relevance.

\myfig{
  \judgbox{\exprevals{\configs}{e}{\configs'}{e'}{\event}}{,,Expression $\src{e}$ evaluates under configuration $\configs$ to $\src{e'}$ and new\\configuration $\src{\configs'}$, emitting event $\src{\event}$.''}
  %
  \typerule{$e-\src{\oplus}$}{
    \src{n_1}\oplus\src{n_2}=\src{n_3}
  }{
    \exprevals{\configs}{n_1\oplus n_2}{\configs}{n_3}{\emptyevent}
  }{w-e-oplus}
  %
  \typerule{$e-\src{get}-\in$}{
    \src{\loc}+\src{n}\in\text{dom }\src{H}
  }{
    \exprevals{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{x[n]}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{H(\loc+n)}{Get\ \loc\ n}
  }{w-e-get-in}
  %
  \typerule{$e-\src{get}-\notin$}{
    \src{\loc}\notin\text{dom }\src{H}
  }{
    \exprevals{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{x[n]}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{1729}{Get\ \loc\ n}
  }{w-e-get-notin}
  %
  \typerule{$e-\src{set}$}{
    \src{H'} = \src{H}(\src{\loc+n}\mapsto \src{v})
  }{
    \exprevals{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{x[n]\leftarrow v}{\cfstate;H';\Delta_1,x\mapsto\loc_\poison,\Delta_2}{v}{Set\ \loc\ n\ v}
  }{w-e-set}
  %
  \typerule{$e-\src{let}-\src{\finalexprnoerr}$}{
  }{
  \exprevals{\Omega}{let\ x=\finalexprnoerr\ in\ e}{\Omega}{e[\finalexprnoerr/x]}{\emptyevent}
  }{w-e-let-x}
  %
  \typerule{$e-\src{delete}$}{
  }{
    \exprevals{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{delete\ x}{\cfstate;H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}{0}{Dealloc\ \loc}
  }{w-e-delete}
  %
  \typerule{$e-\src{new}$}{
    \fresh{\src{\Delta}}{\src{\loc}} &
    \fresh{\src{\Delta}}{\src{z}} &
    \src{H'} = \src{H} \ll \src{n} &
  }{
  \exprevals{\cfstate;H;\Delta}{let\ x=new\ n\ in\ e}{\cfstate;H';z\mapsto \loc_\poisonless,\Delta}{e[z/x]}{Alloc\ \loc\ n}
  }{w-e-let-new}
  %
  \typerule{$e-\src{ifz}-$true}{
  }{
  \exprevals{\Omega}{ifz\ 0\ then\ e_1\ else\ e_2}{\Omega}{e_1}{\emptyevent}
  }{w-e-if-true}
  %
  \typerule{$e-\src{ifz}-$false}{
  }{
  \exprevals{\Omega}{ifz\ S(n)\ then\ e_1\ else\ e_2}{\Omega}{e_2}{\emptyevent}
  }{w-e-if-false}
  %
%  \typerule{$e-\src{abort}$}{
%  }{
%    \exprevals{\Omega}{abort()}{\Omega}{stuck}{\lightning}
%  }{w-e-abort}
}{w-expr-prim-eval}{Primitive Evaluation of $\mmlAs$ expressions.}
Evaluation is mostly straightforward, the only interesting cases involve the pointers.
Specifically, \Cref{tr:w-e-delete} demonstrates why we need the poison-tag on the locations: Regardless of the current tag, emit a $\src{Dealloc\ \loc}$ event and mark $\src{\loc}$ as poisoned ($\src{\poisoned}$).
The intuitive solution, removing the mapping on deletion, doesn't allow to run programs that delete twice.
However, we want to model memory effects and show that such situations never happen, even though they {\em could}.
Given a poisoned location, we can still do everything with it: reading, writing, or deletion.
When generating the static context from the execution context, \Cref{tr:t-poison-store} allows us to disregard deleted locations which will help us reason that the given execution could not have been happening if the program was well-typed to begin with.

\myfig{
  \begin{center}
    \judgbox{\execs[]{\configs}{K[e]}{\configs'}{K[e']}{\event}}{,,Given an evaluation context $\src{K}$ and an expression $\src{e}$,\\it evaluates under configuration $\configs$ to $\src{e'}$ and new\\configuration $\src{\configs'}$ in context $\src{K}$, emitting event $\src{\event}$.''}
    %
    \typerule{$e-\text{ctx}$}{
      \exprevals{\Omega}{e}{\Omega'}{e'}{\event}
    }{
      \execs[]{\Omega}{K[e]}{\Omega'}{K[e']}{\event}
    }{w-e-ectx}
    %
    \typerule{$e-\text{ctx}-\src{stuck}$}{
      \exprevals{\Omega}{e}{\Omega'}{stuck}{\lightning}
    }{
      \execs[]{\Omega}{K[e]}{\Omega'}{stuck}{\lightning}
    }{w-e-ectx-stuck}
    %
    \typerule{$e-\text{ctx}-\src{call}-$main}{
      \src{\Omega}=\src{\commlib;\library;\hole{\cdot};\memstate} &
      \src{\library}=\src{\library_1,}(\src{let\ main\ x:\type}_\lambda\src{:=e})\src{,\library_2} &
      \src{\Omega'}=\src{\commlib;\library;K^{main}_{\comm},\hole{\cdot};\memstate} \\
    }{
      \execs[]{\Omega}{K[call\ main\ \valueexpr]}{\Omega'}{e[x/\valueexpr]}{Start}
    }{w-e-ectx-call-main}
    %
    \typerule{$e-\text{ctx}-\src{call}-\src{\valueexpr}$}{
      \src{\Omega}=\src{\commlib;\library;\kontstack;\memstate} &
      \src{\library}=\src{\library_1,}(\src{let\ foo\ x:\type}_\lambda\src{:=e})\src{,\library_2} \\
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{\kontstack},\src{v}) = \src{\event},\src{\comm} &
      \src{\Omega'}=\src{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate} \\
    }{
      \execs[]{\Omega}{K[call\ foo\ \valueexpr]}{\Omega'}{e[x/\valueexpr]}{\event}
    }{w-e-ectx-call-value}
    %
    \typerule{$e-\text{ctx}-\src{call}-\src{\loc}$}{
      \src{\Omega}=\src{\commlib;\library;\kontstack;\memstate} &
      \src{\memstate}=\src{H;\Delta}&
      \src{\Delta}=\src{\Delta_1},\src{x\mapsto\loc_\poison},\src{\Delta_2}\\
      \src{\library}=\src{\library_1,}(\src{let\ foo\ x:\type}_\lambda\src{:=e})\src{,\library_2} \\
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{\kontstack},\src{\loc}) = \src{\event},\src{\comm} &
      \src{\Omega'}=\src{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate} \\
    }{
      \execs[]{\Omega}{K[call\ foo\ x]}{\Omega'}{e[x/\valueexpr]}{\event}
    }{w-e-ectx-call-loc}
    %
    \typerule{$e-\text{ctx}-\src{return}-$main}{
    }{
      \exec[]{\src{\commlib;\library;K^{main}_{\ctxtocomp},\hole{\cdot};\memstate}}{\src{K'[return\ \valueexpr]}}{\src{\commlib;\library;\hole{\cdot};\memstate}}{\src{K[\valueexpr]}}{\src{End\ \valueexpr}}
    }{w-e-ectx-ret-main}
    %
    \typerule{$e-\text{ctx}-\src{return}-\src{\valueexpr}$}{
    }{
      \exec[]{\src{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate}}{\src{K'[return\ \valueexpr]}}{\src{\commlib;\library;\kontstack;\memstate}}{\src{K[\valueexpr]}}{\rho_{\tiny ret}\left(\src{\comm},\src{\valueexpr}\right)}
    }{w-e-ectx-ret-value}
    %
    \typerule{$e-\text{ctx}-\src{return}-\src{\loc}$}{
      \rho_{\tiny ret}\left(\src{\comm}\right)=\src{\comm_0} &
      \src{\memstate}=\src{H;\Delta}&
      \src{\Delta}=\src{\Delta_1},\src{x\mapsto\loc_\poison},\src{\Delta_2}
    }{
      \exec[]{\src{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate}}{\src{K'[return\ x]}}{\src{\commlib;\library;\kontstack;\memstate}}{\src{K[x]}}{\rho_{\tiny ret}\left(\src{\comm},\src{\loc}\right)}
    }{w-e-ectx-ret-loc}
    %
    \judgbox{\rho_{\tiny ret}(\src{\comm},\src{\interfacevalue})=\src{\event}}{,,Given the last comm. and we are returning, yield event.''}
    %
    \typerule{comm-ret-ctxtocomp}{
    }{
      \rho_{\tiny ret}(\src{\ctxtocomp},\src{\interfacevalue})=\src{Ret\ \ctxtocomp\ \interfacevalue}
    }{w-comm-ret-ctxtocomp}
    %
    \typerule{comm-ret-internal}{
    }{
      \rho_{\tiny ret}(\src{\nocomm},\src{\interfacevalue})=\src{\varepsilon}
    }{w-comm-ret-internal}
    %
    \typerule{comm-ret-comptoctx}{
    }{
      \rho_{\tiny ret}(\src{\comptoctx},\src{\interfacevalue})=\src{Ret\ \comptoctx\ \interfacevalue}
    }{w-comm-ret-comptoctx}\\[0.33cm]
    %
    \judgbox{\rho_{\tiny call}(\src{\commlib},\src{foo},\src{\kontstack},\src{\interfacevalue})=\src{\event},\src{\comm}}{,,Given the ctx. info, yield event. $\src{\commlib}$ contains all\\component names. $\src{foo}$ is the to-be-called function. $\src{\kontstack}$ is\\the stack of eval. ctx. and $\src{\interfacevalue}$ the passed interface-value.''}
    %
    \typerule{comm-call-empty-stack-comp}{
      \src{foo}\in\src{\commlib}
    }{
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{\hole{\cdot}},\src{\interfacevalue})=\src{Call\ \ctxtocomp\ foo\ \interfacevalue},\src{\comptoctx}
    }{w-comm-call-empty-stack-comp}
    %
    \typerule{comm-call-empty-stack-ctx}{
      \src{foo}\notin\src{\commlib}
    }{
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{\hole{\cdot}},\src{\interfacevalue})=\src{Call\ \comptoctx\ foo\ \interfacevalue},\src{\ctxtocomp}
    }{w-comm-call-empty-stack-ctx}
    %
    \typerule{comm-call-nonempty-stack}{
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{bar},\src{\interfacevalue})=\src{\event},\src{\comm}
    }{
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{K^{bar},\kontstack},\src{\interfacevalue})=\src{\event},\src{\comm}
    }{w-comm-call-nonempty-stack}
    %
    \judgbox{\rho_{\tiny call}(\src{\commlib},\src{foo},\src{bar_{cur}},\src{\interfacevalue})=\src{\event},\src{\comm}}{,,Given the current ctx. info, yield comm. $\src{\commlib}$ contains\\all component names. $\src{foo}$ is the to-be-called\\function. $\src{bar_{cur}}$ is the current function in which the\\call is performed. $\src{\interfacevalue}$ is the passed interface-value.''}
    %
    \typerule{comm-call-comptoctx}{
      \src{foo}\notin\src{\commlib} &
      \src{\commlib}=\src{\commlib_1},\src{bar_{cur}},\src{\commlib_2}
    }{
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{bar_{cur}},\src{\interfacevalue})=\src{Call\ \comptoctx\ foo\ \interfacevalue},\src{\ctxtocomp}
    }{w-comm-call-comptoctx}
    %
    \typerule{comm-call-internal-both-irrelevant}{
      \src{foo}\notin\src{\commlib} &
      \src{bar_{cur}}\notin\src{\commlib}
    }{
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{bar_{cur}},\src{\interfacevalue})=\src{\emptyevent},\src{\nocomm}
    }{w-comm-call-internal-both-irrelevant}
    %
    \typerule{comm-call-internal-both-relevant}{
      \src{\commlib} = \src{\commlib_1},\src{foo},\src{\commlib_2} &
      \src{\commlib} = \src{\commlib_3},\src{bar_{cur}},\src{\commlib_4}
    }{
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{bar_{cur}},\src{\interfacevalue})=\src{\emptyevent},\src{\nocomm}
    }{w-comm-call-internal-both-relevant}
    %
    \typerule{comm-call-ctxtocomp}{
      \src{\commlib}=\src{\commlib_1},\src{foo},\src{\commlib_2} &
      \src{bar_{cur}}\notin\src{\commlib}
    }{
      \rho_{\tiny call}(\src{\commlib},\src{foo},\src{bar_{cur}},\src{\interfacevalue})=\src{Call\ \ctxtocomp\ foo\ \interfacevalue},\src{\comptoctx}
    }{w-comm-call-ctxtocomp}
  \end{center}
}{w-expr-ctx-eval}{Contextual Evaluation of $\mmlAs$ expressions.}
\myfig{
  \begin{center}
    \judgbox{\execs{\configs}{e}{\configs'}{e'}{\trace}}{,,Expression $\src{e}$ evaluates under configuration $\configs$ to $\src{e'}$ and\\new configuration $\src{\configs'}$, emitting list of events $\src{\trace}$.''}
    %
    \typerule{$es-\text{refl}$}{
    }{
      \execs{\configs}{\finalexpr}{\configs}{\finalexpr}{\hole{\cdot}}
    }{ws-e-refl}
    \typerule{$es-\text{trans}-$important}{
      \execs[]{\configs}{e}{\configs'}{e'}{\event}&
      \execs{\configs'}{e'}{\configs''}{e''}{\trace}&
      \src{\event}\not=\src{\emptyevent}
    }{
      \execs{\configs}{e}{\configs''}{e''}{\event \cdot \trace}
    }{ws-e-trans-important}
    \typerule{$es-\text{trans}-$unimportant}{
      \execs[]{\configs}{e}{\configs'}{e'}{\emptyevent}&
      \execs{\configs'}{e'}{\configs''}{e''}{\trace}&
    }{
      \execs{\configs}{e}{\configs''}{e''}{\trace}
    }{ws-e-trans-unimportant}
  \end{center}
}{w-steps}{Trace prefix generation given a $\mmlAs$ program using the reflexive-transitive closure.}

\myfig{
  \begin{center}
    \judgbox{\wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{\finalexprnoerr}{\trace}}{,,Run $\mmlAs$ program $\src{prog\ \library_{ctx}\ \library_{comp}}$, giving dynamic state\\$\configs$ and emitting trace $\src{\trace}$.''}
    \typerule{$e-\text{wprog}$}{
      \vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv \src{\commlib},\src{\library} \\
      \execs{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexpr}{\trace}
    }{
      \wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{\finalexpr}{\trace}
    }{ws-e-prog}
    %
    \typerule{$e-\text{wprog}-\lightning$}{
      \vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv \src{\commlib},\src{\library} \\
      \execs{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexpr}{\trace\cdot\lightning}
    }{
      \wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{\finalexpr}{\trace\cdot\lightning}
    }{ws-e-prog}
  \end{center}
}{wprog-run}{Running a whole $\mmlAs$ program.}

\subsubsection{\gls*{ms}-Specific Events}
We introduce another set of actions that allows us to abstract over reading or writing at a certain location.

\myfig{
  \begin{gather*}
  \begin{aligned}
    \mi{Events}~\msevent \bnfdef&\ \specificev{\emptyevent}\mid \specificev{Alloc\ \loc\ n} \mid \specificev{Dealloc\ \loc} \mid \specificev{Use\ \loc\ n} \mid \specificev{\lightning}
  \end{aligned}
  \end{gather*}
}{w-specific-events}{\gls*{ms}-Specific Events.}
In addition to the actions, we also need a way to translate from concrete actions, as emitted by a program's execution, to these more abstract actions.
The translation is, however, standard.
The empty action $\specificev{\emptyevent}$ is necessary. When proving lemmas by structural induction on the primitive steps (\Cref{fig:w-expr-prim-eval}), we get a concrete event $\src{\emptyevent}$ that needs to be related to some $\msevent$. The natural candidate is $\specificev{\emptyevent}$.
We also use it to project the call/return events onto it.

\myfig{
  \begin{center}
    \judgbox{\delta_{MS}(\src{\loc})=\specificev{\loc}}{,,A map from $\mmlAs$ memory locations $\src{\loc}$ to MS-specific locations $\specificev{\loc}$.''}
    \judgbox{\tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\event} = \msevent}{,,Project an $\mmlAs$ event $\src{\event}$ to $\msevent$.''}
    %
    \typerule{filter-alloc-relevant}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n} &
      \src{\comm}=\src{\ctxtocomp}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Alloc\ \loc\ n} = \src{\comm},\specificev{Alloc\ \loc\ n}
    }{filter-alloc-relevant}
    %
    \typerule{filter-dealloc-relevant}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \src{\comm}=\src{\ctxtocomp}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Dealloc\ \loc} = \src{\comm},\specificev{Dealloc\ \loc}
    }{filter-dealloc-relevant}
    %
    \typerule{filter-get-relevant}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n} &
      \src{\comm}=\src{\ctxtocomp}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Get\ \loc\ n} = \src{\comm},\specificev{Use\ \loc\ n}
    }{filter-get-relevant}
    %
    \typerule{filter-set-relevant}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n} &
      \src{\comm}=\src{\ctxtocomp}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Set\ \loc\ n} = \src{\comm},\specificev{Use\ \loc\ n}
    }{filter-set-relevant}
    %
    %
    \typerule{filter-alloc-irrelevant}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n} &
      \src{\comm}\not=\src{\ctxtocomp}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Alloc\ \loc\ n} = \src{\comm},\specificev{\emptyevent}
    }{filter-alloc-irrelevant}
    %
    \typerule{filter-dealloc-irrelevant}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \src{\comm}\not=\src{\ctxtocomp}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Dealloc\ \loc} = \src{\comm},\specificev{\emptyevent}
    }{filter-dealloc-irrelevant}
    %
    \typerule{filter-get-irrelevant}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n} &
      \src{\comm}\not=\src{\ctxtocomp}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Get\ \loc\ n} = \src{\comm},\specificev{\emptyevent}
    }{filter-get-irrelevant}
    %
    \typerule{filter-set-irrelevant}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n} &
      \src{\comm}\not=\src{\ctxtocomp}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Set\ \loc\ n} = \src{\comm},\specificev{\emptyevent}
    }{filter-set-irrelevant}
    %
    %
    \typerule{filter-call-external}{
      \src{\comm}\not=\src{\nocomm}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm'}}]{Call\ \comm\ foo\ n} = \src{\comm},\specificev{\emptyevent}
    }{filter-call-external}
    %
    \typerule{filter-ret-external}{
      \src{\comm}\not=\src{\nocomm}
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm'}}]{Ret\ \comm\ foo\ n} = \src{\comm},\specificev{\emptyevent}
    }{filter-ret-external}
    %
    \typerule{filter-call-internal}{
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Call\ \nocomm\ foo\ n} = \src{\comm},\specificev{\emptyevent}
    }{filter-call-internal}
    %
    \typerule{filter-ret-internal}{
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{Ret\ \nocomm\ foo\ n} = \src{\comm},\specificev{\emptyevent}
    }{filter-ret-internal}
    %
    %
    \typerule{filter-abort}{
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\lightning} = \src{\comm}, \src{\lightning}
    }{filter-abort}
    \\
    %
    %
    \typerule{$\src{\mstrace}$-empty-$\theta$}{
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\hole{\cdot}}=\hole{\cdot}
    }{src-mstrace-empty-map}
    \typerule{$\src{\mstrace}$-cons-$\theta$}{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\msevent}=\src{\comm},\msevent[_0]&
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\mstrace}=\mstrace[_0]&
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\msevent\cdot\mstrace}=\msevent[_0]\cdot\mstrace[_0]
    }{src-cons-empty-map}
    %
    \typerule{$\src{\mstrace}$-cons-$\theta$-ignore}{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\msevent}=\src{\comm'},\specificev{\emptyevent}&
      \tospecificevs[_{\delta_{MS}}^{\src{\comm'}}]{\mstrace}=\mstrace[_0]&
    }{
      \tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\msevent\cdot\mstrace}=\mstrace[_0]
    }{src-cons-empty-map}
  \end{center}
}{w-events-project-to-specific}{Projection of $\mmlAs$ events to \gls*{ms}-specific events.}
\MK{update filter for contexts that pass pointers to the component}
We write just $\tospecificevs[_{\delta_{MS}}]{\bullet}$ for $\tospecificevs[_{\delta_{MS}}^{\nocomm}]{\bullet}$.

\subsubsection{\gls*{tms} Monitor}
In order to just talk about temporal memory safety, we introduce a monitor that works on more abstract monitor-actions, without any other events besides those relevant to temporal memory safety.

\myfig{
  \begin{gather*}
    \begin{aligned}
      \mi{Abstract\ Store}~\tmsmonitor =&\{A : \specificev{L}, F : \specificev{L}\} \\
      \mi{Abstract\ Events}~\absevent \bnfdef&\ \bm{\varepsilon} \mid \textbf{Alloc}\ \specificev{\loc} \mid \textbf{Dealloc}\ \specificev{\loc} \mid \textbf{Use}\ \specificev{\loc} \mid \abstermination\\[0.3cm]
      \tmsmonitor\subseteq_F \tmsmonitor['] &\text{ iff } \tmsmonitor[.F] \subseteq \tmsmonitor['.F]\\
      \absevent\in \tmsmonitor['] &\text{ iff } \absevent \in {\tmsmonitor['.A]} \wedge \absevent \notin {\tmsmonitor['.F]}\\
      \absevent\notin \tmsmonitor['] &\text{ iff } \absevent \notin {\tmsmonitor['.A]} \wedge \absevent \notin {\tmsmonitor['.F]}\\
      \{\specificev{\loc}\}\cup \tmsmonitor &= \{A : \{\specificev{\loc}\}\cup \tmsmonitor[.A], F : \tmsmonitor[.F]\}\\
      \tmsmonitor\setminus\{\specificev{\loc}\} &= \{A : \tmsmonitor[.A]\setminus\{\specificev{\loc}\}, F : \tmsmonitor[.F]\cup\left\{\specificev{\loc}\right\}\}\\
      \tmsmonitor\cup \tmsmonitor' &= \{A : \tmsmonitor[.A]\cup \tmsmonitor['.A], F : \tmsmonitor[.F]\cup \tmsmonitor['.F]\}\\
    \end{aligned}
  \end{gather*}
}{tms-monitor}{\gls{tms} Monitor.}

As before, when doing structural induction over primitive steps (\Cref{fig:w-expr-prim-eval}) we may encounter the $\src{\emptyevent}$, for which $\tospecificevs{\emptyevent}=\specificev{\emptyevent}$, which needs a ,,partner'' in the abstract events as defined in \Cref{fig:tms-monitor}: $\bm{\varepsilon}$.

\myfig{
  \begin{center}
    \judgbox{\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}}{,,Given abstract state $\tmsmonitor$, step to abstract state $\tmsmonitor'$\\ emitting an abstract event $\absevent$.''}
    \judgbox{\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\abstrace}}{,,Reflexive-Transitive closure of above judgement.\\$\abstrace$ is a list of abstract events.''}
    \typerule{TMS-Uninteresting}{
    }{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\bm{\varepsilon}}
    }{tms-uninteresting}
    %
    \typerule{TMS-Use}{
      \specificev{\loc}\in \tmsmonitor
    }{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\textbf{Use}\ \specificev{\loc}}
    }{tms-use}
    %
    \typerule{TMS-Alloc}{
      \tmsmonitor[']=\left\{\specificev{\loc}\right\}\cup\tmsmonitor&
      \specificev{\loc}\notin \tmsmonitor
    }{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Alloc}\ \specificev{\loc}}
    }{tms-alloc}
    %
    \typerule{TMS-Dealloc}{
      \specificev{\loc}\in \tmsmonitor &
      \tmsmonitor[']=\tmsmonitor\setminus\left\{\specificev{\loc}\right\}
    }{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}
    }{tms-dealloc}
    %
    \typerule{TMS-Refl}{
    }{
      \monitorcheck{\tmsmonitor}{\tmsmonitor}{\hole{\cdot}}
    }{tms-refl}
    %
    \typerule{TMS-Trans}{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}&
      \monitorcheck{\tmsmonitor[']}{\tmsmonitor['']}{\abstrace}&
    }{
      \monitorcheck{\tmsmonitor}{\tmsmonitor['']}{\absevent\cdot\abstrace}
    }{tms-trans}
  \end{center}
}{tms-step}{Steps of \gls{tms} Monitor.}

The monitor-state contains two sets of locations that represent the ones that are active and the ones that have been deallocated, respectively.
As seen in \Cref{tr:tms-dealloc}, the monitor only steps if the intuitive condition is true: a location can only be deallocated if it is part of the set of allocated locations.
\Cref{tr:tms-use} ensures that only allocated locations occur in events representing usage, the monitor cannot step if the location has been deallocated before.

As before, we need a way to translate one set of actions to another:

\myfig{
  \begin{center}
    \judgbox{\tmstraceagree{\msevent}{\absevent}}{,,Memory-Safety specific event $\msevent$ describes same action as $\absevent$.''}
    \judgbox{\tmstraceagree[^*]{\mstrace}{\abstrace}}{,,Memory-Safety specific trace $\mstrace$ describes same trace as $\abstrace$.''}
    %
    \typerule{TMS-Alloc-Authentic}{
    }{
      \tmstraceagree{\specificev{Alloc\ \loc\ n}}{\textbf{Alloc}\ \specificev{\loc}}
    }{tms-alloc-auth}
    %
    \typerule{TMS-Dealloc-Authentic}{
    }{
      \tmstraceagree{\specificev{Dealloc\ \loc}}{\textbf{Dealloc}\ \specificev{\loc}}
    }{tms-dealloc-auth}
    %
    \typerule{TMS-Use-Authentic}{
    }{
      \tmstraceagree{\specificev{Use\ \loc\ n}}{\textbf{Use}\ \specificev{\loc}}
    }{tms-use-auth}
    %
    \typerule{TMS-None-Authentic}{
    }{
      \tmstraceagree{\specificev{\varepsilon}}{\bm{\varepsilon}}
    }{tms-use-auth}
    %
    \typerule{TMS-Refl-Authentic}{
    }{
      \tmstraceagree[^*]{\hole{\cdot}}{\hole{\cdot}}
    }{tms-refl-auth}
    %
    \typerule{TMS-Trans-Authentic}{
      \tmstraceagree{\msevent}{\absevent} &
      \tmstraceagree[^*]{\mstrace}{\abstrace}
    }{
      \tmstraceagree[^*]{\msevent\cdot\mstrace}{\absevent\cdot\abstrace}
    }{tms-trans-auth}
  \end{center}
}{tms-trace-agreement}{Trace Agreement.}

\myfig{
  \begin{center}
    \judgbox{\delta_{MS}(\src{\loc})=\specificev{\loc}}{,,Map $\mmlAs$ locations $\src{\loc}$ to abstract locations $\specificev{\loc}$.''}
    \judgbox{\storeagreetms{\tmsmonitor}{\src{\Delta}}}{,,Abstract memory state $\tmsmonitor$ describes the concrete state $\src{\Delta}$.''}
    \typerule{Empty-Agree}{
    }{
      \storeagreetms{\emptyset}{\src{\hole{\cdot}}}
    }{store-empty-agree}
    %
    \typerule{Cons-Agree}{
      \delta_{MS}(\src{\loc})=\specificev{\loc}&
      \specificev{\loc}\notin\tmsmonitor&
      \storeagreetms{\tmsmonitor}{\src{\Delta}}
    }{
      \storeagreetms{\left\{\specificev{\loc}\right\}\cup \tmsmonitor}{\src{x\mapsto\loc_\poisonless,\Delta}}
    }{store-cons-agree}
    %
    \typerule{Poison-Agree}{
      \delta_{MS}(\src{\loc})=\specificev{\loc}&
      \storeagreetms{\tmsmonitor}{\src{\Delta}}
    }{
      \storeagreetms{\tmsmonitor}{\src{x\mapsto\loc_\poisoned,\Delta}}
    }{store-poison-agree}
  \end{center}
}{tms-store-agreement}{Store Agreement.}

\subsubsection{\gls*{sms} Monitor}

\myfig{
  \begin{gather*}
    \begin{aligned}
      \mi{Abstract\ Store}~\smsmonitor =&\ \specificev{L}\times\nat \\
      \mi{Abstract\ Events}~\absevent \bnfdef&\ \textbf{Alloc}\ \specificev{\loc}\ \bm{n} \mid \textbf{Dealloc}\ \specificev{\loc} \mid \textbf{Use}\ \specificev{\loc}\ \bm{n} \mid \abstermination\\
    \end{aligned}
  \end{gather*}
}{sms-monitor}{\gls{sms} Monitor.}

\myfig{
  \begin{center}
    \judgbox{\monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\absevent}}{,,Given abstract state $\smsmonitor$, step to abstract state $\smsmonitor'$\\ emitting an abstract event $\absevent$.''}
    \judgbox{\monitorcheck{\smsmonitor}{\smsmonitor[']}{\abstrace}}{,,Reflexive-Transitive closure of above judgement.\\$\abstrace$ is a list of abstract events.''}
    %
    \typerule{sms-Use}{
      (\specificev{\loc},m) \in \smsmonitor&
      n < m
    }{
      \monitorcheck[]{\smsmonitor}{\smsmonitor}{\textbf{Use}\ \loc\ \bm{n}}
    }{sms-use}
    %
    \typerule{sms-Alloc}{
      \specificev{\loc} \notin \text{dom }\smsmonitor&
      \smsmonitor[']=\smsmonitor \cup \left\{(\specificev{\loc},n)\right\}
    }{
      \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\textbf{Alloc}\ \specificev{\loc}\ \bm{n}}
    }{sms-alloc}
    %
    \typerule{sms-Dealloc}{
      (\specificev{\loc},m) \in \smsmonitor &
      \smsmonitor[']=\smsmonitor\setminus\left\{(\specificev{\loc},m)\right\}
    }{
      \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}
    }{sms-dealloc}
    %
    \typerule{sms-Refl}{
    }{
      \monitorcheck{\smsmonitor}{\smsmonitor}{\hole{\cdot}}
    }{sms-refl}
    %
    \typerule{sms-Trans}{
      \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\absevent}&
      \monitorcheck{\smsmonitor[']}{\smsmonitor['']}{\abstrace}
    }{
      \monitorcheck{\smsmonitor}{\smsmonitor['']}{\absevent\cdot\abstrace}
    }{sms-trans}
  \end{center}
}{sms-step}{Steps of \gls{sms} Monitor.}

\myfig{
  \begin{center}
    \judgbox{\smstraceagree{\msevent}{\absevent}}{,,Memory-Safety specific event $\msevent$ describes same action as $\absevent$.''}
    \judgbox{\smstraceagree{\mstrace}{\abstrace}}{,,Memory-Safety specific trace $\mstrace$ describes same trace as $\abstrace$.''}
    %
    \typerule{SMS-Alloc-Authentic}{
    }{
      \smstraceagree{\specificev{Alloc\ \loc\ n}}{\textbf{Alloc}\ \specificev{\loc}\ \bm{n}}
    }{sms-alloc-auth}
    %
    \typerule{SMS-Dealloc-Authentic}{
    }{
      \smstraceagree{\specificev{Dealloc\ \loc}}{\textbf{Dealloc}\ \specificev{\loc}}
    }{sms-dealloc-auth}
    %
    \typerule{SMS-Use-Authentic}{
    }{
      \smstraceagree{\specificev{Use\ \loc\ n}}{\textbf{Use}\ \specificev{\loc}\ \bm{n}}
    }{sms-use-auth}
    %
    \typerule{SMS-Refl-Authentic}{
    }{
      \smstraceagree{\hole{\cdot}}{\hole{\cdot}}
    }{sms-refl-auth}
    %
    \typerule{SMS-Trans-Authentic}{
      \smstraceagree{\msevent}{\absevent} &
      \smstraceagree{\mstrace}{\abstrace}
    }{
      \smstraceagree{\msevent \cdot \mstrace}{\absevent \cdot \abstrace}
    }{sms-trans-auth}
  \end{center}
}{sms-trace-agreement}{Trace Agreement.}


\myfig{
  \begin{center}
    \typerule{abstract-agree-dealloc}{
    }{
    \textbf{Dealloc}\ \specificev{\loc} \prec \textbf{Dealloc}\ \specificev{\loc}
    }{aagree-dealloc}
    %
    \typerule{abstract-agree-alloc}{
    }{
    \textbf{Alloc}\ \specificev{\loc}\ \bm{n} \prec \textbf{Alloc}\ \specificev{\loc}
    }{aagree-alloc}
    %
    \typerule{abstract-agree-use}{
    }{
    \textbf{Use}\ \specificev{\loc}\ \bm{n} \prec \textbf{Use}\ \specificev{\loc}
    }{use-dealloc}
    %
    \typerule{tms-sms-E}{
      \monitorcheck[]{\smsmonitor}{\smsmonitor}{\absevent} &
      \absevent\prec \absevent['] &
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\absevent[']} &
    T = \tmsmonitor\times\smsmonitor
    }{
      \monitorcheck[]{T}{T}{\absevent}
    }{tms-sms-empty}
    %
    \typerule{tms-sms-Refl}{
    }{
      \monitorcheck{T}{T}{\hole{\cdot}}
    }{tms-sms-refl}
    %
    \typerule{tms-sms-Trans}{
      \monitorcheck[]{T}{T'}{\absevent}&
      \monitorcheck{T'}{T''}{\abstrace}&
    }{
      \monitorcheck{T}{T''}{\absevent\cdot\abstrace}
    }{tms-sms-trans}
  \end{center}
}{tms-sms-step}{Steps of combined \gls{tms} + \gls{sms} Monitor.}


We now define temporal and spatial memory safety in terms of $\mstrace$ traces.

\begin{definition}[Once]
  Given an event $\msevent$ and a trace $\mstrace$, we say $\msevent$ appears exactly once in the trace, written $\msevent\in_{!}\mstrace$, iff

  If $n\in\nat$ such that $\trace{[n]}=\msevent$, then for any $m\in\nat$ such that $\trace{[m]}=\msevent$ we have $n = m$.
\end{definition}

\begin{definition}[Before]
  Given two events $\msevent[_0],\msevent[_1]$ and a trace $\mstrace$, event $\msevent[_0]$ occurs before $\msevent[_1]$ in $\mstrace$, written
  $\event{_0}\le_{\trace}\event{_1}$, iff

  If $n\in\nat$ such that $\mstrace{[n]} = \msevent[_{0}]$, then $\exists m\in\nat, \mstrace{[m]} = \msevent[_1] \wedge n< m$
\end{definition}

\begin{definition}[\gls{tms} on Traces]\label{def:tempmemsafe}
  We define the property $tmsafe(\mstrace)$ as a conjunction of the following conditions:
  \begin{itemize}
    \item $\specificev{Alloc\ \loc\ s}\le_{{\mstrace}}\specificev{Dealloc\ \loc}$
    \item $\neg(\specificev{Use\ \loc\ n}\le_{{\mstrace}}\specificev{Alloc\ \loc\ s})$
    \item $\neg(\specificev{Dealloc\ \loc}\le_{{\mstrace}}\specificev{Use\ \loc\ n})$
    \item $\specificev{Alloc\ \loc\ s}\in_{!}\mstrace$
    \item $\specificev{Dealloc\ \loc}\in_{!}\mstrace$
  \end{itemize}
\end{definition}

\begin{definition}[Spatial Memory Safety]\label{def:spatmemsafe}
  We define the property ${smsafe}\left({\mstrace}\right)$ as follows:
  \begin{itemize}
    \item If $\specificev{Alloc\ \loc\ s}\in{\mstrace}$ and $\specificev{Use\ \loc\ n}\in{\mstrace}$, then ${n}<{s}$
  \end{itemize}
\end{definition}

\begin{definition}[Trace is temporal memory safe via monitor.]\label{def:src:trace:tms}
  We say $\texttt{TMS}(\mstrace)$ iff $\exists \delta_{\text{tms}}\ \abstrace\ \tmsmonitor$ such that:
  \begin{itemize}
    \item $\tmstraceagree{\mstrace}{\abstrace}$
    \item and $\monitorcheck{\emptyset}{\tmsmonitor}{\abstrace}$
  \end{itemize}
\end{definition}

\begin{scontents}[store-env=buffer]
  If
  \begin{assumptions}
  \item\label[ass]{asm:mmlatmsviamonitor:run} $\wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{v}{\trace}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\texttt{TMS}(\tospecificevs[_{\emptyset}]{\trace})$
  \end{goals}.
\end{scontents}
\mockthm{thm:mmlAs:tmssafe}{1}

\begin{scontents}[store-env=buffer]
  There is a well-typed $\mmlAs$ component that does not robustly satisfy \Cref{def:spatmemsafe}:
  $\rsat{\src{\library}}{smsafe}$
\end{scontents}

\realthm{thm:mmlAs:not:smssafe}{2}{$\mmlAs$ is not spatially memory safe}
\begin{proof}
  We pick:
  $$\src{\library_{comp}} = \src{let\ foo\ x:\nat\to\nat:=let\ z=new\ x\ in\ let\ w = z[1337]\ in\ let\ \_ = delete\ z\ in\ w},\src{\hole{\cdot}}$$
  and
  $
  \src{\library_{ctx}} = \src{let\ main\ z:\nat\to\nat:=call\ foo\ 42},\src{\hole{\cdot}}
  $.
  Let $\src{\library} \equiv \src{\library_{comp}}\cup\src{\library_{ctx}}$.
  We show $\vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv\src{\library},\left\{\src{foo}\right\}$.
  First note that $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$, since $\operatorname{dom}\ \src{\library_{ctx}}\cap\operatorname{dom\ \src{\library_{comp}}}=\emptyset$ and $\src{\library}\equiv\src{\library_{ctx}\cup\library_{comp}}$ by definition.
  Now, $\operatorname{dom}\ \src{\library_{comp}}=\left\{\src{foo}\right\}$ and $\src{\library}\downarrow=\src{foo\mapsto\nat\to\nat,main\mapsto\nat\to\nat,\hole{\cdot}}=\src{\Gamma_{0}}$ by \Cref{tr:w-lib-proj-empty,tr:w-lib-proj-cons}.
  Consequently, $\src{main}\in\operatorname{dom}\src{\Gamma_{0}}=\left\{\src{foo},\src{main}\right\}$.
  Note that \Cref{tr:src-int-type-nat} gives $\src{\nat}\ \operatorname{int}$.
  Using \Cref{tr:w-t-lib-empty,tr:w-t-lib-cons}, what is left to show are the following:
  \begin{enumerate}
    \item $\typechecks{x:\nat,\Gamma_{0}}{let\ z=new\ x\ in\ let\ w = z[1337]\ in\ delete\ z; w}{\nat}$
    \item $\typechecks{z:\nat,\Gamma_{0}}{call\ foo\ 42}{\nat}$
  \end{enumerate}

  Let $\src{e_w}=\src{let\ w=z[1337]\ in\ delete\ z; w}$, $\Gammas=\src{z:\ptr,x:\nat,\hole{\cdot}}$, and $\src{\Gamma'}=\src{z:\wptr,x:\nat,\hole{\cdot}}$ due to space constraints.

  \bigskip
  \noindent\makebox[\textwidth]{%
    \typerulederiv{$\text{\Cref{tr:w-t-new}}$}{
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{x:\nat,\hole{\cdot}}{x}{\nat}
      } &
      \typerulederiv{$\text{\Cref{tr:t-let}}$}{
        \typechecks{\Gamma'}{z[1337]}{\nat} &
        \typechecks{w:\nat,\Gamma}{delete\ z;w}{\nat}
      }{
        \typechecks{\Gamma'\circ\Gamma}{e_w}{\nat}
      }
    }{
      \typechecks{x:\nat,\hole{\cdot}\circ x:\nat,\hole{\cdot}}{let\ z=new\ x\ in\ let\ w = z[1337]\ in\ delete\ z; w}{\nat}
    }}
  \bigskip

  Observe that:

  \bigskip
  \noindent\makebox[\textwidth]{%
    \typerulederiv{$\text{\Cref{tr:t-get}}$}{
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{
        \src{\wptr}\not=\src{\ptr}&
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{\Gamma'}{z}{\wptr}
      } &
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{
        \src{\wptr}\not=\src{\ptr}&
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{\Gamma'}{x}{\nat}
      }
    }{
      \typechecks{\Gamma'\circ\Gamma'}{z[1337]}{\nat}
  }}
  \bigskip

  And:

  \bigskip
  \noindent\makebox[\textwidth]{%
    \typerulederiv{$\text{\Cref{tr:t-let}}$}{
      \typerulederiv{$\text{\Cref{tr:w-t-delete}}$}{
        \src{\nat}\not=\src{\ptr} &
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{w:\nat,z:\ptr,x:\nat,\hole{\cdot}}{delete\ z}{\nat}
      }&
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{
        \src{\nat}\not=\src{\ptr} &
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{w:\nat,x:\nat,\hole{\cdot}}{w}{\nat}
      }
    }{
      \typechecks{w:\nat,z:\ptr,x:\nat,\hole{\cdot}\circ w:\nat,x:\nat,\hole{\cdot}}{delete\ z;w}{\nat}
    }}
  \bigskip

  Thus, it typechecks.\\[0.3cm]
  Now consider the other case:

  \bigskip
  \noindent\makebox[\textwidth]{%
    \typerulederiv{$\text{\Cref{tr:t-call}}$}{
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{}{\typechecks{z:\nat,\Gamma_0}{foo}{\nat}}&
      \typerulederiv{$\text{\Cref{tr:t-nat}}$}{}{\typechecks{z:\nat,\Gamma_0}{42}{\nat}}&
      \typerulederiv{$\text{\Cref{tr:src-int-type-nat}}$}{}{\src{\nat}\ \operatorname{int}}
    }{
      \typecheck{\src{z:\nat,\Gamma_0}}{\src{call\ foo\ 42}}{\src{\nat}}
    }}
  \bigskip

  Note that $\src{NoOwnedPtr\ z:\nat,\Gamma_{0}}$ holds by $\src{\nat}\not=\src{\ptr}$ and $\src{\nat\to\nat}\not=\src{\ptr}$

  Running the whole program via \Cref{tr:ws-e-prog} yields trace prefix\\$\src{\trace}=\src{Call\ ?main\ 0}\cdot\src{Call\ !foo\ 42}\cdot\src{Alloc\ \loc\ 42}\cdot\src{Get\ \loc\ 1337}\cdot\src{Dealloc\ \loc}\cdot\src{Ret\ ?1729}\cdot\src{Call\ !1729}$.
  We omit the precise derivation for brevity, but note that \thmref{lem:toplevel:progress} gives us the necessary execution.\\[0.3cm]
  By \Cref{fig:w-events-project-to-specific}, $\tospecificevs{\trace}=\specificev{Alloc\ \loc\ 42}\cdot\specificev{Use\ \loc\ 1337}\cdot\specificev{Dealloc\ \loc}$.\\[0.3cm]
  \Cref{def:spatmemsafe} requires $\specificev{Alloc\ \loc\ 42}\in\tospecificevs{\trace}$ and $\specificev{Use\ \loc\ 1337}\in\tospecificevs{\trace}$, which hold.\\[0.3cm]
  But, ${1337}\not<{42}$, hence $\nrsat{\src{\library_{comp}}}{{smsafe}}$.
\end{proof}

\subsubsection{Auxiliary Definitions and Lemmas}\label{sec:mmla:aux}

\begin{lemma}[Typing Decomposition]\label{lem:ctxtyping:plugged}
  If
  \begin{assumptions}
    \item $\typechecks{\Gamma}{K[e]}{\type}$
  \end{assumptions}
  Then $\exists \src{\type_{e}}$,
  \begin{goals}
    \item $\typechecks{\Gamma}{K}{\type_{e}\to\type}$
    \item $\typechecks{\Gamma}{e}{\type_{e}}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Store Agree Weaken]\label{lem:store-agree-weaken}
  If
  \begin{assumptions}
    \item $\storeagreetms{\tmsmonitor}{\src{\Delta}}$
    \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor}{\src{\Delta}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Induction on $\storeagreetms{\tmsmonitor}{\src{\Delta}}$.
\end{proof}

\begin{lemma}[Trace-based Transitivity Authentic]\label{lem:trace-agree-trans}
  If
  \begin{assumptions}
    \item $\tmstraceagree[^{*}]{\mstrace[_{1}]}{\abstrace_{1}}$
    \item $\tmstraceagree[^{*}]{\mstrace[_{2}]}{\abstrace_{2}}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmstraceagree[^{*}]{\mstrace[_{1}]\cdot\mstrace[_{2}]}{\abstrace_{1}\cdot\abstrace_{2}}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Monitor Step Subset]\label{lem:monitor-step-subset}
  If
  \begin{assumptions}
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmsmonitor\subseteq_F \tmsmonitor[']$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy induction on $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$.
\end{proof}

\begin{lemma}[Monitor Steps Subset]\label{lem:monitor-steps-subset}
  If
  \begin{assumptions}
    \item $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmsmonitor\subseteq_F \tmsmonitor[']$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy induction on $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\absevent}$ using \Thmref{lem:monitor-step-subset}.
\end{proof}

\begin{lemma}[$\alpha$-conv. Typing]\label{lem:alpha-conv-typing}
  If
  \begin{assumptions}
    \item $\typechecks{\Gamma}{e}{\type}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{\Gamma[z:\type'/x:\type]}{e[z/x]}{\type}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Substitution]\label{lem:substitution}
  If
  \begin{assumptions}
    \item $\typechecks{x:\type',\Gamma_1}{e}{\type}$
    \item $\typechecks{\Gamma_2}{v}{\type'}$
    \item $\src{\Gamma_3}=\src{\Gamma_1}\circ\src{\Gamma_2}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{\Gamma_3}{e[v/x]}{\type}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Base Preservation]\label{lem:base-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item $\exprevals{\configs}{e}{\configs'}{e'}{\event}$
    \item $\configs'\not=\src{\lightning}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\type}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Ctx Preservation]\label{lem:ctx-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item $\execs[]{\configs}{e}{\configs'}{e'}{\event}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\type}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Steps Preservation]\label{lem:steps-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item $\execs{\configs}{e}{\configs'}{e'}{\trace}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\type}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Progress]\label{lem:progress}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\src{e}=\src{\finalexprnoerr}$ or $\exists \src{\Omega'}\ \src{\finalexprnoerr}\ \src{\trace}, \execs{\configs}{e}{\configs'}{\finalexprnoerr}{\trace}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{scontents}[store-env=buffer]
  If
  \begin{assumptions}
  \item $\typechecks{}{e}{\type}$
  \end{assumptions}
  Then $\exists \src{\Omega}\ \src{\trace}\ \src{\finalexprnoerr}$,
  \begin{goals}
  \item $\execs{\hole{\cdot};\hole{\cdot}}{e}{\Omega}{\finalexprnoerr}{\trace}$
  \item $\typechecks{}{\finalexprnoerr}{\type}$
  \end{goals}.
\end{scontents}
\realthm{thm:mmlAs:typesafe}{3}{Type Safety}

\begin{lemma}[Top-Level Progress]\label{lem:toplevel:progress}
  If
  \begin{assumptions}
    \item $\vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv\src{\library},\src{\commlib}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\exists \configs\ \src{\finalexprnoerr}\ \src{\trace}, \wexecs{prog\ \library_{ctx}\ \library_{comp}}{\Omega}{\finalexprnoerr}{\trace}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Base \gls{tms} via Monitor]\label{lem:basetmsmonitor}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item $\exprevals{\configs}{e}{\configs'}{e'}{\event}$
    \item $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
  \begin{goals}
    \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
    \item $\tmstraceagree{\tospecificevs[_{\delta_{\text{MS}}'}]{\event}}{\absevent}$
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
    \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{proof}
  First, we note
  \begin{itemize}
    \item $\src{\Omega}=\src{\cfstate;\memstate}$
    \item $\src{\cfstate}=\src{\commlib;\library;\kontstack}$
    \item $\src{\memstate}=\src{H;\Delta}$
  \end{itemize}
  Induction on $\exprevals{\configs}{e}{\configs'}{e'}{\event}$.
  \begin{description}
    \item[$\src{e}=\src{delete\ x}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}\triangleright \src{delete\ x}}{\type}$
        \item\label[ass]{asm:basetmsmonitor:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item\label[goal]{goal:basetmsmonitor:subseteq} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item\label[goal]{goal:basetmsmonitor:tmstraceagree} $\traceagree{\specificev{Dealloc\ }\delta_{\text{MS}}'(\src{\loc})}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}$
      \end{goals}

      We conclude $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$ by inverting \Cref{asm:basetmsmonitor:storeagree}.\MK{technical lemma instead of inversion}
      Choose $\absevent=\textbf{Dealloc\ }\specificev{\loc}$ and $\delta_{\text{MS}}'=\delta_{\text{MS}}$.

      \Cref{goal:basetmsmonitor:subseteq}, $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}$, follows trivially.

        For $\tmstraceagree{\specificev{Dealloc\ }\delta_{\text{MS}}'(\src{\loc})}{\textbf{Dealloc}\ \specificev{\loc}}$ (\Cref{goal:basetmsmonitor:tmstraceagree}), apply \Cref{tr:tms-dealloc-auth}.

      The inversion yields two cases:
      \begin{description}
      \item[\Cref{tr:store-cons-agree}:] \ \\
        If
        \begin{passumptions}{F}
        \item $\typechecks{}{\src{\cfstate;H;\Delta_1},\src{x\mapsto\loc_\poisonless},\src{\Delta_2}\triangleright \src{delete\ x}}{\type}$
        \item $\storeagreetms{\tmsmonitor[_1]}{\src{\Delta_1}}$
        \item $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$
        \item $\storeagreetms{\tmsmonitor[_2]}{\src{\Delta_2}}$
        \item $\tmsmonitor=\tmsmonitor[_1]\cup\left\{\specificev{\loc}\right\}\cup \tmsmonitor[_2]$
        \end{passumptions}
        then $\exists \tmsmonitor[']$,
        \begin{goals}
        \item\label[goal]{goal:basetmsmonitor:monitorcheck1} $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}$
        \item\label[goal]{goal:basetmsmonitor:storeagree1} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}$
        \end{goals}
        Choose $\tmsmonitor[']=\tmsmonitor[_1]\cup \tmsmonitor[_2]$.

        \Cref{goal:basetmsmonitor:monitorcheck1}, $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}$, follows immediately by \Cref{tr:tms-dealloc}.

        \Cref{goal:basetmsmonitor:storeagree1}, $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}$, follows immediately by \Cref{tr:store-poison-agree}.

      \item[\Cref{tr:store-poison-agree}:] \ \\
        If
        \begin{passumptions}{F}
        \item\label[ass]{asm:basetmsmonitor:typing} $\typechecks{}{\src{\cfstate;H;\Delta_1},\src{x\mapsto\loc_\poisoned},\src{\Delta_2}\triangleright \src{delete\ x}}{\type}$
        \item $\storeagreetms{\tmsmonitor[_1]}{\src{\Delta_1}}$
        \item $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$
        \item $\storeagreetms{\tmsmonitor[_2]}{\src{\Delta_2}}$
        \item $\tmsmonitor=\tmsmonitor[_1]\cup \tmsmonitor[_2]$
        \end{passumptions}
        then $\exists \tmsmonitor[']$,
        \begin{goals}
        \item\label[goal]{goal:basetmsmonitor:monitorcheck2} $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}$
        \item\label[goal]{goal:basetmsmonitor:storeagree2} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}$
        \end{goals}.

        Invert \Cref{asm:basetmsmonitor:typing} to get
        \begin{passumptions}{F}
          \setcounter{enumi}{6}
          \item\label[ass]{asm:basetmsmonitor:storechecks} $\typechecks{\library}{\src{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}{\Gammas}$
          \item\label[ass]{asm:basetmsmonitor:freechecks} $\typechecks{\Gammas}{delete\ x}{\nat}$
        \end{passumptions}

      Due to \Cref{asm:basetmsmonitor:storechecks}, we know $\src{x:\ptr}\not\in\Gammas$.

      But, that contradicts \Cref{asm:basetmsmonitor:freechecks}.
      \end{description}

    \item[$\src{e}=\src{n_1+n_2}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}\triangleright\src{n_1+n_2}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{\varepsilon}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega}}$
      \end{goals}
      Choose $\absevent=\bm{\varepsilon}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.

      All goals are completely trivial.

    \item[$\src{e}=\src{let\ x=\finalexprnoerr\ in\ e'}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}\triangleright\src{let\ x=\finalexprnoerr\ in\ e'}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{\varepsilon}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega}}$
      \end{goals}
      Choose $\absevent=\bm{\varepsilon}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.

      All goals are completely trivial.

    \item[$\src{e}=\src{ifz\ 0\ then\ e_1\ else\ e_2}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}\triangleright\src{ifz\ 0\ then\ e_1\ else\ e_2}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{\varepsilon}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega}}$
      \end{goals}
      Choose $\absevent=\bm{\emptyevent}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.

      All goals are completely trivial.

    \item[$\src{e}=\src{ifz\ S(n)\ then\ e_1\ else\ e_2}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}\triangleright\src{ifz\ S(n)\ then\ e_1\ else\ e_2}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree[]{\specificev{\varepsilon}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega}}$
      \end{goals}
      Choose $\absevent=\bm{\emptyevent}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.

      All goals are completely trivial.

    \item[$\src{e}=\src{let\ x=new\ n\ in\ e'}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}}{\type}$
        \item\label[ass]{asm:basetmsmonitor:case4:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
        \item $\fresh{\src{\Delta}}{\src{\loc}}$
        \item $\fresh{\src{\Delta}}{\src{z}}$
        \item $\src{H'}=\src{H}\ll\src{n}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{Alloc\ }\delta_{\text{MS}}'(\loc)\specificev{\ n}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{z\mapsto\loc_{\poisonless},\Delta}}$
      \end{goals}
      Let $\specificev{\loc}$ be such that $\fresh{\operatorname{dom} \delta_{\text{MS}}}{\specificev{\loc}}$.
      Choose $\absevent=\bm{Alloc\ }\specificev{\loc}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}\cup\left\{\src{\loc}\mapsto\specificev{\loc}\right\}$, and $\tmsmonitor[']=\left\{\specificev{\loc}\right\}\cup\tmsmonitor$.
      The goals become:
      \begin{goals}
        \item\label[goal]{goal:basetmsmonitor:case4:subseteq} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}\cup\left\{\src{\loc}\mapsto\specificev{\loc}\right\}$
        \item\label[goal]{goal:basetmsmonitor:case4:tmstraceagree} $\traceagree{\specificev{Alloc\ \loc\ n}}{\bm{Alloc\ }\specificev{\loc}}$
        \item\label[goal]{goal:basetmsmonitor:case4:monitorstep} $\monitorcheck[]{\tmsmonitor}{\left\{A:\tmsmonitor.A\cup\left\{\specificev{\loc}\right\},F:\tmsmonitor.F\right\}}{\bm{Alloc\ }\specificev{\loc}}$
        \item\label[goal]{goal:basetmsmonitor:case4:storeagree} $\storeagreetms[\delta_{MS}\cup\left\{\src{\loc}\mapsto\specificev{\loc}\right\}]{\left\{\specificev{\loc}\right\}\cup\tmsmonitor}{\src{z\mapsto\loc_{\poisonless},\Delta}}$
      \end{goals}

      \Cref{goal:basetmsmonitor:case4:subseteq} is trivial.

      \Cref{goal:basetmsmonitor:case4:tmstraceagree} follows immediately by \Cref{tr:tms-alloc-auth}.

      \Cref{goal:basetmsmonitor:case4:monitorstep} follows by \Cref{tr:tms-alloc}.

      \Cref{goal:basetmsmonitor:case4:storeagree} follows by \Cref{tr:store-cons-agree}.

    \item[$\src{e}=\src{x[n]}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\cfstate};\src{H};\src{\Delta_1,x\mapsto\loc_\poison,\Delta_2}\triangleright\src{x[n]}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}$
        \item $\src{\loc}\in\operatorname{dom}\src{H}\implies \src{v}=\src{H}\left(\src{\loc+n}\right)$
        \item $\src{\loc}\not\in\operatorname{dom}\src{H}\implies \src{v}=\src{1729}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree[\delta_{\text{MS}}']{\specificev{Use\ }\delta_{\text{MS}}'(\loc)\specificev{\ n}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_{\poison},\Delta_2}}$
      \end{goals}
      We conclude $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$ by inverting \Cref{asm:basetmsmonitor:storeagree}.\MK{technical lemma instead of inversion}
      Choose $\absevent=\bm{Use\ }\specificev{\loc}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.
      The goals become:
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}$
        \item $\traceagree{\specificev{Use\ \loc\ n}}{\bm{Use\ }\specificev{\loc}}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\bm{Use\ }\specificev{\loc}}$
        \item $\storeagreetms[\delta_{\text{MS}}]{\tmsmonitor}{\src{\Delta_1,x\mapsto\loc_{\poison},\Delta_2}}$
      \end{goals}
      All goals follow easy.

    \item[$\src{e}=\src{x[n]\leftarrow\valueexpr}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\cfstate};\src{H};\src{\Delta_1,x\mapsto\loc_\poison,\Delta_2}\triangleright\src{x[n]}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Delta_1,x\mapsto\loc_\poison,\Delta_2}}$
        \item $\src{H'}=\src{H}\left(\src{\loc+n}\mapsto\src{\valueexpr}\right)$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{Use\ \loc\ n}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto\loc_{\poison},\Delta_2}}$
      \end{goals}
      We conclude $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$ by inverting \Cref{asm:basetmsmonitor:storeagree}.\MK{technical lemma instead of inversion}
      Choose $\absevent=\bm{Use\ }\specificev{\loc}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.
      The goals become:
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}$
        \item $\traceagree[\delta_{\text{MS}}']{\specificev{Use\ \loc\ n}}{\bm{Use\ }\specificev{\loc}}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\bm{Use\ }\specificev{\loc}}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor}{\src{\Delta_1,x\mapsto\loc_{\poison},\Delta_2}}$
      \end{goals}
      All goals follow easy.
  \end{description}
\end{proof}

\begin{lemma}[Ctx \gls{tms} via Monitor]\label{lem:ctxsteptmsmonitor}
  If
  \begin{assumptions}
    \item\label[ass]{asm:ctxtmsmonitor:typechecks} $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item\label[ass]{asm:ctxtmsmonitor:ctxstep} $\execs[]{\configs}{e}{\configs'}{e'}{\event}$
    \item\label[ass]{asm:ctxtmsmonitor:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
  \begin{goals}
    \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
    \item $\tmstraceagree{\tospecificevs[_{\delta_{\text{MS}}'}]{\event}}{\absevent}$
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
    \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
% Induction on \Cref{asm:ctxtmsmonitor:ctxstep}.
% \begin{passumptions}{H}
%   \item $\src{\Omega}\not=\src{\lightning}$
%   \item $\src{e_0}=\src{K}[\src{e}]$
%   \item $\src{e_0'}=\src{K}[\src{e'}]$
%   \item\label[ass]{asm:ctxtmsmonitor:step} $\exprevals{\Omega}{e_0}{\Omega'}{e_0'}{a}$
% \end{passumptions}

% Use \Cref{asm:ctxtmsmonitor:step} and \Cref{asm:ctxtmsmonitor:typechecks,asm:ctxtmsmonitor:storeagree} for \Thmref{lem:basetmsmonitor}:
% \begin{passumptions}{F}
%   \item $\delta_{\text{tms}}\subseteq\delta_{\text{tms}}'$
%   \item $\tmstraceagree[\delta']{\tospecificevs{\event}}{\absevent}$
%   \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
%   \item $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
% \end{passumptions}
% These premises solve our goal immediately.
\end{incompleteproof}

\begin{lemma}[Steps \gls{tms} via Monitor]\label{lem:generaltms:monitor}
  If
  \begin{assumptions}
    \item\label[ass]{asm:stepstmsmonitor:typing} $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item\label[ass]{asm:stepstmsmonitor:exec} $\execs{\configs}{e}{\configs'}{e'}{\trace}$
    \item\label[ass]{asm:stepstmsmonitor:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists \abstrace\ \delta_{\text{MS}}'\ \tmsmonitor['],$
  \begin{goals}
    \item\label[goal]{goal:stepstmsmonitor:delta} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
    \item\label[goal]{goal:stepstmsmonitor:traceagree} $\tmstraceagree[^{*}]{\tospecificevs[_{\delta_{\text{MS}}'}]{\trace}}{\abstrace}$
    \item\label[goal]{goal:stepstmsmonitor:monitorstep} $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\abstrace}$
    \item\label[goal]{goal:stepstmsmonitor:storeagree} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{proof}
  Induction on \Cref{asm:stepstmsmonitor:exec}.
  \begin{description}
    \item[$\src{\configs'}=\configs$, $\src{e'}=\src{e}$, and $\src{\trace}=\src{\hole{\cdot}}$:]
          This case is easy, since nothing did change.
          Instantiate $\abstrace=\hole{\cdot}$, $\delta_{\text{MS}}'=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.
          Then, \Cref{goal:stepstmsmonitor:delta,goal:stepstmsmonitor:traceagree,goal:stepstmsmonitor:monitorstep} follow immediately by reflexivity and \Cref{goal:stepstmsmonitor:storeagree} by \Cref{asm:stepstmsmonitor:storeagree}.

    \item[Induction step:]
          The inductive hypothesis is as follows.
          If
          \begin{passumptions}{A}
            \item $\typechecks{}{\src{\Omega_{\IH}}\triangleright e_{\IH}}{\src{\type}}$
            \item $\storeagreetms[\delta^{0}_{\text{MS}}]{\tmsmonitor[_{\IH}]}{\src{\Omega_{\IH}}.\src{\Delta}}$
          \end{passumptions}
          then $\exists \abstrace_{\IH}\ \delta_{\text{MS}}^{\IH}\ \tmsmonitor[_{\IH}'],$
          \begin{passumptions}{\IH}
            \item $\delta_{\text{MS}}^{0}\subseteq\delta_{\text{MS}}^{\IH}$
            \item $\tmstraceagree{\tospecificevs[_{\delta^{\IH}_{\text{MS}}}]{\trace}}{\abstrace_{\IH}}$
            \item $\monitorcheck{\tmsmonitor_{\IH}}{\tmsmonitor[_{\IH}']}{\abstrace_{\IH}}$
            \item $\storeagreetms[\delta^{\IH}_{\text{MS}}]{\tmsmonitor[_{\IH}']}{\src{\Omega'}.\src{\Delta}}$
          \end{passumptions}
          Note that above, anything not bound by $\exists$ is universally quantified, besides $\src{\type}$ and $\src{\Omega'}$.
          While our remaining context (excluding the inductive hypothesis) is:
          If
          \begin{passumptions}{H}
            \item\label[ass]{asm:stepstmsmonitor:case0:step} $\execs[]{\configs}{e}{\configs_{0}}{e_{0}}{\event[_0]}$
            \item\label[ass]{asm:stepstmsmonitor:case0:steps} $\execs{\configs_{0}}{e_{0}}{\configs'}{e'}{\trace}$
            \item\label[ass]{asm:stepstmsmonitor:case0:checks} $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
            \item\label[ass]{asm:stepstmsmonitor:case0:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
          \end{passumptions}
          Then $\exists \abstrace\ \delta_{\text{MS}}'\ \tmsmonitor['],$
          \begin{goals}
            \item\label[goal]{goal:stepstmsmonitor:final:delta} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
            \item\label[goal]{goal:stepstmsmonitor:final:traceagree} $\tmstraceagree{\tospecificevs[_{\delta_{\text{MS}}'}]{\event[_{0}]\cdot\trace}}{\abstrace}$
            \item\label[goal]{goal:stepstmsmonitor:final:monitorstep} $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\abstrace}$
            \item\label[goal]{goal:stepstmsmonitor:final:storeagree} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
          \end{goals}
          Use \Thmref{lem:ctxsteptmsmonitor} with \Cref{asm:stepstmsmonitor:case0:step,asm:stepstmsmonitor:case0:checks,asm:stepstmsmonitor:case0:storeagree}, obtaining:
          \begin{passumptions}{F}
            \item\label[ass]{asm:stepstmsmonitor:deltasubset0} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}^{0}$
            \item\label[ass]{asm:stepstmsmonitor:traceagree0} $\tmstraceagree{\tospecificevs[_{\delta^{0}_{\text{MS}}}]{\event[_{0}]}}{\absevent_{0}}$
            \item\label[ass]{asm:stepstmsmonitor:monitorcheck0} $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[_{0}]}{\absevent_{0}}$
            \item\label[ass]{asm:stepstmsmonitor:case0:storeagree1} $\storeagreetms[\delta^{0}_{\text{MS}}]{\tmsmonitor[_{0}]}{\src{\Omega_{0}}.\src{\Delta}}$
          \end{passumptions}
          Discharge the inductive hypothesis with \Cref{asm:stepstmsmonitor:case0:storeagree1} and the result of applying \Thmref{lem:ctx-preservation} using \Cref{asm:stepstmsmonitor:case0:step,asm:stepstmsmonitor:case0:checks}:
          \begin{passumptions}{G}
            \item\label[ass]{asm:stepstmsmonitor:deltasubset1} $\delta_{\text{MS}}^{0}\subseteq\delta_{\text{MS}}^{\IH}$
            \item\label[ass]{asm:stepstmsmonitor:traceagree1} $\tmstraceagree{\tospecificevs[_{\delta^{\IH}_{\text{MS}}}]{\trace}}{\abstrace_{\IH}}$
            \item\label[ass]{asm:stepstmsmonitor:monitorcheck1} $\monitorcheck{\tmsmonitor_{0}}{\tmsmonitor[^{\IH}]}{\abstrace_{\IH}}$
            \item\label[ass]{asm:stepstmsmonitor:case0:storeagree2} $\storeagreetms[\delta^{\IH}]{\tmsmonitor[_{\IH}]}{\src{\Omega'}.\src{\Delta}}$
          \end{passumptions}

          We solve our goals by instantiating $\abstrace=\absevent\cdot\abstrace_{\IH}$, $\delta_{\text{MS}}'=\delta_{\text{MS}}^{\IH}$, and $\tmsmonitor[']=\tmsmonitor[_{\IH}]$.
          \Cref{goal:stepstmsmonitor:final:delta} follows by transitivity using \Cref{asm:stepstmsmonitor:deltasubset0,asm:stepstmsmonitor:deltasubset1}.

          Similarily for \Cref{goal:stepstmsmonitor:final:traceagree} using \Cref{asm:stepstmsmonitor:traceagree0,asm:stepstmsmonitor:traceagree1}.\MK{$\theta$ subsets lemma}

          \Cref{goal:stepstmsmonitor:final:monitorstep} also by transitivity using \Cref{asm:stepstmsmonitor:monitorcheck0,asm:stepstmsmonitor:monitorcheck1}.

          \Cref{goal:stepstmsmonitor:final:storeagree}, again, by transitivity using \Cref{asm:stepstmsmonitor:case0:storeagree1,asm:stepstmsmonitor:case0:storeagree2}, making use of \Thmref{lem:store-agree-weaken}.
  \end{description}
\end{proof}

\realthm{thm:mmlAs:tmssafe}{1}{$\mmlAs$ is \gls{tms} via Monitor}
\begin{proof}
  Inverting \Cref{asm:mmlatmsviamonitor:run} and omitting the spurious cases, we get \MK{rework}
  \begin{passumptions}{H}
    \item\label[ass]{asm:mmlatmsviamonitor:progtyps} $\typechecks{}{prog\ e_{0}\ e_{p}\ e_{1}}{\nat}$
    \item\label[ass]{asm:mmlatmsviamonitor:fill} $\plugs{e_{p}}{e_{0}}=\src{e_{0}'}$
    \item\label[ass]{asm:mmlatmsviamonitor:exec0} $\execs{\hole{\cdot};\hole{\cdot}}{e_{0}'}{\configs_{0}}{e_{po}}{\trace[_{0}]\cdot Call\ ?\finalexprnoerr_{0}}$
    \item\label[ass]{asm:mmlatmsviamonitor:execp} $\execs{\configs_{0}}{e_{po}}{\configs_{po}}{e_{0}''}{\trace[_{p}]\cdot Ret\ !\finalexprnoerr_{p}}$
    \item\label[ass]{asm:mmlatmsviamonitor:exec0p} $\execs{\configs_{po}}{e_0''}{\configs_{0}'}{\finalexprnoerr_{p}'}{\trace[_{0}']}$
    \item\label[ass]{asm:mmlatmsviamonitor:exec1} $\execs{\configs_{0}'}{e_{1}[\finalexprnoerr_{p}'/y]}{\configs_{1}}{\finalexprnoerr_{1}}{\trace[_{1}]}$
    \item\label[ass]{asm:mmlatmsviamonitor:tracedef} $\src{\trace}=\src{Ret\ !0}\cdot\src{\trace[_0]}\cdot\src{Call\ ?\finalexprnoerr_0}\cdot\src{\trace[_p]}\cdot\src{Ret\ !\finalexprnoerr_p}\cdot\src{\trace[_{0}']}\cdot\src{\trace[_1]\cdot\src{Call\ ?\finalexprnoerr_1}}$
  \end{passumptions}
  Inverting \Cref{asm:mmlatmsviamonitor:progtyps} yields:
  \begin{passumptions}{H'}
    \item\label[ass]{asm:mmlatmsviamonitor:ctxtyps} $\typechecks{}{context\ e_{0}\ e_{1}}{\left(\type_{1}\to\type_{2}\right)\to\nat}$
    \item\label[ass]{asm:mmlatmsviamonitor:comptyps} $\typechecks{}{component\ e_{p}}{\type_{1}\to\type_{2}}$
  \end{passumptions}
  Use \Thmref{lem:fillTyping} with \Cref{asm:mmlatmsviamonitor:ctxtyps,asm:mmlatmsviamonitor:comptyps} and \Cref{asm:mmlatmsviamonitor:fill}:
  \begin{passumptions}{F}
    \item\label[ass]{asm:mmlatmsviamonitor:e0typs} $\typechecks{}{e_{0}'}{\type}$
    \item\label[ass]{asm:mmlatmsviamonitor:e1typs} $\typechecks{y:\type}{e_{1}}{\nat}$
  \end{passumptions}
  Note that by \Cref{tr:t-empty-store} and \Cref{tr:w-t-prog} using \Cref{asm:mmlatmsviamonitor:e0typs} we have:
  \begin{passumptions}{F}
    \setcounter{enumi}{2}
    \item\label[ass]{asm:mmlatmsviamonitor:e0progtypsi} $\typechecks{}{\hole{\cdot};\hole{\cdot}\triangleright e_{0}'}{\type}$
  \end{passumptions}
  Also note that by \Thmref{lem:fill:nohole} using \Cref{asm:mmlatmsviamonitor:fill}, we can apply \Cref{tr:runtime-term-rule} on \Cref{asm:mmlatmsviamonitor:e0progtypsi}:
  \begin{passumptions}{F}
    \setcounter{enumi}{3}
    \item\label[ass]{asm:mmlatmsviamonitor:e0progtyps} $\left[\typechecks{}{\hole{\cdot};\hole{\cdot}\triangleright e_{0}'}{\type}\right]$
  \end{passumptions}
  With \Cref{asm:mmlatmsviamonitor:e0progtyps,asm:mmlatmsviamonitor:exec0} and \Cref{tr:store-empty-agree} we discharge \Thmref{lem:generaltms:monitor}:
  \begin{passumptions}{M^{(0')}}
    \item\label[ass]{asm:mmlatmsviamonitor:m0:deltasubset} $\emptyset\subseteq\delta_{\text{tms}}^{(0)}$
    \item\label[ass]{asm:mmlatmsviamonitor:m0:traceagree} $\traceagree[\delta_{\text{tms}}^{(0)}]{\tospecificevs{\trace[_{0}]\cdot Call\ ?\finalexprnoerr_{0}}}{\abstrace_{0}}$
    \item\label[ass]{asm:mmlatmsviamonitor:m0:monitorstep} $\monitorcheck{\emptyset}{\tmsmonitor[^{(0)}]}{\abstrace_{0}}$
    \item\label[ass]{asm:mmlatmsviamonitor:m0:storeagree} $\storeagree[\delta_{\text{tms}}^{(0)}]{\tmsmonitor^{(0)}}{\src{\Omega_{0}.\Delta}}$
  \end{passumptions}
  To use \Thmref{lem:steps-preservation}, we take \Cref{asm:mmlatmsviamonitor:e0progtyps,asm:mmlatmsviamonitor:exec0} and get:
  \begin{passumptions}{F}
    \setcounter{enumi}{4}
    \item\label[ass]{asm:mmlatmsviamonitor:epoprogtyps} $\left[\typechecks{}{\Omega_{0}\triangleright e_{po}}{\type}\right]$
  \end{passumptions}
  Now we are ready to apply \Thmref{lem:generaltms:monitor} again, making use of \Cref{asm:mmlatmsviamonitor:epoprogtyps,asm:mmlatmsviamonitor:execp} and \Cref{asm:mmlatmsviamonitor:m0:storeagree}:
  \begin{passumptions}{M^{(p)}}
    \item\label[ass]{asm:mmlatmsviamonitor:mp:deltasubset} $\delta_{\text{tms}}^{(0)}\subseteq\delta_{\text{tms}}^{(p)}$
    \item\label[ass]{asm:mmlatmsviamonitor:mp:traceagree} $\traceagree[\delta_{\text{tms}}^{(p)}]{\tospecificevs{\trace[_{p}]\cdot Ret\ !\finalexprnoerr_{p}}}{\abstrace_{p}}$
    \item\label[ass]{asm:mmlatmsviamonitor:mp:monitorstep} $\monitorcheck{\tmsmonitor[^{(0)}]}{\tmsmonitor[^{(p)}]}{\abstrace_{p}}$
    \item\label[ass]{asm:mmlatmsviamonitor:mp:storeagree} $\storeagree[\delta_{\text{tms}}^{(p)}]{\tmsmonitor^{(p)}}{\src{\Omega_{po}.\Delta}}$
  \end{passumptions}
  We would like to use \Thmref{lem:steps-preservation} again. So, take \Cref{asm:mmlatmsviamonitor:epoprogtyps,asm:mmlatmsviamonitor:execp} and get:
  \begin{passumptions}{F}
    \setcounter{enumi}{5}
    \item\label[ass]{asm:mmlatmsviamonitor:e0pprogtyps} $\left[\typechecks{}{\Omega_{po}\triangleright e_{0}''}{\type_{2}}\right]$
  \end{passumptions}
  We are ready to apply \Thmref{lem:generaltms:monitor} again, making use of \Cref{asm:mmlatmsviamonitor:e0pprogtyps,asm:mmlatmsviamonitor:exec0p} and \Cref{asm:mmlatmsviamonitor:mp:storeagree}:
  \begin{passumptions}{M^{(0'')}}
    \item\label[ass]{asm:mmlatmsviamonitor:m0p:deltasubset} $\delta_{\text{tms}}^{(p)}\subseteq\delta_{\text{tms}}^{(0'')}$
    \item\label[ass]{asm:mmlatmsviamonitor:m0p:traceagree} $\traceagree[\delta_{\text{tms}}^{(0'')}]{\tospecificevs{\trace[_{0}']}}{\abstrace_{0}'}$
    \item\label[ass]{asm:mmlatmsviamonitor:m0p:monitorstep} $\monitorcheck{\tmsmonitor[^{(p)}]}{\tmsmonitor[^{(0'')}]}{\abstrace_{0}'}$
    \item\label[ass]{asm:mmlatmsviamonitor:m0p:storeagree} $\storeagree[\delta_{\text{tms}}^{(0'')}]{\tmsmonitor^{(0'')}}{\src{\Omega_{0}'.\Delta}}$
  \end{passumptions}
  Yet again, use \Thmref{lem:steps-preservation} with \Cref{asm:mmlatmsviamonitor:e0pprogtyps,asm:mmlatmsviamonitor:exec0p}, but invert the result:
  \begin{passumptions}{G}
    \item\label[ass]{asm:mmlatmsviamonitor:omega0pgamma0p} $\typechecks{}{\Omega_{0}'}{\Gamma_{0}'}$
    \item\label[ass]{asm:mmlatmsviamonitor:fpprogtyps} $\typechecks{\Gamma_{0}'}{\finalexprnoerr_{p}'}{\type_{2}}$
  \end{passumptions}
  Note that $\src{\Gamma_{0}'}=\src{\hole{\cdot}}\circ\src{\Gamma_{0}'}$ by \Cref{tr:t-empty-splitL}, which we use together with \Cref{asm:mmlatmsviamonitor:fpprogtyps,asm:mmlatmsviamonitor:e1typs} to discharge \Thmref{lem:substitution}:
  \begin{passumptions}{G}
    \setcounter{enumi}{2}
    \item\label[ass]{asm:mmlatmsviamonitor:e1substtyps} $\typechecks{\Gamma_{0}'}{e_{1}[\finalexprnoerr_{p}'/y]}{\nat}$
  \end{passumptions}
  With \Cref{asm:mmlatmsviamonitor:e1substtyps,asm:mmlatmsviamonitor:omega0pgamma0p} it follows from \Cref{tr:w-t-prog} that
  \begin{passumptions}{F}
    \setcounter{enumi}{6}
    \item\label[ass]{asm:mmlatmsviamonitor:e1substprogchecks} $\left[\typechecks{}{\Omega_{0}'\triangleright e_{1}[\finalexprnoerr_{p}'/y]}{\nat}\right]$
  \end{passumptions}
  Use \Cref{asm:mmlatmsviamonitor:e1substprogchecks,asm:mmlatmsviamonitor:exec1} and \Cref{asm:mmlatmsviamonitor:m0p:storeagree} to apply \Thmref{lem:generaltms:monitor}:
  \begin{passumptions}{M^{(1)}}
    \item\label[ass]{asm:mmlatmsviamonitor:m1:deltasubset} $\delta_{\text{tms}}^{(0'')}\subseteq\delta_{\text{tms}}^{(1)}$
    \item\label[ass]{asm:mmlatmsviamonitor:m1:traceagree} $\traceagree[\delta_{\text{tms}}^{(1)}]{\tospecificevs{\trace[_{1}]}}{\abstrace_{1}}$
    \item\label[ass]{asm:mmlatmsviamonitor:m1:monitorstep} $\monitorcheck{\tmsmonitor[^{(p)}]}{\tmsmonitor[^{(1)}]}{\abstrace_{1}}$
    \item\label[ass]{asm:mmlatmsviamonitor:m1:storeagree} $\storeagree[\delta_{\text{tms}}^{(1)}]{\tmsmonitor^{(1)}}{\src{\Omega_{1}.\Delta}}$
  \end{passumptions}
  We instantiate our goal according to \Cref{def:src:trace:tms} with $\delta=\delta_{\text{tms}}^{{(1)}}$, $\abstrace=\bm{\varepsilon}\cdot\abstrace_{0}\cdot\abstrace_{p}\cdot\abstrace_{0}'\cdot\abstrace_{1}\cdot\bm{\varepsilon}$, and $\tmsmonitor=\tmsmonitor^{(1)}$, what we have left to show is:
  \begin{goals}
    \setcounter{enumi}{1}
    \item\label[goal]{goal:mmlatmsviamonitor:traceagree} $\traceagree[\delta_{\text{tms}}^{(1)}]{\tospecificevs{\trace}}{\bm{\varepsilon}\cdot\abstrace_{0}\cdot\abstrace_{p}\cdot\abstrace_{0}'\cdot\abstrace_{1}\cdot\bm{\varepsilon}}$
    \item\label[goal]{goal:mmlatmsviamonitor:monitorcheck} $\monitorcheck{\emptyset}{\tmsmonitor^{(1)}}{\bm{\varepsilon}\cdot\abstrace_{0}\cdot\abstrace_{p}\cdot\abstrace_{0}'\cdot\abstrace_{1}\cdot\bm{\varepsilon}}$
  \end{goals}
  Note we can rewrite \Cref{goal:mmlatmsviamonitor:traceagree} using \Cref{asm:mmlatmsviamonitor:tracedef} to:
  \begin{goals}
    \setcounter{enumi}{1}
    \item $\traceagree[\delta_{\text{tms}}^{(1)}]{\tospecificevs{Ret\ !0\cdot\trace[_{0}]\cdot Call\ ?\finalexprnoerr_{0}\cdot\trace[_{p}]\cdot Ret\ !\finalexprnoerr_{p}\cdot\trace[_{0}']\cdot\trace[_{1}]\cdot Call\ ?\finalexprnoerr_{1}}}{\bm{\varepsilon}\cdot\abstrace_{0}\cdot\abstrace_{p}\cdot\abstrace_{0}'\cdot\abstrace_{1}\cdot\bm{\varepsilon}}$
  \end{goals}
  which equals
  \begin{goals}
    \setcounter{enumi}{1}
    \item $\traceagree[\delta_{\text{tms}}^{(1)}]{\specificev{Ret\ !0}\cdot\tospecificevs{\trace[_{0}]\cdot Call\ ?\finalexprnoerr_{0}\cdot\trace[_{p}]\cdot Ret\ !\finalexprnoerr_{p}\cdot\trace[_{0}']\cdot\trace[_{1}]\cdot Call\ ?\finalexprnoerr_{1}}}{\bm{\varepsilon}\cdot\abstrace_{0}\cdot\abstrace_{p}\cdot\abstrace_{0}'\cdot\abstrace_{1}\cdot\bm{\varepsilon}}$
  \end{goals}
  By \Cref{tr:tms-ret-auth} we can trim the head. We immediately apply \Thmref{lem:trace-agree-trans} several times to get:
  \begin{itemize}
    \item $\traceagree[\delta_{\text{tms}}^{(1)}]{\tospecificevs{\trace[_{0}]\cdot Call\ ?\finalexprnoerr_{0}}}{\abstrace_{0}}$, by \Cref{asm:mmlatmsviamonitor:m0:traceagree}
    \item $\traceagree[\delta_{\text{tms}}^{(1)}]{\tospecificevs{\trace[_{p}]\cdot Ret\ !\finalexprnoerr_{p}}}{\abstrace_{p}}$, by \Cref{asm:mmlatmsviamonitor:mp:traceagree}
    \item $\traceagree[\delta_{\text{tms}}^{(1)}]{\tospecificevs{\trace[_{0}']}}{\abstrace_{0}'}$, by \Cref{asm:mmlatmsviamonitor:m0p:traceagree}
    \item $\traceagree[\delta_{\text{tms}}^{(1)}]{\tospecificevs{\trace[_{1}]}}{\abstrace_{1}}$, by \Cref{asm:mmlatmsviamonitor:m1:traceagree}
    \item $\traceagree[\delta_{\text{tms}}^{(1)}]{\tospecificevs{Call\ ?\finalexprnoerr_{1}\cdot\hole{\cdot}}}{\bm{\varepsilon}\cdot\hole{\cdot}}$, by \Cref{tr:tms-call-auth,tr:tms-refl-auth}
  \end{itemize}

  \Cref{goal:mmlatmsviamonitor:monitorcheck} goes by transitivity using \Cref{tr:tms-trans,tr:tms-uninteresting} and \Cref{asm:mmlatmsviamonitor:m0:monitorstep,asm:mmlatmsviamonitor:mp:monitorstep} and \Cref{asm:mmlatmsviamonitor:m0p:monitorstep,asm:mmlatmsviamonitor:m1:monitorstep}.
\end{proof}

\subsection{Target Language}
\subsubsection{Syntax}

%%%%
%% TARGET

\myfig{
	\vspace{-1em}
  \begin{gather*}
  \begin{aligned}
  \mi{Final\ Result}\ \trg{\finalexprnoerr} \bnfdef&\ \trg{\valueexpr} \mid \trg{x}\hspace{0.5cm}
  \mi{May\ be\ a\ Result}\ \trg{\finalexpr} \bnfdef\ \trg{\finalexprnoerr} \mid \trg{stuck} \\
  \mi{Expressions}~\trg{e} \bnfdef&\ \trg{\finalexpr} \mid \trg{e_{1} \oplus e_{2}} \mid \trg{x[e]} \mid \trg{let\ x = e_{1}\ in\ e_{2}}\mid \trg{x[e_{1}]\leftarrow e_{2}} \\
    & \mid \trg{let\ x=new\ e_{1}\ in\ e_{2}} \mid \trg{delete\ x} \mid \trg{return\ e} \mid \trg{call\ foo\ e} \\
    & \mid \trg{ifz\ e_1\ then\ e_2\ else\ e_3} \mid \trg{abort()} \mid \trg{x\ is\ \poisoned} \\
    & \mid \trg{\langle e_1;e_2\rangle} \mid \trg{\pi_1\ e} \mid \trg{\pi_2\ e}\mid \trg{e\ has\ \type}
  \hspace{0.5cm} \text{where } \trg{\oplus}\in\{\trg{+},\trg{-},\trg{\times},\trg{<}\}\\
  \mi{Functions}~\trg{\asymbol} \bnfdef&\ \trg{let\ foo\ x:=e}\hspace{0.5cm}
  \mi{Types}~\trg{\type} \bnfdef\ \trg{\nat}\mid\trg{\nat\times\nat} \\
  %
  \mi{Values}~\trg{v} \bnfdef&\ \trg{\langle n_{1}, n_{2}\rangle} \mid \trg{n}\in\trg{\nat} \hspace{0.5cm}
  \mi{References}~\trg{\loc}\in\trg{\nat} \\
  \mi{Eval.Ctx.}~\trg{K}\bnfdef &\ \trg{\hole{\cdot}}\mid \trg{K\oplus e}\mid \trg{v\oplus E}\mid \trg{x[K]}\mid \trg{let\ x=K\ in\ e} \\
                 &\mid \trg{x[K]\leftarrow e}\mid \trg{x[v]\leftarrow K}\mid \trg{let\ x=new\ K\ in\ e} \\
                 &\mid \trg{\langle K; e\rangle} \mid \trg{\langle n; K\rangle} \mid \trg{ifz\ K\ then\ e_1\ else\ e_2} \mid \trg{\pi_{1}\ K} \mid \trg{\pi_{2}\ K} \\
                 &\mid \trg{K\ has\ \type}\mid\trg{call\ foo\ K}\mid\trg{return\ K} \\
  %
  \mi{Variables}~\ \trg{x} &\mid \trg{y} \mid \trg{foo} \mid \dots \hspace{0.35cm}
  %
  \mi{Poison}~\ \trg{\poison}~\bnfdef\ \trg{\poisonless} \mid \trg{\poisoned}\\
  %
  \mi{Store}~\trg{\Delta} \bnfdef&\ \trg{\hole{\cdot}} \mid \trg{x\mapsto\loc_\poison},\Deltat\hspace{0.35cm}
  \mi{Communication}~\trg{\comm} \bnfdef\ \trg{\ctxtocomp} \mid \trg{\comptoctx} \mid \trg{\nocomm}\\
  \mi{Cont.\ Stack}~\trg{\kontstack} \bnfdef&\ \trg{\hole{\cdot}} \mid \trg{K_{\comm}^{foo}},\trg{\kontstack} \hspace{0.5cm}
  \mi{Library}~\trg{\library} \bnfdef\ \trg{\hole{\cdot}} \mid \trg{\asymbol},\trg{\library}\\
  %
  \mi{Relevant}~\trg{\commlib} \bnfdef&\ \trg{\hole{\cdot}} \mid \trg{foo},\trg{\commlib}\hspace{0.35cm}
  \mi{Heaps}~\trg{H} \bnfdef\ \trg{\hole{\cdot}} \mid \trg{H}::\trg{n} \hspace{0.35cm}
  \mi{State}\ \configt \bnfdef\ \trg{\cfstate;\memstate} \\
  %
  \mi{Flow\ State}\ \trg{\cfstate} \bnfdef&\ \trg{\commlib;\library;\kontstack}\hspace{0.35cm}
  \mi{Memory\ State}\ \trg{\memstate} \bnfdef \trg{H;\Delta}\\
  %
  \mi{Programs}\ &\trg{prog\ \library_{ctx}\ \library_{comp}} \\
  \end{aligned}
  \end{gather*}
}{mmlat-syntax}{Syntax of $\mmlAt$}

The target language is very similar to the source language presented in the previous section.
However, it does contain simple, non-nested pairs and dynamic type checks.

\subsubsection{Dynamic Semantics}

\myfig{
  \judgbox{\operatorname{dom}\ \trg{\library}=\trg{foo},\dots,\trg{bar}}{,,Collect function names.''}$\;$\\
  \begin{center}
    \typerule{$\trg{\library}$-dom-$\trg{\hole{\cdot}}$}{
    }{
      \operatorname{dom}\ \trg{\hole{\cdot}} = \trg{\hole{\cdot}}
    }{wt-lib-dom-empty}
    %
    \typerule{$\trg{\library}$-dom-cons}{
      \operatorname{dom}\ \trg{\library} = \trg{D}
    }{
      \operatorname{dom}\ (\trg{let\ foo\ x : \type}_\lambda\trg{:= e})\trg{,\library} = \trg{foo},\trg{D}
    }{wt-lib-dom-cons}
  \end{center}
  \begin{center}
    \judgbox{\trg{\library}\equiv\trg{\library_1}\cup\trg{\library_2}}{,,Merging $\mmlAt$ libraries.''}$\;$\\
    \typerule{lib-merge-empty}{
      \trg{\library}=\trg{\library_1}
    }{
      \trg{\library}\equiv\trg{\library_1}\cup\trg{\hole{\cdot}}
    }{trg-lib-merge-empty}
    %
    \typerule{lib-merge-cons}{
      \trg{\library}\equiv\trg{\library_1}\cup\trg{\library_2}
    }{
      \trg{\asymbol,\library}\equiv\trg{\library_1}\cup\trg{\asymbol,\library_2}
    }{trg-lib-merge-cons}

    \judgbox{\trg{\library_1\linker\library_2}=\trg{\library}}{,,Syntactically linking $\mmlAt$ libraries.''}$\;$\\
    \typerule{syntactic-plugging}{
      \operatorname{dom}\trg{\library_1}\cap\operatorname{dom}\trg{\library_2} = \emptyset &
      \trg{\library}\equiv\trg{\library_1}\cup\trg{\library_2}
    }{
      \trg{\library_1\linker\library_2} = \trg{\library}
    }{trg-plugging}
  \end{center}
}{w-plugging-t}{$\mmlAt$ plugging of libraries and collecting of function names.}


\myfig{
  \begin{gather*}
  \begin{aligned}
  \mi{Interface\ Value}~\trg{\interfacevalue} \bnfdef&\ \trg{\valueexpr} \mid \trg{\loc} \\
  \mi{Events}~\trg{\event} \bnfdef&\ \trg{\emptyevent} \mid \trg{Alloc\ \loc\ n} \mid \trg{Dealloc\ \loc} \mid \trg{Get\ \loc\ n} \mid \trg{Set\ \loc\ n} \mid \trg{\lightning}\\
                             & \mid \trg{Call\ \comm\ foo\ \interfacevalue} \mid \trg{Ret\ \comm\ \interfacevalue} \mid \trg{Start} \mid \trg{End\ \interfacevalue}
  \end{aligned}
  \end{gather*}
}{tw-events}{Events of $\mmlAt$.}

\myfig{
  \judgbox{\exprevalt{\configt}{e}{\configt'}{e'}{\event}}{,,Expression $\trg{e}$ evaluates under configuration $\configt$ to $\trg{e'}$ and\\new configuration $\trg{\configt'}$, emitting event $\trg{\event}$.''}
  %
  \typerule{$e-\trg{\oplus}$}{
    \trg{n_1}\oplus\trg{n_2}=\trg{n_3}
  }{
    \exprevalt{\configt}{n_1\oplus n_2}{\configt}{n_3}{\emptyevent}
  }{tw-e-oplus}
  %
  \typerule{$e-\trg{get}-\in$}{
    \trg{\loc}+\trg{n}\in\text{dom }\trg{H}
  }{
    \exprevalt{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{x[n]}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{H(\loc+n)}{Get\ \loc\ n}
  }{tw-e-get-in}
  %
  \typerule{$e-\trg{get}-\notin$}{
    \trg{\loc}+\trg{n}\notin\text{dom }\trg{H}
  }{
    \exprevalt{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{x[n]}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{1729}{Get\ \loc\ n}
  }{tw-e-get-notin}
  %
  \typerule{$e-\trg{set}$}{
    \trg{H'} = \trg{H}(\trg{\loc+n}\mapsto \trg{v})
  }{
    \exprevalt{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{x[n]\leftarrow \valueexpr}{\cfstate;H';\Delta_1,x\mapsto\loc_\poison,\Delta_2}{v}{Set\ \loc\ n\ \valueexpr}
  }{tw-e-set}
  %
  \typerule{$e-\trg{let}-\trg{\finalexprnoerr}$}{
  }{
    \exprevalt{\Omega}{let\ x=\finalexprnoerr\ in\ e}{\Omega}{e[\finalexprnoerr/x]}{\emptyevent}
  }{tw-e-let-x}
  %
  \typerule{$e-\trg{delete}$}{
  }{
    \exprevalt{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{delete\ x}{\cfstate;H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}{0}{Dealloc\ \loc}
  }{tw-e-delete}
  %
  \typerule{$e-\trg{new}$}{
    \fresh{\trg{\Delta}}{\trg{\loc}} &
    \fresh{\trg{\Delta}}{\trg{z}} &
    \trg{H'} = \trg{H} \ll \trg{n} &
  }{
  \exprevalt{\cfstate;H;\Delta}{let\ x=new\ n\ in\ e}{\cfstate;H';z\mapsto \loc_\poisonless,\Delta}{e[z/x]}{Alloc\ \loc\ n}
  }{tw-e-let-new}
  %
  \typerule{$e-\trg{ifz}-$true}{
  }{
    \exprevalt{\configt}{ifz\ 0\ then\ e_1\ else\ e_2}{\configt}{e_1}{\emptyevent}
  }{tw-e-if-true}
  %
  \typerule{$e-\trg{ifz}-$false}{
  }{
    \exprevalt{\configt}{ifz\ S(n)\ then\ e_1\ else\ e_2}{\configt}{e_2}{\emptyevent}
  }{tw-e-if-false}
  %
  \typerule{$e-\trg{abort}$}{
  }{
    \exprevalt{\configt}{abort()}{\configt}{stuck}{\lightning}
  }{tw-e-abort}
  %
  %
  \typerule{$e-\trg{\pi_1}$}{
  }{
    \exprevalt{\configt}{\pi_1\langle n_1;n_2\rangle}{\configt}{n_1}{\emptyevent}
  }{tw-e-proj1}
  %
  \typerule{$e-\trg{\pi_2}$}{
  }{
    \exprevalt{\configt}{\pi_2\langle n_1;n_2\rangle}{\configt}{n_2}{\emptyevent}
  }{tw-e-proj2}
  %
  \typerule{$e-\trg{x\ is\ \poisoned}-$yes}{
    \trg{\memstate}=\trg{H;\Delta} &
    \trg{\Delta}=\trg{\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}
  }{
    \exprevalt{\cfstate;\memstate}{x\ is\ \poisoned}{\cfstate;\memstate}{0}{\emptyevent}
  }{tw-e-x-is-poisoned-yes}
  %
  \typerule{$e-\trg{x\ is\ \poisoned}-$no}{
    \trg{\memstate}=\trg{H;\Delta} &
    \trg{\Delta}=\trg{\Delta_1,x\mapsto\loc_\poisonless,\Delta_2}
  }{
    \exprevalt{\cfstate;\memstate}{x\ is\ \poisoned}{\cfstate;\memstate}{1}{\emptyevent}
  }{tw-e-x-is-poisoned-yes}
  %
  \typerule{$e-\trg{n\ has\ \nat}$}{
  }{
    \exprevalt{\configt}{n\ has\ \nat}{\configt}{0}{\emptyevent}
  }{tw-e-n-hasnat}
  %
  \typerule{$e-pair-\trg{has\ \nat}$}{
  }{
    \exprevalt{\configt}{\langle n_1,n_2\rangle\ has\ \nat}{\configt}{1}{\emptyevent}
  }{tw-e-pair-hasnat}
  %
  \typerule{$e-\trg{x\ has\ \nat}$}{
  }{
    \exprevalt{\configt}{x\ has\ \nat}{\configt}{1}{\emptyevent}
  }{tw-e-x-hasnat}
  %
  \typerule{$e-\trg{n\ has\ \nat\times\nat}$}{
  }{
    \exprevalt{\configt}{n\ has\ \nat\times\nat}{\configt}{1}{\emptyevent}
  }{tw-e-n-haspair}
  %
  \typerule{$e-pair-\trg{has\ \nat\times\nat}$}{
  }{
    \exprevalt{\configt}{\langle n_1,n_2\rangle\ has\ \nat\times\nat}{\configt}{0}{\emptyevent}
  }{tw-e-pair-haspair}
  %
  \typerule{$e-\trg{x\ has\ \nat\times\nat}$}{
  }{
    \exprevalt{\configt}{x\ has\ \nat\times\nat}{\configt}{1}{\emptyevent}
  }{tw-e-x-haspair}
}{tw-expr-eval}{Evaluation of $\mmlAt$ expressions.}

\myfig{
  \begin{center}
    \judgbox{\exect[]{\configt}{K[e]}{\configt'}{K[e']}{\event}}{,,Given an evaluation context $\trg{K}$ and an expression $\trg{e}$,\\it evaluates under configuration $\configt$ to $\trg{e'}$ and new\\configuration $\trg{\configt'}$ in context $\trg{K}$, emitting event $\trg{\event}$.''}
    %
    \typerule{$et-\text{ctx}$}{
      \exprevalt{\Omega}{e}{\Omega'}{e'}{\event}
    }{
      \exect[]{\Omega}{K[e]}{\Omega'}{K[e']}{\event}
    }{w-t-e-ectx}
    %
    \typerule{$et-\text{ctx}-\trg{stuck}$}{
      \exprevalt{\Omega}{e}{\Omega'}{stuck}{\lightning}
    }{
      \exect[]{\Omega}{K[e]}{\Omega'}{stuck}{\lightning}
    }{w-t-e-ectx-stuck}
    %
    \typerule{$et-\text{ctx}-\trg{call}-\trg{\valueexpr}$}{
      \trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate} &
      \trg{\library}=\trg{\library_1,}(\trg{let\ foo\ x:\type}_\lambda\trg{:=e})\trg{,\library_2} \\
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{\kontstack},\trg{v}) = \trg{\event},\trg{\comm} &
      \trg{\Omega'}=\trg{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate} \\
    }{
      \exect[]{\Omega}{K[call\ foo\ \valueexpr]}{\Omega'}{return\ e[x/\valueexpr]}{\event}
    }{w-t-e-ectx-call-value}
    %
    \typerule{$et-\text{ctx}-\trg{call}-\trg{\loc}$}{
      \trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate} &
      \trg{\memstate}=\trg{H;\Delta}&
      \trg{\Delta}=\trg{\Delta_1},\trg{x\mapsto\loc_\poison},\trg{\Delta_2}\\
      \trg{\library}=\trg{\library_1,}(\trg{let\ foo\ x:\type}_\lambda\trg{:=e})\trg{,\library_2} \\
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{\kontstack},\trg{\loc}) = \trg{\event},\trg{\comm} &
      \trg{\Omega'}=\trg{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate} \\
    }{
      \exect[]{\Omega}{K[call\ foo\ x]}{\Omega'}{return\ e[x/\valueexpr]}{\event}
    }{w-t-e-ectx-call-value}
    %
    \typerule{$et-\text{ctx}-\trg{return}-\trg{\valueexpr}$}{
    }{
      \exec[]{\trg{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate}}{\trg{K'[return\ \valueexpr]}}{\trg{\commlib;\library;\kontstack;\memstate}}{\trg{K[\valueexpr]}}{\rho_{\tiny ret}\left(\trg{\comm},\trg{\valueexpr}\right)}
    }{w-t-e-ectx-ret}
    %
    \typerule{$e-\text{ctx}-\trg{return}-\trg{\loc}$}{
      \rho_{\tiny ret}\left(\trg{\comm}\right)=\trg{\comm_0} &
      \trg{\memstate}=\trg{H;\Delta}&
      \trg{\Delta}=\trg{\Delta_1},\trg{x\mapsto\loc_\poison},\trg{\Delta_2}
    }{
      \exec[]{\trg{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate}}{\trg{K'[return\ x]}}{\trg{\commlib;\library;\kontstack;\memstate}}{\trg{K[x]}}{\rho_{\tiny ret}\left(\trg{\comm},\trg{\loc}\right)}
    }{w-e-ectx-ret}
    %
    \judgbox{\rho_{\tiny ret}(\trg{\comm},\trg{\interfacevalue})=\trg{\event}}{,,Given the last comm. and we are returning, yield event.''}
    %
    \typerule{t-comm-ret-ctxtocomp}{
    }{
      \rho_{\tiny ret}(\trg{\ctxtocomp},\trg{\interfacevalue})=\trg{Ret\ \ctxtocomp\ \interfacevalue}
    }{w-t-comm-ret-ctxtocomp}
    %
    \typerule{t-comm-ret-internal}{
    }{
      \rho_{\tiny ret}(\trg{\nocomm},\trg{\interfacevalue})=\trg{\varepsilon}
    }{w-t-comm-ret-internal}
    %
    \typerule{t-comm-ret-comptoctx}{
    }{
      \rho_{\tiny ret}(\trg{\comptoctx},\trg{\interfacevalue})=\trg{Ret\ \comptoctx\ \interfacevalue}
    }{w-t-comm-ret-comptoctx}\\[0.33cm]
    %
    \judgbox{\rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{\kontstack},\trg{\interfacevalue})=\trg{\event},\trg{\comm}}{,,Given the ctx. info, yield event.''}
    %
    \typerule{t-comm-call-empty-stack-comp}{
      \trg{foo}\in\trg{\commlib}
    }{
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{\hole{\cdot}},\trg{\interfacevalue})=\trg{Call\ \ctxtocomp\ foo\ \interfacevalue},\trg{\comptoctx}
    }{w-t-comm-call-empty-stack-comp}
    %
    \typerule{t-comm-call-empty-stack-ctx}{
      \trg{foo}\notin\trg{\commlib}
    }{
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{\hole{\cdot}},\trg{\interfacevalue})=\trg{Call\ \comptoctx\ foo\ \interfacevalue},\trg{\ctxtocomp}
    }{w-t-comm-call-empty-stack-ctx}
    %
    \typerule{t-comm-call-nonempty-stack}{
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{bar},\trg{\interfacevalue})=\trg{\event},\trg{\comm}
    }{
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{K^{bar},\kontstack},\trg{\interfacevalue})=\trg{\event},\trg{\comm}
    }{w-t-comm-call-nonempty-stack}
    %
    \judgbox{\rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{bar_{cur}},\trg{\interfacevalue})=\trg{\event},\trg{\comm}}{,,Given the current ctx. info, yield comm.''}
    %
    \typerule{t-comm-call-comptoctx}{
      \trg{foo}\notin\trg{\commlib} &
      \trg{\commlib}=\trg{\commlib_1},\trg{bar_{cur}},\trg{\commlib_2}
    }{
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{bar_{cur}},\trg{\interfacevalue})=\trg{Call\ \comptoctx\ foo\ \interfacevalue},\trg{\ctxtocomp}
    }{w-t-comm-call-comptoctx}
    %
    \typerule{t-comm-call-internal-both-irrelevant}{
      \trg{foo}\notin\trg{\commlib} &
      \trg{bar_{cur}}\notin\trg{\commlib}
    }{
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{bar_{cur}},\trg{\interfacevalue})=\trg{\emptyevent},\trg{\nocomm}
    }{w-t-comm-call-internal-both-irrelevant}
    %
    \typerule{t-comm-call-internal-both-relevant}{
      \trg{\commlib} = \trg{\commlib_1},\trg{foo},\trg{\commlib_2} &
      \trg{\commlib} = \trg{\commlib_3},\trg{bar_{cur}},\trg{\commlib_4}
    }{
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{bar_{cur}},\trg{\interfacevalue})=\trg{\emptyevent},\trg{\nocomm}
    }{w-t-comm-call-internal-both-relevant}
    %
    \typerule{t-comm-call-ctxtocomp}{
      \trg{\commlib}=\trg{\commlib_1},\trg{foo},\trg{\commlib_2} &
      \trg{bar_{cur}}\notin\trg{\commlib}
    }{
      \rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{bar_{cur}},\trg{\interfacevalue})=\trg{Call\ \ctxtocomp\ foo\ \interfacevalue},\trg{\comptoctx}
    }{w-t-comm-call-ctxtocomp}
  \end{center}
}{w-t-expr-ctx-eval}{Contextual Evaluation of $\mmlAt$ expressions.}

\myfig{
  \begin{center}
    \judgbox{\exect{\configt}{e}{\configt'}{e'}{\trace}}{,,Expression $\trg{e}$ evaluates under configuration $\configt$ to $\trg{e'}$ and\\new configuration $\trg{\configt'}$, emitting list of events $\trg{\trace}$.''}
    %
    \typerule{$et-\text{refl}$}{
    }{
      \exect{\configt}{\finalexpr}{\configt}{\finalexpr}{\hole{\cdot}}
    }{wt-e-refl}
    \typerule{$et-\text{trans}-$important}{
      \exect[]{\configt}{e}{\configt'}{e'}{\event}&
      \exect{\configt'}{e'}{\configt''}{e''}{\trace}&
      \trg{a}\not=\trg{\emptyevent}
    }{
      \exect{\configt}{e}{\configt''}{e''}{\event \cdot \trace}
    }{wt-e-trans-important}
    \typerule{$et-\text{trans}-$unimportant}{
      \exect[]{\configt}{e}{\configt'}{e'}{\emptyevent}&
      \exect{\configt'}{e'}{\configt''}{e''}{\trace}&
    }{
      \exect{\configt}{e}{\configt''}{e''}{\trace}
    }{wt-e-trans-unimportant}
  \end{center}
}{wt-steps}{Trace prefix generation given a $\mmlAt$ program using the reflexive-transitive closure.}

\myfig{
  \begin{center}
    \judgbox{\wexect{prog\ \library_{ctx}\ \library_{comp}}{\Omega}{\finalexpr}{\trace}}{,,Run $\mmlAt$ program $\trg{prog\ \library_{ctx}\ \library_{comp}}$, giving\\dynamic state $\configt$ and emitting trace $\trg{\trace}$.''}
    \typerule{$te-\text{wprog}$}{
      \trg{\library}=\trg{\library_{ctx}\linker\library_{comp}} &
      \trg{\commlib}=\operatorname{dom}\ \trg{\library_{comp}} \\
      \exect{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexpr}{Call\ \comptoctx\ main\ 0\cdot\trace\cdot Ret\ \ctxtocomp\ \interfacevalue}
    }{
      \wexect{prog\ \library_{ctx}\ \library_{comp}}{\Omega}{\finalexpr}{Start\cdot\trace\cdot End\ \interfacevalue}
    }{wt-e-prog}
    %
    \typerule{$te-\text{wprog}-\lightning$}{
      \trg{\library}=\trg{\library_{ctx}\linker\library_{comp}} &
      \trg{\commlib}=\operatorname{dom}\ \trg{\library_{comp}} \\
      \exect{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexpr}{Call\ \comptoctx\ main\ 0\cdot\trace\cdot\lightning}
    }{
      \wexect{prog\ \library_{ctx}\ \library_{comp}}{\Omega}{\finalexpr}{Start\cdot\trace\cdot\lightning}
    }{wt-e-prog-fail}
  \end{center}
}{twprog-run}{Running a whole $\mmlAt$ program.}

\subsubsection{Proofs and Auxiliary Lemmas}

\begin{lemma}[Determinism of Step]\label{lem:determ:step}
  If
  \begin{assumptions}
  \item $\exprevalt{\Omega}{e}{\Omega'}{v_1}{\event_{1}}$
  \item $\exprevalt{\Omega}{e}{\Omega''}{v_2}{\event_{2}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\trg{v'}=\trg{v''}$
  \item $\trg{\Omega'}=\trg{\Omega''}$
  \item $\trg{\event_{1}}=\trg{\event_{2}}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Determinism of Ctx-Step]\label{lem:determ:ctxstep}
  If
  \begin{assumptions}
  \item $\exect[]{\Omega}{e}{\Omega'}{v_1}{\event}$
  \item $\exect[]{\Omega}{e}{\Omega''}{v_2}{\event}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\trg{v'}=\trg{v''}$
  \item $\trg{\Omega'}=\trg{\Omega''}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Determinism of Steps]\label{lem:determ:steps}
  If
  \begin{assumptions}
  \item $\exect{\Omega}{e}{\Omega'}{v_1}{\trace[_{1}]}$
  \item $\exect{\Omega}{e}{\Omega''}{v_2}{\trace[_{2}]}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\trg{v'}=\trg{v''}$
  \item $\trg{\Omega'}=\trg{\Omega''}$
  \item $\trg{\trace[_{1}]}=\trg{\trace[_{2}]}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{definition}[Stuck Trace]\label{def:stuck:trgtrace}
  A trace $\trg{\trace}$ is stuck if it ends with $\trg{\lightning}$.
\end{definition}

\begin{lemma}[Non-stuck Trace Generation]\label{lem:nonstuck:traces}
  If
  \begin{assumptions}
  \item $\exect{\Omega}{e}{\Omega'}{\finalexprnoerr}{\trace}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\trg{\trace}$ is not stuck.
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\subsection{Robust \gls*{tms} Preserving Compiler}

\subsubsection{Compiler}

\myfig{
  \begin{center}
    \begin{gather*}
    \judgbox{\mmlAmmlAtcomp{e}=\trg{e}}{,,Compile $\mmlAs$ expression $\src{e}$ to $\mmlAt$ expression $\trg{e}$.}\\
    \judgbox{\mmlAmmlAtcomp{\left[\valueexpr / x\right]}=\trg{\left[\valueexpr / x\right]}}{,,Compile $\mmlAs$ substitution to $\mmlAt$ substitution.''} \\
    \judgbox{\mmlAmmlAtcomp{\commlib}=\trg{\commlib}}{,,Compile $\mmlAs$ component library to $\mmlAt$ component library.''} \\
    \end{gather*}
    $$
    \begin{array}{rll}
    \mmlAmmlAtcomp{\finalexpr} &\ = & \trg{\finalexpr} \\
    \mmlAmmlAtcomp{call\ foo\ e} &\ = & \trg{call\ }\mmlAmmlAtcomp{foo}\ \mmlAmmlAtcomp{e}\\
    \mmlAmmlAtcomp{return\ e} &\ = & \trg{return\ }\mmlAmmlAtcomp{e}\\
    \mmlAmmlAtcomp{e_1\oplus e_2} &\ = & \mmlAmmlAtcomp{e_1} \trg{\oplus} \mmlAmmlAtcomp{e_2} \\
    \mmlAmmlAtcomp{x[e]} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{e}\trg{]} \\
    \mmlAmmlAtcomp{let\ x= e_1\ in\ e_2} &\ = & \trg{let\ }\mmlAmmlAtcomp{x}\trg{=} \mmlAmmlAtcomp{e_1}\trg{\ in\ }\mmlAmmlAtcomp{e_2} \\
    \mmlAmmlAtcomp{x[e_1]\leftarrow e_2} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{e_1}\trg{]\leftarrow }\mmlAmmlAtcomp{e_2} \\
    \mmlAmmlAtcomp{let\ x=new\ e_1\ in\ e_2} &\ = & \trg{let\ }\mmlAmmlAtcomp{x}\trg{=new\ }\mmlAmmlAtcomp{e_1}\trg{\ in\ }\mmlAmmlAtcomp{e_2} \\
    \mmlAmmlAtcomp{delete\ x} &\ = & \trg{delete\ }\mmlAmmlAtcomp{x} \\
    \mmlAmmlAtcomp{ifz\ e_1\ then\ e_2\ else\ e_3} &\ = & \trg{ifz\ }\mmlAmmlAtcomp{e_1}\\
                                                        &&\trg{then\ }\mmlAmmlAtcomp{e_2} \\
                                                        &&\trg{else\ }\mmlAmmlAtcomp{e_3} \\[0.5cm]
    %
    \mmlAmmlAtcomp{\left[\src{v}/\src{x}\right]}&\ = & \trg{\left[\right.}\mmlAmmlAtcomp{v}\trg{/}\mmlAmmlAtcomp{x}\trg{\left.\right]} \\[0.5cm]
    %
    \mmlAmmlAtcomp{\hole{\cdot}}&\ = & \trg{\hole{\cdot}} \\
    \mmlAmmlAtcomp{foo,\commlib}&\ = & \trg{foo,}\mmlAmmlAtcomp{\commlib} \\
    \end{array}
    $$
  \end{center}
}{tms-pres-compiler}{Compiler from $\mmlAs$ to $\mmlAt$.}
\myfig{
  \begin{center}
    \begin{gather*}
    \judgbox{\mmlAmmlAtcomp{F}=\trg{F}}{,,Compile $\mmlAs$ procedures to $\mmlAt$ procedures.''}
    \end{gather*}
    $$
    \begin{array}{rll}
    %
      \mmlAmmlAtcompN{\src{let\ foo\ x :\nat \to \type_{e} := e}}&\ = & \trg{let\ }\mmlAmmlAtcomp{foo}\ \mmlAmmlAtcomp{x}\trg{ := }\\
                               && \trg{ifz\ }\mmlAmmlAtcomp{x}\trg{\ has\ \nat\ then}\\
                               && \ \ \mmlAmmlAtcomp{e}\\
                               && \trg{else}\\
                               && \ \ \trg{abort()}\\
      \mmlAmmlAtcompN{\src{let\ foo\ x :\wptr \to \type_{e} := e}}&\ = & \trg{let\ }\mmlAmmlAtcomp{foo}\ \mmlAmmlAtcomp{x}\trg{ := }\\
                               && \trg{ifz\ }\mmlAmmlAtcomp{x}\trg{\ has\ \nat\ then}\\
                               && \ \ \trg{abort()}\\
                               && \trg{else\ ifz\ }\mmlAmmlAtcomp{x}\trg{\ has\ \nat \times \nat\ then}\\
                               && \ \ \trg{abort()}\\
                               && \trg{else\ ifz\ }\mmlAmmlAtcomp{x}\trg{\ is\ \poisoned\ then}\\
                               && \ \ \trg{abort()}\\
                               && \trg{else}\\
                               && \ \ \mmlAmmlAtcomp{e}\\
    \end{array}
    $$
    \begin{gather*}
    \judgbox{\mmlAmmlAtcomp{\library}=\trg{\library}}{,,Compile $\mmlAs$ libraries to $\mmlAt$ libraries.''}
    \end{gather*}
    $$
    \begin{array}{rll}
      \mmlAmmlAtcomp{\hole{\cdot}}&\ = & \trg{\hole{\cdot}} \\
      \mmlAmmlAtcomp{F,\library}&\ = & \mmlAmmlAtcomp{F}\trg{,}\mmlAmmlAtcomp{\library} \\
    \end{array}
    $$
  \end{center}
}{tms-pres-compiler-comp}{Compiler from $\mmlAs$ components to $\mmlAt$ components.}
\myfig{
  \begin{center}
    \begin{gather*}
      \judgbox{\mmlAmmlAtcomp{K}=\trg{K}}{,,Compile $\mmlAs$ evaluation contexts to $\mmlAt$ evaluation contexts.''}
    \end{gather*}
    $$
    \begin{array}{rll}
      \mmlAmmlAtcomp{\hole{\cdot}} &\ = & \trg{\hole{\cdot}} \\
      \mmlAmmlAtcomp{K \oplus e} &\ = & \mmlAmmlAtcomp{K}\trg{\oplus}\mmlAmmlAtcomp{e} \\
      \mmlAmmlAtcomp{\valueexpr \oplus K} &\ = & \mmlAmmlAtcomp{\valueexpr}\trg{\oplus}\mmlAmmlAtcomp{K} \\
      \mmlAmmlAtcomp{x[K]} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{K}\trg{]} \\
      \mmlAmmlAtcomp{let\ x\ = K\ in\ e} &\ = & \trg{let\ }\mmlAmmlAtcomp{x}\trg{\ = }\mmlAmmlAtcomp{K}\trg{\ in\ }\mmlAmmlAtcomp{e} \\
      \mmlAmmlAtcomp{x[K] \leftarrow e} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{K}\trg{]\leftarrow} \mmlAmmlAtcomp{e} \\
      \mmlAmmlAtcomp{x[\valueexpr] \leftarrow K} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{\valueexpr}\trg{]\leftarrow }\mmlAmmlAtcomp{K} \\
      \mmlAmmlAtcomp{let\ x\ = new\ K\ in\ e} &\ = & \trg{let\ }\mmlAmmlAtcomp{x}\trg{\ = new\ }\mmlAmmlAtcomp{K}\trg{\ in\ }\mmlAmmlAtcomp{e} \\
      \mmlAmmlAtcomp{ifz\ K\ then\ e_{1}\ else\ e_{2}} &\ = & \trg{ifz\ }\mmlAmmlAtcomp{K}\trg{\ then\ }\\
                               &&\ \ \mmlAmmlAtcomp{e_{1}}\\
                               &&\trg{else\ }\\
                               &&\ \ \mmlAmmlAtcomp{e_{2}} \\
      \mmlAmmlAtcomp{call\ foo\ K} &\ = & \trg{call\ }\mmlAmmlAtcomp{foo}\ \mmlAmmlAtcomp{K}\\
      \mmlAmmlAtcomp{return\ K} &\ = & \trg{return\ }\mmlAmmlAtcomp{K}\\
    \end{array}
    $$
  \end{center}
}{tms-pres-compiler-ctx}{Compiling $\mmlAs$ evaluation contexts to $\mmlAt$ evaluation contexts.}
Compiling components requires a wrapper to ensure that target contexts invoke the compiled component with the right runtime terms.
For example, by adding the dynamic type check we prevent contexts from binding $\trg{\langle 42,1729 \rangle}$ to $\trg{x}$, which is never valid for $\mmlAs$ components.

\myfig{
  \begin{center}
    \judgbox{\delta(\src{\loc})=\trg{\loc}}{,,Map from $\mmlAs$ locations $\src{\loc}$ to $\mmlAt$ locations $\trg{\loc}$.''} \\
    \judgbox{\xlangtraceeq{\trace}{\trace}}{,,The $\mmlAs$ trace $\src{\trace}$ describes the same actions as $\mmlAt$ trace $\trg{\trace}$. Any action in\\$\src{X}$ is ignored, these are generated by the backtranslation wrapper.''} \\
    \typerule{empty-trace-eq}{
    }{
      \xlangtraceeq{\hole{\cdot}}{\hole{\cdot}}
    }{empty-trace-eq}
    %
    \typerule{cons-trace-eq}{
      \src{\event}\notin\src{X} &
      \xlangeventeq{\event}{\event} &
      \xlangtraceeq{\trace}{\trace}
    }{
      \xlangtraceeq{\event\cdot\trace}{\event\cdot\trace}
    }{cons-trace-eq}
    %
    \typerule{ignore-cons-trace-eq}{
      \src{\event}\in\src{X} &
      \xlangtraceeq{\trace}{\trace}
    }{
      \xlangtraceeq{\event\cdot\trace}{\trace}
    }{ignore-cons-trace-eq}
    %
    \judgbox{\xlangeventeq{\event}{\event}}{,,The $\mmlAs$ event $\src{\event}$ describes the same action as $\mmlAt$ event $\trg{\event}$.''} \\
    %
    \typerule{start-event-eq}{
    }{
      \xlangeventeq{Start}{Start}
    }{start-event-eq}
    %
    \typerule{end-event-eq}{
      \src{\interfacevalue} = \trg{\interfacevalue}
    }{
      \xlangeventeq{End\ \interfacevalue}{End\ \interfacevalue}
    }{end-event-eq}
    %
    \typerule{alloc-event-eq}{
      \mmlAmmlAtcomp{n}=\trg{n} &
      \delta(\src{\loc})=\trg{\loc}
    }{
      \xlangeventeq{Alloc\ \loc\ n}{Alloc\ \loc\ n}
    }{alloc-event-eq}
    %
    \typerule{dealloc-event-eq}{
      \delta(\src{\loc})=\trg{\loc}
    }{
      \xlangeventeq{Dealloc\ \loc}{Dealloc\ \loc}
    }{dealloc-event-eq}
    %
    \typerule{get-event-eq}{
      \mmlAmmlAtcomp{n} = \trg{n} &
      \delta(\src{\loc}) = \trg{\loc}
    }{
      \xlangeventeq{Get\ \loc\ n}{Get\ \loc\ n}
    }{get-event-eq}
    %
    \typerule{set-event-eq}{
      \mmlAmmlAtcomp{n} = \trg{n} &
      \delta(\src{\loc}) = \trg{\loc}
    }{
      \xlangeventeq{Set\ \loc\ n}{Set\ \loc\ n}
    }{set-event-eq}
    %
    \typerule{call-event-eq}{
      \mmlAmmlAtcomp{n} = \trg{n} &
      \mmlAmmlAtcomp{foo} = \trg{foo} &
      \src{\comm} = \trg{\comm}
    }{
      \xlangeventeq{Call\ \comm\ foo\ n}{Call\ \comm\ foo\ n}
    }{call-event-eq}
    %
    \typerule{ret-event-eq}{
      \mmlAmmlAtcomp{n} = \trg{n} &
      \src{\comm} = \trg{\comm}
    }{
      \xlangeventeq{Ret\ \comm\ n}{Ret\ \comm\ n}
    }{ret-event-eq}
    %
    \typerule{$\src{\emptyevent}$-event-eq}{
    }{
      \xlangeventeq{\emptyevent}{\emptyevent}
    }{emptyevent-event-eq}
    $\;$\\
    %
    \judgbox{\src{\comm} = \trg{\comm}}{,,Communications are equal.''} \\
    %
    \typerule{$\src{\ctxtocomp}=\trg{\ctxtocomp}$}{
    }{
      \src{\ctxtocomp}=\trg{\ctxtocomp}
    }{sctxtocomp-eq-tctxtocomp}
    %
    \typerule{$\src{\comptoctx}=\trg{\comptoctx}$}{
    }{
      \src{\comptoctx}=\trg{\comptoctx}
    }{scomptoctx-eq-tcomptoctx}
    %
    \typerule{$\src{\nocomm}=\trg{\nocomm}$}{
    }{
      \src{\nocomm}=\trg{\nocomm}
    }{snocomm-eq-tnocomm}
  \end{center}
}{tms-pres-trace-relation}{Trace Relation from $\mmlAs$ to $\mmlAt$.}

\myfig{
  \begin{center}
    \judgbox{\delta(\src{\loc})=\trg{\loc}}{,,The $\mmlAs$ memory location $\src{\loc}$ corresponds to\\the $\mmlAt$ memory location $\trg{\loc}$.''} \\
    \judgbox{\xlangstateeq{\Omega}{\Omega}}{,,The $\mmlAs$ state $\configs$ agrees with $\mmlAt$ state $\configt$. $\src{L}$ contains locations introduced\\by the backtranslation wrapper, which are subsequently ignored.''} \\
    %
    \typerule{state-eq}{
      \src{\Omega}=\src{\cfstate;\memstate} &
      \trg{\Omega}=\trg{\cfstate;\memstate} \\
      \xlangstateeq[]{\cfstate}{\cfstate} &
      \xlangstateeq{\memstate}{\memstate}
    }{
      \xlangstateeq{\Omega}{\Omega}
    }{state-eq}
    %
    \judgbox{\xlangstateeq{\memstate}{\memstate}}{,,The $\mmlAs$ memory-state $\src{\memstate}$ agrees with $\mmlAt$ one $\trg{\memstate}$. $\src{L}$ contains locations\\introduced by the backtranslation wrapper.''}\\
    %
    \typerule{empty-memstate-eq}{
    }{
      \xlangstateeq{\hole{\cdot};\hole{\cdot}}{\hole{\cdot};\hole{\cdot}}
    }{empty-memstate-eq}
    %
    \typerule{cons-memstate-eq}{
      \src{\loc}\notin\src{L}&
      \mmlAmmlAtcomp{x}=\trg{x}&
      \delta\left(\src{\loc}\right)=\trg{\loc}&
      \src{\poison}=\trg{\poison}&
      \src{\loc'-\loc}=\trg{\loc'-\loc} \\
      \src{\loc'-\loc}\vdash\xlangstateeq{H}{H} &
      \xlangstateeq{y\mapsto\loc'_{\poison'},\Delta;H}{y\mapsto\loc'_{\poison'},\Delta;H}
    }{
      \xlangstateeq{x\mapsto\loc_{\poison},y\mapsto\loc'_{\poison'},\Delta;H}{x\mapsto\loc_{\poison},y\mapsto\loc'_{\poison'},\Delta;H}
    }{cons-memstate-eq}
    %
    \typerule{last-cons-memstate-eq}{
      \src{\loc}\notin\src{L}&
      \mmlAmmlAtcomp{x}=\trg{x}&
      \delta\left(\src{\loc}\right)=\trg{\loc}&
      \src{\poison}=\trg{\poison}&
      \operatorname{length}\src{H}\vdash\xlangstateeq[]{H}{H}
    }{
      \xlangstateeq{x\mapsto\loc_{\poison},\hole{\cdot};H}{x\mapsto\loc_{\poison},\hole{\cdot};H}
    }{last-cons-memstate-eq}
    %
    \typerule{cons-ignore-memstate-eq}{
      \src{\loc}\in\src{L}&
      \src{H'}\vdash^{42}_{\operatorname{skip}}\src{H}&
      \xlangstateeq{\Delta;H}{\Delta;H}
    }{
      \xlangstateeq{x\mapsto\loc_{\poison},\Delta;H'}{\Delta;H}
    }{cons-ignore-memstate-eq}
    %
    \judgbox{\src{H}\vdash^{n}_{\operatorname{skip}}\src{H'}}{,,Skip $n$ elements of $\mmlAs$ heap $\src{H}$, yielying $\src{H'}$.}\\
    %
    \typerule{$\src{H}$-skip-none}{
    }{
      \src{H}\vdash^{0}_{\operatorname{skip}}\src{H}
    }{heap-skip-none}
    %
    \typerule{$\src{H}$-skip-one}{
      \src{H}\vdash^{n}_{\operatorname{skip}}\src{H'}
    }{
      \src{m,H}\vdash^{n+1}_{\operatorname{skip}}\src{H'}
    }{heap-skip-one}
    %
    \judgbox{n\vdash\xlangstateeq[]{H}{H}}{,,Heap $\src{H}$ agrees with $\trg{H}$ over $n$ entries.''}\\
    %
    \typerule{$\src{H}$-agree-zero}{
    }{
      0\vdash\xlangstateeq[]{H}{H}
    }{heap-agree-zero}
    %
    \typerule{$\src{H}$-agree-cons}{
      \src{n}=\trg{n}&
      m\vdash\xlangstateeq[]{H}{H}
    }{
      m+1\vdash\xlangstateeq[]{n,H}{n,H}
    }{heap-agree-cons}
    %
    \judgbox{\xlangstateeq[]{\cfstate}{\cfstate}}{,,The $\mmlAs$ control-flow-state $\src{\cfstate}$ agrees with $\mmlAt$ one $\trg{\cfstate}$.''} \\
    %
    \typerule{cfstate-eq}{
      \src{\cfstate}=\src{\commlib;\library;\kontstack} &
      \trg{\cfstate}=\trg{\commlib;\library;\kontstack} \\
      \xlangstateeq[]{\library}{\library} &
      \xlangstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangstateeq[]{\cfstate}{\cfstate}
    }{cfstate-eq}$\;$\\
    %
    %
    \judgbox{\src{\poison}=\trg{\poison}}{,,$\mmlAs$ poison equals $\mmlAt$ one $\trg{\poison}$.''} \\
    %
    \typerule{$\poisoned$-equal}{
    }{
      \src{\poisoned}=\trg{\poisoned}
    }{poisoned-equal}
    %
    \typerule{$\poisonless$-equal}{
    }{
      \src{\poisonless}=\trg{\poisonless}
    }{poisonless-equal}
  \end{center}
}{tms-pres-state-relations}{State Relation from $\mmlAs$ to $\mmlAt$. This is meant to relate the states whenever we are ,,inside'' a component.}

\myfig{
  \begin{center}
    %
    \judgbox{\xlangstateeq[]{\library}{\library}}{,,The procedures of $\mmlAs$ agree with $\mmlAt$ ones.''} \\
    %
    \typerule{empty-commlib-lib-eq}{
    }{
      \xlangstateeq[]{\hole{\cdot}}{\library}
    }{empty-commlib-eq}
    %
    \typerule{cons-commlib-eq}{
      \mmlAmmlAtcomp{let\ foo\ x:\type_{\color{black}\lambda} := e} = \trg{let\ foo\ x := e} &
      \xlangstateeq[]{\library}{\library_1,\library_2}
    }{
      \xlangstateeq[]{(let\ foo\ x:\type_{\color{black}\lambda} := e),\library}{\library_1,(let\ foo\ x := e),\library_2}
    }{cons-commlib-eq}
    %
    %
    \judgbox{\xlangstateeq[]{\kontstack}{\kontstack}}{,,The stack of $\mmlAs$ continuations $\src{\kontstack}$ agrees with $\mmlAt$ one $\trg{\kontstack}$.''} \\
    %
    \typerule{empty-kontstack-eq}{
    }{
      \xlangstateeq[]{\hole{\cdot}}{\hole{\cdot}}
    }{empty-kontstack-eq}
    %
    \typerule{cons-kontstack-eq}{
      \src{\comm}=\trg{\comm} &
      \src{foo}=\trg{foo} &
      \xlangstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangstateeq[]{K^{foo}_{\comm},\kontstack}{K^{foo}_{\comm},\kontstack}
    }{cons-kontstack-eq}
  \end{center}
}{tms-pres-memstate-relations}{Memory-State Relations from $\mmlAs$ to $\mmlAt$.}

\myfig{
  \begin{center}
    \judgbox{\delta(\src{\loc})=\trg{\loc}}{,,The $\mmlAs$ memory location $\src{\loc}$ corresponds to\\the $\mmlAt$ memory location $\trg{\loc}$.''} \\
    \judgbox{\xlangbackstateeq{\Omega}{\Omega}}{,,The $\mmlAs$ state $\configs$ agrees with $\mmlAt$ state $\configt$. $\src{L}$ contains locations introduced\\by the backtranslation wrapper, which are subsequently ignored.''} \\
    %
    \typerule{state-qe}{
      \src{\Omega}=\src{\cfstate;\memstate} &
      \trg{\Omega}=\trg{\cfstate;\memstate} \\
      \xlangbackstateeq[]{\cfstate}{\cfstate} &
      \xlangbackstateeq{\memstate}{\memstate}
    }{
      \xlangbackstateeq{\Omega}{\Omega}
    }{state-qe}
    %
    \judgbox{\xlangbackstateeq{\memstate}{\memstate}}{,,The $\mmlAs$ memory-state $\src{\memstate}$ agrees with $\mmlAt$ one $\trg{\memstate}$. $\src{L}$ contains locations\\introduced by the backtranslation wrapper.''}\\
    %
    \typerule{memstate-qe}{
      \xlangstateeq{\memstate}{\memstate}
    }{
      \xlangbackstateeq{\memstate}{\memstate}
    }{memstate-qe}$\;$\\
    %
    %
    \judgbox{\xlangbackstateeq[]{\cfstate}{\cfstate}}{,,The $\mmlAs$ control-flow-state $\src{\cfstate}$ agrees with $\mmlAt$ one $\trg{\cfstate}$.''} \\
    %
    \typerule{cfstate-qe}{
      \src{\cfstate}=\src{\commlib;\library;\kontstack} &
      \trg{\cfstate}=\trg{\commlib;\library;\kontstack} \\
      \xlangstateeq[]{\library}{\library} &
      \xlangbackstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangbackstateeq[]{\cfstate}{\cfstate}
    }{cfstate-qe}
    %
    \judgbox{\xlangbackstateeq[]{\kontstack}{\kontstack}}{,,The stack of $\mmlAs$ continuations $\src{\kontstack}$ agrees with $\mmlAt$ one $\trg{\kontstack}$.}\\
    %
    \typerule{empty-kontstack-qe}{
    }{
      \xlangbackstateeq[]{\hole{\cdot}}{\hole{\cdot}}
    }{empty-kontstack-qe}
    %
    \typerule{cons-ctx-kontstack-qe}{
      \xlangbackstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangbackstateeq[]{K^{\overline{bars}}_{\overline{\nocomm}},K^{foo}_{\ctxtocomp},\kontstack}{K^{foo}_{\ctxtocomp},\kontstack}
    }{cons-ctx-kontstack-qe}
    %
    \typerule{cons-comp-kontstack-qe}{
      \xlangbackstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangbackstateeq[]{K^{foo}_{\comptoctx},\kontstack}{K^{foo}_{\comptoctx},\kontstack}
    }{cons-comp-kontstack-qe}
    %
    \typerule{cons-internal-kontstack-qe}{
      \xlangbackstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangbackstateeq[]{K^{foo}_{\nocomm},\kontstack}{K^{foo}_{\nocomm},\kontstack}
    }{cons-internal-kontstack-qe}
  \end{center}
}{tms-pres-state-relations}{State Relation from $\mmlAt$ to $\mmlAs$. This is meant to relate the states whenever we are ,,inside'' a context.}

\begin{lemma}[Trace Agreement with Filter]\label{lem:traceagreement:with:filter}
  If
  \begin{assumptions}
    \item $\xlangtraceeq{\trace}{\trace}$
    \item $\src{\comm}=\trg{\comm}$
  \end{assumptions}
  Then $\exists \delta_{MS}$
  \begin{goals}
    \item $\tospecificevs[_{\delta_{MS}}^{\src{\comm}}]{\trace}=\tospecificevt[_{\delta\circ\delta_{MS}}^{\trg{\comm}}]{\trace}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Compiler Injective]\label{lem:injective:comp}
  If
  \begin{assumptions}
    \item $\mmlAmmlAtcomp{e}=\trg{e}$
    \item $\mmlAmmlAtcomp{e}=\trg{e'}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\trg{e}=\trg{e'}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Step Forward Simulation]\label{lem:step:forwardsim}
  If
  \begin{assumptions}
    \item\label[ass]{asm:step:forwardsim:srcstep} $\exprevals{\Omega}{e}{\Omega'}{e'}{\event}$
    \item $\xlangstateeq{\Omega}{\Omega}$
    \item\label[ass]{asm:step:forwardsim:srccheck} $\typechecks{}{\Omega\triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
  \begin{goals}
    \item $\delta\subseteq\delta'$
    \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e'}}{\trg{\event}}$
    \item $\xlangeventeq{\event}{\event}$
    \item $\xlangstateeq{\Omega'}{\Omega'}$
  \end{goals}
\end{lemma}
\begin{proof}
  We proceed by induction on \Cref{asm:step:forwardsim:srcstep}.
  \begin{description}
    \item \textbf{Case $\exprevals{\Omega}{n_1+n_2}{\Omega}{n_3}{\varepsilon}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case1:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \item $\typechecks{}{\Omega\triangleright n_1+n_2}{\nat}$
      \item\label[ass]{asm:step:forwardsim:case1:additioneq} $n_3=n_1+n_2$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{n_1+n_2}}{\trg{\Omega'}}{\mmlAmmlAtcomp{n_3}}{\trg{\event}}$
        \item $\xlangeventeq{\varepsilon}{\event}$
        \item $\xlangstateeq{\Omega}{\Omega'}$
      \end{goals}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\Omega}$, and $\trg{\event}=\trg{\varepsilon}$, so that what is left to prove is:
      \begin{goals}
        \item\label[goal]{goal:step:forwardsim:case1:deltasubset} $\delta\subseteq\delta$
        \item\label[goal]{goal:step:forwardsim:case1:eval} $\expreval{\trg{\Omega}}{\trg{n_1+n_2}}{\trg{\Omega}}{\trg{n_3}}{\trg{\varepsilon}}$
        \item\label[goal]{goal:step:forwardsim:case1:eventeq} $\xlangeventeq{\varepsilon}{\varepsilon}$
        \item\label[goal]{goal:step:forwardsim:case1:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \end{goals}

      \Cref{goal:step:forwardsim:case1:deltasubset} follows immediately from reflexivity of the subset relation.

      \Cref{goal:step:forwardsim:case1:eval} follows using \Cref{tr:tw-e-oplus} and \Cref{asm:step:forwardsim:case1:additioneq}.

      \Cref{goal:step:forwardsim:case1:eventeq} follows using \Cref{tr:emptyevent-event-eq}.

      \Cref{goal:step:forwardsim:case1:stateeq} follows using \Cref{asm:step:forwardsim:case1:stateeq}.

    \item \textbf{Case $\exprevals{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{delete\ x}{\cfstate;H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}{0}{Dealloc\ \loc}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case2:stateeq} $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{\trg{\Omega}}$
      \item $\typechecks{}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2\triangleright delete\ x}{\nat}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{delete\ x}}{\trg{\Omega'}}{\mmlAmmlAtcomp{0}}{\trg{\event}}$
        \item $\xlangeventeq{Dealloc\ \loc}{\event}$
        \item $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}{\Omega'}$
      \end{goals}

      First note that $\trg{\Omega}=\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}$, otherwise we'd get a contradiction in \Cref{asm:step:forwardsim:case2:stateeq}.\MK{technical lemma needed}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}$, and $\trg{\event}=\trg{Dealloc\ \loc}$, so that what is left to prove is:
      \begin{goals}
      \item\label[goal]{goal:step:forwardsim:case2:deltasubset} $\delta\subseteq\delta$
      \item\label[goal]{goal:step:forwardsim:case2:eval} $\expreval{\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{\trg{delete\ x}}{\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}}{\trg{0}}{\trg{Dealloc\ \loc}}$
      \item\label[goal]{goal:step:forwardsim:case2:eventeq} $\xlangeventeq{Dealloc\ \loc}{Dealloc\ \loc}$
      \item\label[goal]{goal:step:forwardsim:case2:stateeq} $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}{\cfstate;H;\Delta_1,x\mapsto\loc_\poisoned,\Delta_2}$
      \end{goals}

      \Cref{goal:step:forwardsim:case2:deltasubset} follows immediately from reflexivity of the subset relation.

      \Cref{goal:step:forwardsim:case2:eval} follows using \Cref{tr:tw-e-delete}.

      For \Cref{goal:step:forwardsim:case2:eventeq}, apply \Cref{tr:dealloc-event-eq}, what is left to show is $\delta(\src{\loc})=\trg{\loc}$.

      Similarily for \Cref{goal:step:forwardsim:case2:stateeq}, apply \Cref{tr:state-eq,tr:cons-locmap-eq} ,,suitably''\MK{needs technical lemma: splitting} so that what is left to show is
      $\xlangstateeq{\cfstate}{\cfstate}$, $\xlangstateeq{H}{H}$, $\xlangstateeq{\Delta_1}{\Delta_1}$, $\xlangstateeq{\Delta_2}{\Delta_2}$, $\mmlAmmlAtcomp{x}=\trg{x}$, and, like in the previous case, $\delta(\src{\loc})=\trg{\loc}$.

      $\mmlAmmlAtcomp{x}=\trg{x}$ follows by definition of the compiler, anything else follows immediately by inverting \Cref{asm:step:forwardsim:case2:stateeq} ,,suitably''\MK{needs technical lemma: splitting}.

    \item \textbf{Case $\exprevals{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{x[n]}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{v}{Get\ \loc\ n}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case3:stateeq} $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{\Omega}$
      \item $\typechecks{}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2\triangleright x[n]}{\nat}$
      \item\label[ass]{asm:step:forwardsim:case3:dom1} $\src{\loc}\in\operatorname{dom} \src{H}\implies\src{v}=\src{H}(\src{\loc+n})$
      \item\label[ass]{asm:step:forwardsim:case3:dom2} $\src{\loc}\not\in\operatorname{dom} \src{H}\implies\src{v}=\src{1729}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{x[n]}}{\trg{\Omega'}}{\mmlAmmlAtcomp{v}}{\trg{\event}}$
        \item $\xlangeventeq{Get\ \loc\ n}{\event}$
        \item $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{\Omega'}$
      \end{goals}
      First note that $\trg{\Omega}=\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}$, otherwise we'd get a contradiction in \Cref{asm:step:forwardsim:case3:stateeq}.\MK{technical lemma needed}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}$, and $\trg{\event}=\trg{Get\ \loc\ n}$, so that what is left to prove is:
      \begin{goals}
      \item\label[goal]{goal:step:forwardsim:case3:deltasubset} $\delta\subseteq\delta$
        \setcounter{enumi}{2}
      \item\label[goal]{goal:step:forwardsim:case3:eventeq} $\xlangeventeq{Get\ \loc\ n}{Get\ \loc\ n}$
      \item\label[goal]{goal:step:forwardsim:case3:stateeq} $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}$
        \setcounter{enumi}{1}
      \item\label[goal]{goal:step:forwardsim:case3:eval} $\expreval{\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{\trg{x[n]}}{\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{\trg{v}}{\trg{Get\ \loc\ n}}$
      \end{goals}

      \Cref{goal:step:forwardsim:case3:deltasubset} follows immediately from reflexivity of the subset relation.

      For \Cref{goal:step:forwardsim:case3:eventeq}, invert \Cref{asm:step:forwardsim:case3:stateeq} ,,suitably''\MK{technical lemma needed: splitting} to obtain the assumption $\delta(\src{\loc})=\trg{\loc}$. The claim then follows by applying \Cref{tr:get-event-eq}.

      \Cref{goal:step:forwardsim:case3:stateeq} follows immediately from \Cref{asm:step:forwardsim:case3:stateeq}.

      \Cref{goal:step:forwardsim:case3:eval} is a bit technical. First apply \Cref{tr:tw-e-get-in,tr:tw-e-get-notin}, what is left to show is:
      \begin{goals}
        \setcounter{enumi}{4}
      \item $\trg{\loc}\in\operatorname{dom} \trg{H}\implies\trg{v}=\trg{H}(\trg{\loc+n})$
      \item $\trg{\loc}\not\in\operatorname{dom} \trg{H}\implies\trg{v}=\trg{1729}$
      \end{goals}

      Now, note that $\src{\loc}\in\operatorname{dom}\src{H}\Leftrightarrow\delta(\src{\loc})=\trg{\loc}\in\operatorname{dom}\trg{H}$.\MK{This is a technical lemma...}
      We continue with a case distinction.
      \begin{description}
        \item \textbf{Case $\src{\loc}\in\operatorname{dom}\src{H}$:}

          \Cref{asm:step:forwardsim:case3:dom1} gives $\src{v}=\src{H}(\src{\loc+n})$.
          Since $\trg{v}=\mmlAmmlAtcomp{v}$, $\trg{v}=\mmlAmmlAtcomp{H(\loc+n)}$.
          Using \Cref{asm:step:forwardsim:case3:stateeq}\MK{technical lemma}, $\trg{v}=\trg{H(\loc+n)}$, done.

        \item \textbf{Case $\src{\loc}\not\in\operatorname{dom}\src{H}$:}

          \Cref{asm:step:forwardsim:case3:dom2} gives $\src{v}=\src{1729}$.
          Since $\trg{v}=\mmlAmmlAtcomp{v}$, $\trg{v}=\mmlAmmlAtcomp{1729}=\trg{1729}$, done.
      \end{description}

    \item \textbf{Case $\exprevals{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{x[n]\leftarrow v}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{v}{Set\ \loc\ n}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case4:stateeq} $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{\Omega}$
      \item $\typechecks{}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2\triangleright x[n]}{\nat}$
      \item\label[ass]{asm:step:forwardsim:case4:update} $\src{H'}=\src{H}(\src{\loc+n}\mapsto\src{v})$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{x[n]\leftarrow v}}{\trg{\Omega'}}{\mmlAmmlAtcomp{v}}{\trg{\event}}$
        \item $\xlangeventeq{Set\ \loc\ n}{\event}$
        \item $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{\Omega'}$
      \end{goals}
      First note that $\trg{\Omega}=\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}$, otherwise we'd get a contradiction in \Cref{asm:step:forwardsim:case4:stateeq}.\MK{technical lemma needed}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}$, and $\trg{\event}=\trg{Set\ \loc\ n}$, so that what is left to prove is:
      \begin{goals}
      \item\label[goal]{goal:step:forwardsim:case4:deltasubset} $\delta\subseteq\delta$
      \item\label[goal]{goal:step:forwardsim:case4:eval} $\expreval{\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{\trg{x[n]\leftarrow v}}{\trg{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}}{\trg{v}}{\trg{Set\ \loc\ n}}$
      \item\label[goal]{goal:step:forwardsim:case4:eventeq} $\xlangeventeq{Set\ \loc\ n}{Set\ \loc\ n}$
      \item\label[goal]{goal:step:forwardsim:case4:stateeq} $\xlangstateeq{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}{\cfstate;H;\Delta_1,x\mapsto\loc_\poison,\Delta_2}$
      \end{goals}

      \Cref{goal:step:forwardsim:case4:deltasubset} follows immediately from reflexivity of the subset relation.

      For \Cref{goal:step:forwardsim:case4:eval}, apply \Cref{tr:tw-e-set}.
      What is left to prove is $\trg{H'} = \trg{H}(\trg{\loc+n}\mapsto \trg{v})$.
      This follows by \Cref{asm:step:forwardsim:case4:stateeq}.\MK{technical lemma: compatibility with update}

      Apply \Cref{tr:set-event-eq} on \Cref{goal:step:forwardsim:case4:eventeq}, what is left to show is $\mmlAmmlAtcomp{n}=\trg{n}$, which is trivial, and $\delta(\src{\loc})=\trg{\loc}$.
      The latter can be obtained by a ,,suitable''\MK{technical lemma needed} inversion of \Cref{asm:step:forwardsim:case4:stateeq}.

      \Cref{goal:step:forwardsim:case4:stateeq} is assumed in \Cref{asm:step:forwardsim:case4:stateeq}.

    \item \textbf{Case $\exprevals{\cfstate;H;\Delta}{let\ x\ =\ new\ n\ in\ e}{\cfstate;H';z\mapsto\loc_\poisonless,\Delta}{e[z/x]}{Alloc\ \loc\ n}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case5:stateeq} $\xlangstateeq{\cfstate;H;\Delta}{\Omega}$
      \item $\typechecks{}{\cfstate;H;\Delta\triangleright let\ x\ =\ new\ n\ in\ e}{\nat}$
      \item\label[ass]{asm:step:forwardsim:case5:update} $\src{H'}=\src{H}\ll\src{n}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{let\ x\ =\ new\ n\ in\ e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e[z/x]}}{\trg{\event}}$
        \item $\xlangeventeq{Alloc\ \loc\ n}{\event}$
        \item $\xlangstateeq{\cfstate;H;z\mapsto\loc_\poisonless,\Delta}{\Omega'}$
      \end{goals}
      First note that $\trg{\Omega}=\trg{H;z\mapsto\loc_\poisonless,\Delta}$, otherwise we'd get a contradiction in \Cref{asm:step:forwardsim:case5:stateeq}.\MK{technical lemma needed}

      Instantiate the goal with $\delta'=\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\},\ \trg{\Omega'}=\trg{\cfstate;H;z\mapsto\loc_\poisonless,\Delta}$, and $\trg{\event}=\trg{Alloc\ \loc\ n}$, so that what is left to prove is:

      \begin{goals}
      \item\label[goal]{goal:step:forwardsim:case5:deltasubset} $\delta\subseteq\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\}$
    \item\label[goal]{goal:step:forwardsim:case5:eval} $\expreval{\trg{\cfstate;H;\Delta}}{\trg{let\ x\ =\ new\ n\ in\ }\mmlAmmlAtcomp{e}}{\trg{\cfstate;H;z\mapsto\loc_\poisonless,\Delta}}{\mmlAmmlAtcomp{e}\trg{[z/x]}}{\trg{Alloc\ \loc\ n}}$
      \item\label[goal]{goal:step:forwardsim:case5:eventeq} $\xlangeventeq[\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\}]{Alloc\ \loc\ n}{Alloc\ \loc\ n}$
      \item\label[goal]{goal:step:forwardsim:case5:stateeq} $\xlangstateeq[\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\}]{\cfstate;H;z\mapsto\loc_\poisonless,\Delta}{\cfstate;H;z\mapsto\loc_\poisonless,\Delta}$
      \end{goals}

      \Cref{goal:step:forwardsim:case5:deltasubset} follows by rewriting it as $\forall x, x\in\delta\implies x\in\delta\vee x\in\left\{\src{\loc}\mapsto\trg{\loc}\right\}$, then just choose the left side of the disjunction.

      Apply \Cref{tr:tw-e-let-new} on \Cref{goal:step:forwardsim:case5:eval}, what is left to show is $\trg{H'} = \trg{H} \ll \trg{n}$.
      This follows by \Cref{asm:step:forwardsim:case5:stateeq}.\MK{technical lemma: compatibility with grow}

      Apply \Cref{tr:set-event-eq} on \Cref{goal:step:forwardsim:case5:eventeq}, what is left to show is $\mmlAmmlAtcomp{n}=\trg{n}$, follows immediately by definition of the compiler, and $(\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\})(\src{\loc})=\trg{\loc}$, which follows by definition.

      Apply \Cref{tr:state-eq,tr:cons-locmap-eq} on \Cref{goal:step:forwardsim:case5:stateeq}, what is left to show is $\mmlAmmlAtcomp{x}=\trg{x}$, follows immediately by definition of the compiler, and $(\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\})(\src{\loc})=\trg{\loc}$, which follows by definition.

    \item \textbf{Case $\exprevals{\Omega}{abort()}{\lightning}{stuck}{\lightning}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case6:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \item\label[ass]{asm:step:forwardsim:case6:typechecks} $\typechecks{}{\Omega\triangleright abort()}{\nat}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{abort()}}{\trg{\Omega'}}{\mmlAmmlAtcomp{stuck}}{\trg{\event}}$
        \item $\xlangeventeq{\lightning}{\event}$
        \item $\xlangstateeq{\lightning}{\Omega'}$
      \end{goals}

      Inverting \Cref{asm:step:forwardsim:case6:typechecks} yields a contradiction.

    \item \textbf{Case $\exprevals{\Omega}{let\ x=y\ in\ e}{\Omega}{e[y/x]}{\varepsilon}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case7:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \item $\typechecks{}{\Omega\triangleright let\ x\ = y\ in\ e}{\nat}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{let\ x\ = y\ in\ e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e[y/x]}}{\trg{\event}}$
        \item $\xlangeventeq{\varepsilon}{\event}$
        \item $\xlangstateeq{\Omega}{\Omega'}$
      \end{goals}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\Omega}$, and $\trg{\event}=\trg{\varepsilon}$, so that what is left to prove is:

      \begin{goals}
        \item\label[goal]{goal:step:forwardsim:case7:deltasubset} $\delta\subseteq\delta$
        \item\label[goal]{goal:step:forwardsim:case7:eval} $\expreval{\trg{\Omega}}{\trg{let\ x\ = y\ in\ }\mmlAmmlAtcomp{e}}{\trg{\Omega}}{\mmlAmmlAtcomp{e}\trg{[y/x]}}{\trg{\varepsilon}}$
        \item\label[goal]{goal:step:forwardsim:case7:eventeq} $\xlangeventeq{\varepsilon}{\varepsilon}$
        \item\label[goal]{goal:step:forwardsim:case7:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \end{goals}

      \Cref{goal:step:forwardsim:case7:deltasubset} follows by reflexivity of the subset relation.

      \Cref{goal:step:forwardsim:case7:eval} follows by definition of \Cref{tr:tw-e-let-x}.

      \Cref{goal:step:forwardsim:case7:eventeq} follows by definition of \Cref{tr:emptyevent-event-eq}.

      \Cref{goal:step:forwardsim:case7:stateeq} follows by \Cref{asm:step:forwardsim:case7:stateeq}.

    \item \textbf{Case $\exprevals{\Omega}{let\ x=v\ in\ e}{\Omega}{e[v/x]}{\varepsilon}$:}

      This case is completely analogous to the previous case.

    \item \textbf{Case $\exprevals{\Omega}{ifz\ 0\ then\ e_1\ else\ e_2}{\Omega}{e_1}{\varepsilon}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case9:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \item $\typechecks{}{\Omega\triangleright ifz\ 0\ then\ e_1\ else\ e_2}{\nat}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{ifz\ 0\ then\ e_1\ else\ e_2}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e_1}}{\trg{\event}}$
        \item $\xlangeventeq{\varepsilon}{\event}$
        \item $\xlangstateeq{\Omega}{\Omega'}$
      \end{goals}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\Omega}$, and $\trg{\event}=\trg{\varepsilon}$, so that what is left to prove is:

      \begin{goals}
        \item\label[goal]{goal:step:forwardsim:case9:deltasubset} $\delta\subseteq\delta$
        \item\label[goal]{goal:step:forwardsim:case9:eval} $\expreval{\trg{\Omega}}{\trg{ifz\ 0\ then\ }\mmlAmmlAtcomp{e_1}\trg{\ else\ }\mmlAmmlAtcomp{e_2}}{\trg{\Omega}}{\mmlAmmlAtcomp{e_1}}{\trg{\varepsilon}}$
        \item\label[goal]{goal:step:forwardsim:case9:eventeq} $\xlangeventeq{\varepsilon}{\varepsilon}$
        \item\label[goal]{goal:step:forwardsim:case9:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \end{goals}

      \Cref{goal:step:forwardsim:case9:deltasubset} follows by reflexivity of the subset relation.

      \Cref{goal:step:forwardsim:case9:eval} follows by definition of \Cref{tr:tw-e-if-true}.

      \Cref{goal:step:forwardsim:case9:eventeq} follows by definition of \Cref{tr:emptyevent-event-eq}.

      \Cref{goal:step:forwardsim:case9:stateeq} follows by \Cref{asm:step:forwardsim:case9:stateeq}.

    \item \textbf{Case $\exprevals{\Omega}{ifz\ S(n)\ then\ e_1\ else\ e_2}{\Omega}{e_2}{\varepsilon}$:}

      This case is completely analogous to the previous case, the only difference is the use of \Cref{tr:tw-e-if-false} instead of \Cref{tr:tw-e-if-true}.

  \end{description}
\end{proof}


\begin{lemma}[Ctx Step Forward Simulation]\label{lem:ctxstep:forwardsim}
  If
  \begin{assumptions}
    \item\label[ass]{asm:ctxstep:forwardsim:srcstep} $\execs[]{\Omega}{e}{\Omega'}{e'}{\event}$
    \item\label[ass]{asm:ctxstep:forwardsim:staterel} $\xlangstateeq{\Omega}{\Omega}$
    \item\label[ass]{asm:ctxstep:forwardsim:typechecks} $\typechecks{}{\Omega\triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
  \begin{goals}
    \item $\delta\subseteq\delta'$
    \item $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e'}}{\trg{\event}}$
    \item $\xlangeventeq{\event}{\event}$
    \item $\xlangstateeq{\Omega'}{\Omega'}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
% Induction on \Cref{asm:ctxstep:forwardsim:srcstep}:

% If
% \begin{passumptions}{H}
%   \item\label[ass]{asm:ctxstep:forwardsim:nocrash} $\src{\Omega}\not=\src{\lightning}$
%   \item\label[ass]{asm:ctxstep:forwardsim:simplestep} $\exprevals{\Omega}{e_{0}}{\Omega'}{e_{0}'}{\event}$
% \end{passumptions}
% Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
% \begin{goals}
%   \item $\delta\subseteq\delta'$
%   \item $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{K[e_{0}]}}{\trg{\Omega'}}{\mmlAmmlAtcomp{K[e_{0}']}}{\trg{\event}}$
%   \item $\xlangeventeq{\event}{\event}$
%   \item $\xlangstateeq{\Omega'}{\Omega'}$
% \end{goals}

% We augment \Cref{asm:ctxstep:forwardsim:typechecks} using \Thmref{lem:ctxtyping:plugged}.
% \begin{passumptions}{H}
%   \setcounter{enumi}{2}
%   \item\label[ass]{asm:ctxstep:forwardsim:e0typechecks} $\typechecks{}{\Omega\triangleright e_{0}}{\nat}$
% \end{passumptions}
% Withg \Cref{asm:ctxstep:forwardsim:simplestep,asm:ctxstep:forwardsim:staterel,asm:ctxstep:forwardsim:e0typechecks} use \Thmref{lem:step:forwardsim} to get witnesses $\delta', \trg{\Omega'},$ and $\trg{\event}$ such that:

% \begin{passumptions}{F}
%   \item\label[ass]{asm:ctxstep:forwardsim:f1} $\delta\subseteq\delta'$
%   \item\label[ass]{asm:ctxstep:forwardsim:trgstep} $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e_{0}'}}{\trg{\event}}$
%   \item\label[ass]{asm:ctxstep:forwardsim:f3} $\xlangeventeq{\event}{\event}$
%   \item\label[ass]{asm:ctxstep:forwardsim:f4} $\xlangstateeq{\Omega'}{\Omega'}$
% \end{passumptions}

% Immediately instantiate our goal with those witnesses and use \Cref{asm:ctxstep:forwardsim:f1,asm:ctxstep:forwardsim:f3,asm:ctxstep:forwardsim:f4}.
% What is left to prove is
% \begin{goals}
%   \setcounter{enumi}{1}
%   \item $\exec[]{\trg{\Omega}}{\trg{K[}\mmlAmmlAtcomp{e_{0}}\trg{]}}{\trg{\Omega'}}{\trg{K[}\mmlAmmlAtcomp{e_{0}'}\trg{]}}{\trg{\event}}$
% \end{goals}
% Use \Cref{tr:tw-e-ectx}, what is left to show is
% \begin{goals}
%   \setcounter{enumi}{4}
%   \item\label[ass]{goal:ctxstep:forwardsim:nocrash} $\trg{\Omega}\not=\trg{\lightning}$
%   \item\label[goal]{goal:ctxstep:forwardsim:trgstep} $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e_{0}'}}{\trg{\event}}$
% \end{goals}
% \Cref{goal:ctxstep:forwardsim:trgstep} follows immediately by \Cref{asm:ctxstep:forwardsim:trgstep}.
% For \Cref{goal:ctxstep:forwardsim:nocrash}, we can use \Thmref{lem:relatednoncrash} relying on \Cref{asm:ctxstep:forwardsim:staterel,asm:ctxstep:forwardsim:nocrash}.
\end{incompleteproof}

\begin{lemma}[Forward Simulation]\label{lem:forwardsim}
  If
  \begin{assumptions}
    \item\label[ass]{asm:forwardsim:starstep} $\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$
    \item\label[ass]{asm:forwardsim:staterel} $\xlangstateeq{\Omega}{\Omega}$
    \item\label[ass]{asm:forwardsim:typechecks} $\typechecks{}{\Omega\triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists\delta'\ \trg{\Omega'}\ \trg{\trace}$,
  \begin{goals}
    \item $\delta\subseteq\delta'$
    \item $\exec{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace}}$
    \item $\xlangtraceeq[\delta']{\trace}{\trace}$
    \item $\xlangstateeq[\delta']{\Omega'}{\Omega'}$
  \end{goals}
\end{lemma}
\begin{proof}
  Induction on \Cref{asm:forwardsim:starstep}.
  \begin{description}
    \item \textbf{Case }$\execs{\Omega}{\finalexpr}{\Omega}{\finalexpr}{\hole{\cdot}}$\textbf{:}
          Trivial. Witnesses are $\delta, \trg{\Omega}$, and $\trg{\hole{\cdot}}$, goals follow immediately by reflexivity of the respective relation.

    \item \textbf{Cases }$\execs{\Omega}{e}{\Omega}{\finalexpr}{\event\cdot\trace}$ (\Cref{tr:ws-e-trans-important})\textbf{ and }\\$\execs{\Omega}{e}{\Omega}{\finalexpr}{\trace}$ (\Cref{tr:ws-e-trans-unimportant})\textbf{:}
          \begin{passumptions}{H}
            \item\label[ass]{asm:forwardsim:evnoteps} $\src{a}\not=\src{\varepsilon}$ (provided only in the case of \Cref{tr:ws-e-trans-important})
            \item\label[ass]{asm:forwardsim:ctxstep} $\execs[]{\Omega}{e}{\Omega_{0}}{e_0}{\event}$
            \item $\execs{\Omega_{0}}{e_0}{\Omega'}{\finalexpr}{\trace}$
          \end{passumptions}
          With the inductive hypothesis: $\forall\delta_{\forall}\ \trg{\Omega_{\forall}},\exists \delta_{\IH}\ \trg{\Omega_{\IH}}\ \trg{\trace[_{\IH}]},$
          \begin{passumptions}{\IH}
            \item $\delta_{\forall}\subseteq\delta_{\IH}$
            \item $\exec{\trg{\Omega_{\forall}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega_{{\IH}}}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace[_{{\IH}}]}}$
            \item\label[ass]{asm:forwardsim:justraceeq} $\xlangtraceeq[\delta_{\IH}]{\trace}{\trace[_{\IH}]}$
            \item $\xlangstateeq[\delta_{\IH}]{\Omega_{0}}{\Omega_{\IH}}$
          \end{passumptions}

          Now apply \Thmref{lem:ctxstep:forwardsim} on \Cref{asm:forwardsim:ctxstep} using \Cref{asm:forwardsim:staterel,asm:forwardsim:typechecks},
          giving us witnesses $\delta_0\ \trg{\Omega_{0}}\ \trg{\event}$,
          \begin{passumptions}{F}
            \item\label[ass]{asm:forwardsim:deltasubset0} $\delta\subseteq\delta_{0}$
            \item\label[ass]{asm:forwardsim:thectxstep} $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega_{0}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\event}}$
            \item\label[ass]{asm:forwardsim:eventeq} $\xlangeventeq[\delta_{0}]{\event}{\event}$
            \item $\xlangstateeq[\delta_{0}]{\Omega_{0}}{\Omega_{0}}$
          \end{passumptions}

          Instantiate the inductive hypothesis with $\delta_{\forall}=\delta_{0}$ and $\trg{\Omega_{\forall}}=\trg{\Omega_{0}}$ and obtain witnesses
          $\delta_{\IH}, \trg{\Omega_{\IH}}$, and $\trg{\trace[_{\IH}]}$ such that:
          \begin{passumptions}{\IH'}
            \item\label[ass]{asm:forwardsim:deltasubset:IH} $\delta_{0}\subseteq\delta_{\IH}$
            \item\label[ass]{asm:forwardsim:steps} $\exec{\trg{\Omega_{0}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega_{{\IH}}}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace[_{{\IH}}]}}$
            \item $\xlangtraceeq[\delta_{\IH}]{\trace}{\trace[_{\IH}]}$
            \item $\xlangstateeq[\delta_{\IH}]{\Omega_{0}}{\Omega_{\IH}}$
          \end{passumptions}

          \begin{description}
            \item \textbf{Case $\src{\event}\not=\src{\varepsilon}$:}
                Our goal looks as follows: $\exists \delta'\ \trg{\Omega'}\ \trg{\trace}$,
                \begin{goals}
                  \item\label[goal]{goal:forwardsim:deltasubset} $\delta\subseteq\delta'$
                  \item\label[goal]{goal:forwardsim:steps} $\exec{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace}}$
                  \item\label[goal]{goal:forwardsim:traceeq} $\xlangtraceeq{\event\cdot\trace}{\trace'}$
                  \item\label[goal]{goal:forwardsim:staterel} $\xlangstateeq{\Omega'}{\Omega'}$
                \end{goals}

                Instantiate the goal with $\delta_{\IH}, \trg{\Omega_{\IH}}, \trg{\event\cdot\trace}$.
                Note that $\delta\subseteq\delta_{\IH}$ (\Cref{goal:forwardsim:deltasubset}) follows by transitivity using \Cref{asm:forwardsim:deltasubset0,asm:forwardsim:deltasubset:IH}.
                Similarily for \Cref{goal:forwardsim:staterel}.\MK{technical lemma...}

                Apply \Cref{tr:wt-e-trans-important} on \Cref{goal:forwardsim:steps}. So, what is left to show is
                \begin{goals}
                  \setcounter{enumi}{2}
                  \item\label[goal]{goal:forwardsim:tracerel} $\xlangtraceeq{\event\cdot\trace}{\event\cdot\trace}$
                  \setcounter{enumi}{4}
                  \item\label[goal]{goal:forwardsim:noeps:ctxstep} $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega_{0}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\event}}$
                  \item\label[goal]{goal:forwardsim:noeps:steps} $\exec{\trg{\Omega_{0}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega_{\IH}}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace}}$
                \end{goals}
                \Cref{goal:forwardsim:tracerel} follows from \Cref{asm:forwardsim:justraceeq,asm:forwardsim:eventeq} using \Cref{tr:cons-trace-eq}.
                \Cref{goal:forwardsim:noeps:ctxstep} is proven by \Cref{asm:forwardsim:thectxstep}.
                \Cref{goal:forwardsim:noeps:steps} is proven by \Cref{asm:forwardsim:steps}.
            \item \textbf{Case $\src{\event}=\src{\varepsilon}$:}
                Similar to the other case, but make use of \Cref{asm:forwardsim:evnoteps}.
          \end{description}
  \end{description}
\end{proof}

\begin{lemma}[Different Reduction]\label{lem:differentreduction}
  If
  \begin{assumptions}
    \item\label[ass]{asm:differentreduction:nored} $\neg\left(\execs{\Omega}{e}{\Omega'}{\valueexpr}{\trace}\right)$
    \item\label[ass]{asm:differentreduction:red} $\execs{\Omega}{e}{\Omega'}{\valueexpr'}{\trace}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\src{\valueexpr}\not=\src{\valueexpr'}$
  \end{goals}
\end{lemma}
\begin{proof}
  Assume $\src{v}=\src{v'}$, apply \Cref{asm:differentreduction:nored} to the goal $\bot$, rewrite in the goal using $\src{v}=\src{v'}$ and solve the goal by \Cref{asm:differentreduction:red}.
\end{proof}


\clearpage
\begin{lemma}[$\mmlAs$ call at $\mmlAt$ level finishes]\label{lem:trg:callfinishes}
  If
  \begin{assumptions}
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $(\src{let\ foo\ x:\type_{\color{black}\lambda}:=e_{foo}})\in\src{\Omega.\library_{comp}}$
  \item $\trg{foo}=\mmlAmmlAtcomp{foo}$
  \item $\typechecks{}{\Omega\triangleright call\ foo\ \interfacevalue}{\type}$
  \item $\exec[]{\trg{\commlib;\library;\kontstack;\memstate}}{\trg{K[}\mmlAmmlAtcomp{call\ foo\ \interfacevalue}\trg{]}}{\trg{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate}}{\mmlAmmlAtcomp{e_{foo}[\interfacevalue/x]}}{\trg{Call\ \hat{\comm}\ foo\ \interfacevalue}}$
  \item $\xlangstateeq{\Omega}{\commlib;\library;\kontstack;\memstate}$
  \end{assumptions}
  Then $\exists \delta'\ n\ m\ \trg{\memstate'}\ \trg{\interfacevalue'}\ \src{\Omega'}$,
  \begin{goals}
    \item $\delta\subseteq\delta'$
    \item $\exec[^{m}]{\trg{\commlib;\library;K^{foo}_{\comm},\kontstack;\memstate}}{\mmlAmmlAtcomp{e_{foo}[\interfacevalue/x]}}{\trg{\commlib;\library;\kontstack;\memstate'}}{\trg{K[\interfacevalue']}}{\trg{\trace}}$
    \item $\exec[^{n}]{\src{\Omega}}{\src{call\ foo\ \interfacevalue}}{\src{\Omega'}}{\src{K[\interfacevalue']}}{\src{\trace}}$
    \item $\xlangstateeq[\delta',\src{L}]{\Omega'}{\commlib;\library;\kontstack;\memstate'}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
  .\MK{split this lemma into two parts: one red call-decomposition and the other one is generalized (substitutions) forward-sim with step-indices}
\end{incompleteproof}

\begin{lemma}[Expression Correctness]\label{lem:expression:correctness}
  If
  \begin{assumptions}
  \item\label[ass]{asm:exprcorrect:exec1:trg} $\exec{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace}}$
  \item\label[ass]{asm:exprcorrect:stateeq} $\xlangstateeq{\Omega}{\Omega}$
  \item\label[ass]{asm:expr:corr:typechecks} $\typechecks{}{\Omega\triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists \delta'\ \src{\Omega'}\ \src{\trace}$,
  \begin{goals}
  \item $\delta\subseteq\delta'$
  \item $\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$
  \item $\xlangstateeq[\delta']{\Omega'}{\Omega'}$
  \item $\xlangtraceeq[\delta']{\trace}{\trace}$
  \end{goals}
\end{lemma}
\begin{proof}
  We prove this by contradiction. So, we get the assumption:
  \begin{passumptions}{I}
    \item\label[ass]{asm:exprcorr:toplevel} $\forall\delta'\ \src{\Omega'}\ \src{\trace},\delta'\subset\delta\vee\neg\left(\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}\right)\vee\xlangstateneq[\delta']{\Omega'}{\Omega'}\vee\xlangtraceneq[\delta']{\trace}{\trace}$
  \end{passumptions}
  and need to prove $\bot$.
  Apply \Thmref{lem:progress} on \Cref{asm:expr:corr:typechecks}, so:
  \begin{passumptions}{I}
    \setcounter{enumi}{1}
    \item\label[ass]{asm:exprcorr:progressor} $\src{e}=\src{\valueexpr}$ or $\exists\src{\Omega'}\ \src{\valueexpr}\ \src{\trace},\execs{\Omega}{e}{\Omega'}{\valueexpr}{\trace}$
  \end{passumptions}
  Proceed by case anaylsis on \Cref{asm:exprcorr:progressor}.
  \begin{description}
    \item \textbf{Case $\src{e}=\src{\valueexpr}$:}
      Specialize \Cref{asm:exprcorr:toplevel} for $\delta'=\delta$, $\src{\Omega'}=\src{\Omega},$ and $\src{\trace}=\src{\hole{\cdot}}$.
      We proceed by case analysis:

      Invert \Cref{asm:exprcorrect:exec1:trg} and proceed by case analysis:
      \begin{description}
        \item \textbf{Case $\delta\subset\delta$:} Trivial.
        \item \textbf{Case }$\neg\left(\execs{\Omega}{\valueexpr}{\Omega}{\valueexpr}{\hole{\cdot}}\right)$\textbf{:}
            Simply apply $\neg\left(\execs{\Omega}{\valueexpr}{\Omega}{\valueexpr}{\hole{\cdot}}\right)$ to the goal $\bot$ and use \Cref{tr:ws-e-refl}.
        \item \textbf{Case }$\xlangstateneq{\Omega}{\Omega}$\textbf{:}
            Apply $\xlangstateneq{\Omega}{\Omega}$ to the goal $\bot$ and use \Cref{asm:exprcorrect:stateeq}.
        \item \textbf{Case }$\xlangtraceneq{\hole{\cdot}}{\hole{\cdot}}$\textbf{:}
            Apply $\xlangtraceneq{\hole{\cdot}}{\hole{\cdot}}$ to the goal $\bot$, use \Cref{tr:empty-trace-eq}.
      \end{description}

    \item \textbf{Case }$\exists\src{\Omega'}\ \src{\valueexpr}\ \src{\trace},\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$\textbf{:}
          First extract the witnesses and obtain:
          \begin{passumptions}{H}
            \item\label[ass]{asm:exprcorr:ereduce} $\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$
          \end{passumptions}


          Apply \Thmref{lem:forwardsim} to \Cref{asm:exprcorr:ereduce} with \Cref{asm:exprcorrect:stateeq,asm:expr:corr:typechecks} to get:
          \begin{passumptions}{F}
            \item\label[ass]{asm:exprcorrect:deltavsubset} $\delta\subseteq\delta_{v}$
            \item\label[ass]{asm:exprcorrect:exec2:trg} $\exec{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega_{v}'}}{\mmlAmmlAtcomp{\valueexpr}}{\trg{\trace[_{v}]}}$
            \item\label[ass]{asm:exprcorrect:stateeq2} $\xlangstateeq[\delta_{v}]{\Omega'}{\Omega_{v}'}$
            \item\label[ass]{asm:exprcorrect:traceeq2} $\xlangtraceeq[\delta_{v}]{\trace}{\trace[_{v}]}$
          \end{passumptions}


          Use \Thmref{lem:determ:steps} on \Cref{asm:exprcorrect:exec1:trg,asm:exprcorrect:exec2:trg}, giving us:
          \begin{passumptions}{K}
            \item\label[ass]{asm:exprcorrect:compiledvalueseq} $\mmlAmmlAtcomp{v}=\mmlAmmlAtcomp{f}$
            \item\label[ass]{asm:exprcorrect:stateequal} $\trg{\Omega'}=\trg{\Omega_{v}'}$
            \item\label[ass]{asm:exprcorrect:traceequal} $\trg{\trace}=\trg{\trace[_{v}]}$
          \end{passumptions}
          Rewrite using \Cref{asm:exprcorrect:stateequal} in \Cref{asm:exprcorrect:stateeq2}, similarily \Cref{asm:exprcorrect:traceequal} in \Cref{asm:exprcorrect:traceeq2}:
          \begin{passumptions}{F'}
            \setcounter{enumi}{2}
            \item\label[ass]{asm:exprcorrect:stateeq3} $\xlangstateeq[\delta_{v}]{\Omega'}{\Omega'}$
            \item\label[ass]{asm:exprcorrect:traceeq3} $\xlangtraceeq[\delta_{v}]{\trace}{\trace}$
          \end{passumptions}
      Specialize \Cref{asm:exprcorr:toplevel} for $\delta'=\delta_{v}$, $\src{\Omega'}=\src{\Omega'},$ and $\src{\trace}=\src{\trace}$.
      We proceed by case analysis:
      \begin{description}
        \item \textbf{Case $\neg\left(\delta\subseteq\delta_{v}\right)$:} Apply $\neg\left(\delta\subseteq\delta_{v}\right)$ on our goal $\bot$, then $\delta\subseteq\delta_{v}$ immediately follows from \Cref{asm:exprcorrect:deltavsubset}.

        \item \textbf{Case }$\neg\left(\execs{\Omega}{e}{\Omega'}{\valueexpr}{\trace}\right)$\textbf{:}
          Using \Cref{asm:exprcorr:ereduce} and the assumption $\neg\left(\execs{\Omega}{e}{\Omega'}{\valueexpr}{\trace}\right)$, we conclude $\src{\valueexpr}\not=\src{f}$ using \Thmref{lem:differentreduction}.
          Apply \Thmref{lem:injective:comp} on \Cref{asm:exprcorrect:compiledvalueseq}, so $\src{\valueexpr}=\src{f}$, contradicting the above.

        \item \textbf{Case }$\xlangstateneq[\delta_{v}]{\Omega'}{\Omega'}$\textbf{:} Immediate contradiction with \Cref{asm:exprcorrect:stateeq3}.
        \item \textbf{Case }$\xlangtraceneq[\delta_{v}]{\trace}{\trace}$\textbf{:} Immediate contradiction with \Cref{asm:exprcorrect:traceeq3}.
      \end{description}
  \end{description}
\end{proof}

\begin{lemma}[Component-based Expression Correctness]\label{lem:component:correctness}
  If
  \begin{assumptions}
  \item $\exec{\trg{\cfstate;\memstate}}{\mmlAmmlAtcomp{e}}{\trg{\cfstate;\memstate'}}{\mmlAmmlAtcomp{K_{component}\hole{return\ \finalexprnoerr}}}{\trg{\trace}}$
  \item $\trg{\cfstate}=\trg{\commlib;\library;K^{foo}_{\comptoctx},\overline{K}}$
  \item $\xlangstateeq{\Omega}{\cfstate;\memstate}$
  \item $\typechecks{}{\Omega \triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists \delta'\ \src{\Omega'}\ \src{\trace}$,
  \begin{goals}
  \item $\delta\subseteq\delta'$
  \item $\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$
  \item $\xlangstateeq[\delta';\src{L}]{\Omega'}{\cfstate;\memstate'}$
  \item $\xlangtraceeq[\delta';\src{X}]{\trace}{\trace}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\subsubsection{Trace-based Backtranslation}

\myfig{
  \begin{center}
    \judgbox{\Game(\trg{\loc}) = \src{x}}{,,Map from $\mmlAt$ locations to $\mmlAs$ variable names.''}
    \judgbox{\Game[\trg{\loc}] = \Game'}{,,Extend $\Game$ with $\trg{\loc}$ and call the extension $\Game'$.''}
    \typerule{backtrans-create-symb}{
      \trg{\loc}\not\in\operatorname{dom}\Game &
      \fresh{\Game}{\src{x}} &
    }{
      \Game'[\trg{\loc}]=\Game\cup\left\{\trg{\loc}\mapsto\src{x}\right\}
    }{backtrans-create-symb}
    \typerule{backtrans-nocreate-symb}{
      \trg{\loc}\in\operatorname{dom}\Game &
    }{
      \Game'[\trg{\loc}]=\Game
    }{backtrans-nocreate-symb}
    %
    \typerule{backtrans-lookup-symb}{
      \trg{\loc}\in\operatorname{dom}\Game
    }{
      \Game(\trg{\loc}) = \src{x}
    }{backtrans-lookup-symb}
  \end{center}
}{backtrans-locs-to-var}{\varmapbacktransds to keep track of $\mmlAt$ locations and $\mmlAs$ variables.}

\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtbackv{\interfacevalue} = \src{\interfacevalue}}{,,Map an $\mmlAt$ interface value to an $\mmlAs$ interface value.''}$\;$\\
    \typerule{backtrans-value}{
    }{
      \mmlAmmlAtbackv{n} = \src{n}
    }{backtrans-value}
    \typerule{backtrans-location}{
    }{
      \mmlAmmlAtbackv{\loc} = \Game(\trg{\loc})
    }{backtrans-value}
  \end{center}
}{backtrans-values}{Backtranslation of $\mmlAt$ interface values to $\mmlAs$ interface values.}

\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtbackdetail[\Game, \trg{\overline{\loc}}]{\trace}=\Game',\trg{\overline{\loc'}},\src{e}}{,,Given a \varmapbacktransds $\Game$ and $\trg{\overline{\loc}}$, construct a \varmapbacktransds $\Game'$,\\another stack of locations $\trg{\overline{\loc'}}$, and an $\mmlAs$\\backtranslation contexts from target-trace $\trg{\mstrace}$.''}
    %
    \typerule{backtrans-empty}{
    }{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\hole{\cdot}}=\Game,\trg{\overline{\loc}},\src{42}
    }{backtrans-empty}
    \typerule{backtrans-alloc}{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trg{\trace}}=\Game',\trg{\overline{\loc'}},\src{e}
    }{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trg{Alloc\ \loc\ s}\cdot\trg{\trace}}=\Game',\trg{\overline{\loc'}},\src{e}
    }{backtrans-alloc}
    \typerule{backtrans-dealloc}{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trg{\trace}}=\Game',\trg{\overline{\loc'}},\src{e}
    }{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trg{Dealloc\ \loc}\cdot\trg{\trace}}=\Game',\trg{\overline{\loc'}},\src{e}
    }{backtrans-dealloc}
    \typerule{backtrans-set}{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trg{\trace}}=\Game',\trg{\overline{\loc'}},\src{e}
    }{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trg{Set\ \loc\ n}\cdot\trg{\trace}}=\Game',\trg{\overline{\loc'}},\src{e}
    }{backtrans-set}
    \typerule{backtrans-get}{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trg{\trace}}=\Game',\trg{\overline{\loc'}},\src{e}
    }{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trg{Get\ \loc\ n}\cdot\trg{\trace}}=\Game',\trg{\overline{\loc'}},\src{e}
    }{backtrans-get}
    \typerule{backtrans-abort}{
    }{
      \mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}\cdot\trace}]{\lightning}=\Game,\trg{\overline{\loc}},\src{abort();}
    }{backtrans-abort}
    %
  \end{center}
}{tms-pres-backtrans}{Trace-Based Backtranslation from memory-specific $\mmlAt$ events to $\mmlAs$ terms.}
\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtbackcomptoctx[\Game, \trg{\overline{\loc}}]{\event}=\Game',\trg{\overline{\loc'}},\src{e}}{,,Given a \varmapbacktransds $\Game$ and $\trg{\overline{\loc}}$, construct a \varmapbacktransds $\Game'$,\\another stack of locations $\trg{\overline{\loc'}}$, and an $\mmlAs$\\expression from target $\comptoctx$-interaction-event $\trg{\event}$.''}
    %
    \typerule{backtrans-start}{
    }{
      \mmlAmmlAtbackcomptoctx[\emptyset,\trg{\hole{\cdot}}]{\trg{Start}} = \emptyset,\trg{\hole{\cdot}},\src{42}
    }{backtrans-start}
    %
    \typerule{backtrans-end}{
    }{
      \mmlAmmlAtbackcomptoctx[\emptyset,\trg{\hole{\cdot}}]{\trg{End\ \interfacevalue}} = \emptyset,\trg{\hole{\cdot}},\mmlAmmlAtbackv{\interfacevalue}
    }{backtrans-end}
    %
    \typerule{backtrans-call-comptoctx}{
    }{
      \mmlAmmlAtbackcomptoctx[\Game,\trg{\overline{\loc}}]{\trg{Call\ \comptoctx\ foo\ \interfacevalue}}=\Game,\trg{\overline{\loc}},\src{42}
    }{backtrans-call-comptoctx}
    %
    \typerule{backtrans-ret-comptoctx}{
      \src{z}=\Game(\trg{\loc}) &
      \src{e}=\src{delete\ z}
    }{
      \mmlAmmlAtbackcomptoctx[\Game,\trg{\loc,\overline{\loc}}]{\trg{Ret\ \comptoctx\ \interfacevalue}}=\Game,\trg{\overline{\loc}},\src{e}
    }{backtrans-ret-comptoctx}
    \typerule{backtrans-start-ctxtocomp}{
    }{
      \mmlAmmlAtbackctxtocomp[\Game,\trg{\cdot}]{\trg{Start}}=\Game,\trg{\hole{\cdot}},\src{42}
    }{backtrans-start-ctxtocomp}
    %
    %
    \judgbox{\mmlAmmlAtbackctxtocomp[\Game, \trg{\overline{\loc}}]{\event}=\Game',\trg{\overline{\loc'}},\src{e}}{,,Given a \varmapbacktransds $\Game$ and $\trg{\overline{\loc}}$, construct a \varmapbacktransds $\Game'$,\\another stack of locations $\trg{\overline{\loc'}}$, and an $\mmlAs$\\expression from target $\ctxtocomp$-interaction-event $\trg{\event}$.''}
    %
    \typerule{backtrans-call-ctxtocomp}{
      \fresh{\Game}{\trg{\loc}}&
      \Game_z=\Game[\trg{\loc}] &
      \src{z}=\Game_z(\trg{\loc}) \\
      \src{e}=\src{let\ z = new\ 42\ in\ call\ }\mmlAmmlAtbackdetail[\Game_z]{foo}\ \mmlAmmlAtbackv[\Game_z]{\interfacevalue}
    }{
      \mmlAmmlAtbackctxtocomp[\Game,\trg{\overline{\loc}}]{\trg{Call\ \ctxtocomp\ foo\ \interfacevalue}}=\Game_z,\trg{\loc,\overline{\loc}},\src{e}
    }{backtrans-call-ctxtocomp}
    \typerule{backtrans-ret-ctxtocomp}{
      \fresh{\Game}{\src{x}}
    }{
      \mmlAmmlAtbackctxtocomp[\Game,\trg{\overline{\loc}}]{\trg{Ret\ \ctxtocomp\ \interfacevalue}}=\Game,\trg{\overline{\loc}},\src{let\ x = new\ 1\ in\ delete\ x;return\ }\mmlAmmlAtbackv{\interfacevalue}
    }{backtrans-ret-ctxtocomp}
    \typerule{backtrans-end-ctxtocomp}{
    }{
      \mmlAmmlAtbackctxtocomp[\Game,\trg{\cdot}]{\trg{End\ \interfacevalue}}=\Game,\trg{\hole{\cdot}},\mmlAmmlAtbackv{\interfacevalue}
    }{backtrans-end-ctxtocomp}
  \end{center}
}{tms-pres-backtrans-interact}{Backtranslation of interaction-events from memory-specific $\mmlAt$ events to $\mmlAs$ terms.}
\myfig{
  \begin{center}
    \typerule{non-interface-$\trg{\varepsilon}$}{
    }{
      \vdash \trg{\varepsilon} \operatorname{non-int-\trg{\event}}
    }{non-interface-epsilon}
    %
    \typerule{non-interface-$\trg{Alloc}$}{
    }{
      \vdash \trg{Alloc\ \loc\ n} \operatorname{non-int-\trg{\event}}
    }{non-interface-alloc}
    %
    \typerule{non-interface-$\trg{Dealloc}$}{
    }{
      \vdash \trg{Dealloc\ \loc} \operatorname{non-int-\trg{\event}}
    }{non-interface-dealloc}
    %
    \typerule{non-interface-$\trg{Get}$}{
    }{
      \vdash \trg{Get\ \loc\ n} \operatorname{non-int-\trg{\event}}
    }{non-interface-get}
    %
    \typerule{non-interface-$\trg{Set}$}{
    }{
      \vdash \trg{Set\ \loc\ n} \operatorname{non-int-\trg{\event}}
    }{non-interface-set}
    %
    \typerule{non-interface-$\trg{\lightning}$}{
    }{
      \vdash \trg{\lightning} \operatorname{non-int-\trg{\event}}
    }{non-interface-abort}
    %
    \typerule{non-interface-trace-empty}{
    }{
      \vdash \trg{\hole{\cdot}} \operatorname{non-int-\trg{\trace}}
    }{non-interface-trace-empty}
    %
    \typerule{non-interface-trace-cons}{
      \vdash \trg{\event} \operatorname{non-int-\trg{\trace}} &
      \vdash \trg{\trace} \operatorname{non-int-\trg{\trace}}
    }{
      \vdash \trg{\event\cdot\trace} \operatorname{non-int-\trg{\trace}}
    }{non-interface-trace-cons}
  \end{center}
}{tms-non-interfacing-events}{Non-Interfacing events.}
\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtbacksubtop[\Game, \trg{\overline{\loc}}]{\event[_1]\cdot\trace\cdot\event[_2]}=\Game',\trg{\overline{\loc'}},\src{e_1},\src{e_2}}{,,Given a \varmapbacktransds $\Game$ and $\trg{\overline{\loc}}$, construct a\\\varmapbacktransds $\Game'$, another stack of locations $\trg{\overline{\loc'}}$, and\\an $\mmlAs$ backtranslation context from\\target-trace $\trg{\mstrace}$ which starts with a $\ctxtocomp$ event\\and ends in a $\comptoctx$.''}
    %
    \typerule{subtoplevel-backtrans}{
      \left(\trg{\event[_1]}=\trg{Start} \wedge \trg{\event[_2]}=\trg{Call\ \ctxtocomp\ bar\ \interfacevalue_2}\right)\vee\\\left(\trg{\event[_1]}=\trg{Ret\ \comptoctx\ \interfacevalue_1}\wedge\trg{\event[_2]}=\trg{End\ \interfacevalue_2}\right) \\
      \vdash \trg{\trace} \operatorname{non-int-\trg{\trace}}\\
      \mmlAmmlAtbackcomptoctx[\Game,\trg{\overline{\loc}}]{\trg{\event[_1]}}=\Game',\trg{\overline{\loc'}},\src{e_1} &
      \mmlAmmlAtbackdetail[\Game',\trg{\overline{\loc'}}]{\trg{\trace}}=\Game'',\trg{\overline{\loc''}}, \src{e_2} &
      \mmlAmmlAtbackctxtocomp[\Game'',\trg{\overline{\loc''}}]{\trg{\event[_2]}}=\Game''',\trg{\overline{\loc'''}},\src{e_3} \\
    }{
      \mmlAmmlAtbacksubtop[\Game,\trg{\overline{\loc}}]{\trg{\event[_1]\cdot\trace\cdot\event[_2]}}=\Game''',\trg{\overline{\loc'''}}, \src{e_1}, \src{e_2},\src{e_3}
    }{subtoplevel-backtrans}
  \end{center}
}{tms-pres-subtop-backtrans}{Interaction-Trace-Based Backtranslation from memory-specific $\mmlAt$ events to $\mmlAs$ terms.}

\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtback[\Game]{\mstrace} = \Game',\src{\library}}{,,Top-Level backtranslation of $\trg{\trace}$ to $\mmlAs$ library $\src{\library}$.''}
    %
    \typerule{backtrans-top-level}{
      \trg{\trace}=\trg{\trace[_0]\cdot\trace[^{comp}]\cdot\trace[_1]} &
      \vdash \trg{\trace[^{comp}]} \operatorname{non-int-\trg{\trace}} \\
      \trg{\trace[_0]}=\trg{Start\cdot\trace[_0']\cdot Call\ \ctxtocomp\ foo\ \interfacevalue_1}\\
      \trg{\trace[_1]}=\trg{Ret\ \comptoctx\ \interfacevalue_2\cdot\trace[_0']\cdot End\ \interfacevalue_3}\\
      \mmlAmmlAtbacksubtop[\Game,\trg{\hole{\cdot}}]{\trace[_0]} = \Game', \trg{\overline{\loc}}, \src{e_0},\src{e_0'},\src{let\ x_0 = new\ n_0\ in\ e_0''} \\
      \mmlAmmlAtbacksubtop[\Game',\trg{\overline{\loc}}]{\trace[_1]} = \Game'', \trg{\hole{\cdot}}, \src{e_1},\src{e_1'},\src{e_1''} \\
      \src{e} = \src{e_0;e_0';let\ x_0 = new\ n_0\ in\ (e_0'';e_1);e_1';e_1''}
    }{
      \mmlAmmlAtback[\Game]{\trace} = \Game'', \src{let\ main\ x : \nat\to\nat := e, \hole{\cdot}}
    }{backtrans-top-level}
  \end{center}
}{tms-pres-top-level-backtrans}{Top-Level trace-based Backtranslation from $\mmlAt$ trace $\trg{\trace}$ to $\mmlAs$ context $\src{\library}$.}

.\MK{take care of $\trg{\lightning}$}

\subsubsection{Proofs and Auxiliary Lemmas}

\begin{lemma}[Backtranslation for Non-Interacting Traces is Well-Typed]\label{lem:expr:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item $\trg{\trace}$ not stuck
  \item $\vdash\trg{\trace} \operatorname{non-int-\trg{\trace}}$
  \item $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trace}=\Game,\trg{\overline{\loc'}},\src{e}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\typechecks{}{e}{\nat}$
  \end{goals}
\end{lemma}
\begin{proof}
  Induction on $\trg{\trace}$. Most cases go through immediately using the induction hypothesis, the only left cases are $\src{e}=\src{42}$ and $\src{e}=\src{abort()}$.
  Since $\trg{\trace}$ is not stuck, it cannot be that the backtranslation yields $\src{abort()}$.
  The term $\src{42}$ easily typechecks against an empty gamma.
\end{proof}

\begin{lemma}[Backtranslation for $\comptoctx$-Interacting Events is Well-Typed]\label{lem:expr:interact:comptoctx:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item $\trg{\event}$ not stuck
  \item\label[ass]{asm:expr:interact:comptoctx:backtranslation:welltyped} $\mmlAmmlAtbackcomptoctx[\Game,\trg{\overline{\loc}}]{\event}=\Game,\trg{\overline{\loc'}},\src{e}$
  \end{assumptions}
  Then $\exists \src{\Gamma}$,
  \begin{goals}
  \item $\typechecks{\Gamma}{e}{\nat}$
  \end{goals}
\end{lemma}
\begin{proof}
  Inverting \Cref{asm:expr:interact:comptoctx:backtranslation:welltyped} yields two cases, so we continue with two cases.
  \begin{description}
    \item \textbf{Case }$\trg{\event} = \trg{Call\ \comptoctx\ foo\ \interfacevalue}$\textbf{:}

    Here, $\src{e} = \src{42}$. Let $\src{\Gamma} = \src{\hole{\cdot}}$, it's easy to see that $\typechecks{}{42}{\nat}$ holds by \Cref{tr:t-nat}.

    \item \textbf{Case }$\trg{\event} = \trg{Ret\ \comptoctx\ \interfacevalue}$\textbf{:}

    $\src{e} = \src{delete\ z}$, where $\src{z} = \Game\left(\trg{\loc}\right)$ and $\trg{\loc}$ is at the top of the stack of locations $\trg{\overline{\loc}}$.
    Choose $\src{\Gamma} = \src{x:\ptr,\hole{\cdot}}$, the typing follows using \Cref{tr:w-t-delete}.
  \end{description}
\end{proof}

\begin{lemma}[Backtranslation for Call-$\ctxtocomp$ is Well-Typed]\label{lem:expr:interact:call:comptoctx:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item\label[ass]{asm:expr:interact:call:ctxtocomp:backtranslation:welltyped} $\mmlAmmlAtbackctxtocomp[\Game,\trg{\overline{\loc}}]{Call\ \ctxtocomp\ foo\ \interfacevalue}=\Game',\trg{\loc,\overline{\loc'}},\src{e'}$
  \item $\src{x} = \Game'\left(\trg{\loc}\right)$
  \item $\src{e}=\src{e';\ delete\ x}$
  \item\label[ass]{asm:expr:interact:call:ctxtocomp:backtranslation:gamma} $\src{\Gamma}=\src{\Gamma_{1}, foo:\nat\to\nat ,\Gamma_{2}}$\MK{$\src{\nat\to\nat}$ only holds under the assumption of non-passing pointers}
  \end{assumptions}
  Then,
  \begin{goals}
  \item $\typechecks{\Gamma}{e}{\nat}$
  \end{goals}
\end{lemma}
\begin{proof}
  Invert \Cref{asm:expr:interact:call:ctxtocomp:backtranslation:welltyped} giving\\$\src{e}=\src{let\ x=new\ 42\ in\ call\ }\mmlAmmlAtbackv[\Game']{foo}\ \mmlAmmlAtbackv[\Game']{\interfacevalue}\src{;\ delete\ x}$, where $\Game' = \Game\left[\trg{\loc}\right]$ and $\fresh{\Game}{\trg{\loc}}$.
  The claim follows using \Cref{tr:w-t-new,tr:w-t-delete} and \Cref{tr:t-let,tr:t-call}, where the latter uses \Cref{asm:expr:interact:call:ctxtocomp:backtranslation:gamma}.
\end{proof}

\begin{lemma}[Backtranslation for Ret-$\ctxtocomp$ is Well-Typed]\label{lem:expr:interact:ret:ctxtocomp:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item\label[ass]{asm:expr:interact:ret:ctxtocomp:backtranslation:welltyped} $\mmlAmmlAtbackctxtocomp[\Game,\trg{\overline{\loc}}]{Ret\ \ctxtocomp\ \interfacevalue}=\Game,\trg{\overline{\loc'}},\src{e}$
  \end{assumptions}
  Then,
  \begin{goals}
  \item $\typechecks{}{e}{\nat\to\bot}$
  \end{goals}
\end{lemma}
\begin{proof}
  Invert \Cref{asm:expr:interact:ret:ctxtocomp:backtranslation:welltyped} giving $\src{e}=\src{let\ x=new\ 1\ in\ delete\ x;\ return\ }\mmlAmmlAtbackv{\interfacevalue}$, where $\fresh{\Game}{\src{x}}$.
  It's assumed that $\mmlAmmlAtbackv{\interfacevalue}=\src{n}$\MK{this assumption is gone if we talk about passing pointers}, so the claim follows using \Cref{tr:w-t-new,tr:w-t-delete,tr:t-return}.
\end{proof}

\begin{lemma}[Backtranslation is Well-Typed]\label{lem:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item $\trg{\trace}$ not stuck
  \item\label[ass]{asm:backtranslation:welltyped:backtrans} $\mmlAmmlAtback[\emptyset]{\trace}=\Game,\src{\library_{ctx}}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
  \item $\Gammas\vdash\src{\library_{comp}}\operatorname{ok}$
  \end{assumptions}
  Then,
  \begin{goals}
  \item $\Gammas\vdash\src{\library}\operatorname{ok}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
  First up, note that $\Gammas\vdash\src{\library_{comp}}\operatorname{ok}$, so it suffices to check $\Gammas\vdash\src{\library_{ctx}}\operatorname{ok}$.\MK{technical lemma}
  By inverting \Cref{asm:backtranslation:welltyped:backtrans} we get $\trg{\trace}=\trg{\trace[_{0}]\cdot\trace[^{comp}]\cdot\trace[_{1}]}$ and\\$\src{e}=\src{e_{0};e_{0}';let\ x_{0}=new\ n_{0}\ in\ \left(e_{0}'';e_{1}\right);e_{1}';e_{1}''}$, where:
  \begin{passumptions}{H}
    \item $\vdash\trg{\trace[^{comp}]}\operatorname{non-int-\trg{\trace}}$
    \item\label[ass]{asm:backtranslation:welltyped:subtop1} $\mmlAmmlAtbackdetail[\Game,\trg{\hole{\cdot}}]{\trace[_{0}]}=\Game',\trg{\overline{\loc}},\src{e_{0}},\src{e_{0}'},\src{let\ x_{0} = new\ n_{0}\ in\ e_{0}''}$
    \item\label[ass]{asm:backtranslation:welltyped:subtop2} $\mmlAmmlAtbackdetail[\Game',\trg{\overline{\loc}}]{\trace[_{1}]}=\Game'',\trg{\hole{\cdot}},\src{e_{1}},\src{e_{1}'},\src{e_{1}''}$.
  \end{passumptions}
  Inverting \Cref{asm:backtranslation:welltyped:subtop1,asm:backtranslation:welltyped:subtop2}, first take note that\\$\trg{\trace[_0]}=\trg{Call\ \comptoctx\ main\ \interfacevalue_1\cdot\trace[_0']\cdot Call\ \ctxtocomp\ foo\ \interfacevalue_2}$ and $\trg{\trace[_1]}=\trg{Ret\ \ctxtocomp\ \interfacevalue_3\cdot\trace[_1']\cdot Ret\ \comptoctx\ \interfacevalue_4}$.
  Furthermore, $\src{e_{0}}=\src{42}$, $\mmlAmmlAtbackdetail[\Game,\trg{\hole{\cdot}}]{\trace[_{0}']}=\Game',\trg{\loc,\overline{\loc}},\src{e_{0}'}$, and $\src{e_0''}=\src{let\ z=new\ 42\ in\ call\ foo\ n}$, where $\src{z}=\Game'\left(\trg{\loc}\right)$, $\src{n}=\mmlAmmlAtbackv{\interfacevalue_{2}}$, and $\mmlAmmlAtcomp{foo}=\trg{foo}$ with $\src{foo}\in\operatorname{dom}\src{\library_{comp}}$.
  Also, $\src{e_{1}}=\src{delete\ z}$, $\mmlAmmlAtbackdetail[\Game',\trg{\loc,\overline{\loc}}]{\trace[_{1}']}=\Game'',\trg{\hole{\cdot}},\src{e_{1}'}$, and $\src{e_{1}''}=\src{let\ x = new\ 1\ in\ delete\ x;return\ m}$, where $\src{m}=\mmlAmmlAtbackv[\Game'']{\interfacevalue_{4}}$ and $\fresh{\Game''}{\src{x}}$.
  Therefore: $$\src{e}=\src{42;e_{0}';let\ z=new\ 42\ in\ \left(call\ foo\ n; delete\ z\right);e_{1}';let\ x=\ new\ 1\ in\ delete\ x;return\ m}$$

  This typechecks easily, making use of \Cref{tr:w-t-new,tr:w-t-delete} and \Cref{tr:t-let,tr:t-return,tr:t-call}, as well as \Thmref{lem:expr:backtranslation:welltyped}\MK{...and weakening (with NonOwnedPtr stuff)}.
\end{incompleteproof}

\begin{lemma}[Backtranslation Correctness of $\trg{Start}$]\label{lem:exprbacktranslation:vbeg:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item\label[ass]{asm:exprbacktranslation:vbeg:wrapper:correct:exect} $\exect[]{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_{main}}{Start}$
  \item $\mmlAmmlAtbackdetail[\Game,\trg{\hole{\cdot}}]{Start}=\Game,\trg{\hole{\cdot}},\src{42}$
  \item $\xlangstateeq[\emptyset;\src{\hole{\cdot}}]{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}$
  \item $\src{\library}=\left\{\src{main}\mapsto\src{42;e_{main}}\right\}\src{\linker\library_{comp}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{goal:exprbacktranslation:vbeg:wrapper:correct:execs} $\exec{\src{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}}{\src{call\ main\ 0}}{\src{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}}{\src{e_{main}}}{\src{Start}}$
  \item\label[goal]{goal:exprbacktranslation:vbeg:wrapper:correct:backstateeq} $\xlangbackstateeq[\emptyset;\src{\hole{\cdot}}]{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{\src{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}}$
  \item\label[goal]{goal:exprbacktranslation:vbeg:wrapper:correct:eventeq} $\src{Start}\thexlangtraceeq[\emptyset;\src{\hole{\cdot}}]\trg{Start}$
  \end{goals}
\end{lemma}
\begin{proof}
  %$\src{main}\in\operatorname{dom}\left\{\src{main}\mapsto\src{42;e_{main}}\right\}$.
  For \Cref{goal:exprbacktranslation:vbeg:wrapper:correct:execs}, use \Cref{tr:w-e-ectx-call-value,tr:w-e-ectx,tr:w-e-let-x}.
  \Cref{goal:exprbacktranslation:vbeg:wrapper:correct:backstateeq} by \Cref{tr:state-qe}, \Cref{tr:memstate-qe,tr:cfstate-qe} and \Cref{tr:empty-kontstack-qe,tr:empty-commlib-eq,tr:empty-memstate-eq}.
  \Cref{goal:exprbacktranslation:vbeg:wrapper:correct:eventeq} follow \Cref{tr:start-event-eq}.
\end{proof}

\begin{lemma}[Beginning of Backtranslation Correctness]\label{lem:exprbacktranslation:beg:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:exect} $\exect[]{\Omega}{K_{component}[return\ \interfacevalue]}{\Omega'}{K[\interfacevalue]}{Ret\ \comptoctx\ \interfacevalue}$
  \item $\trg{K_{component}}=\mmlAmmlAtcomp{K_{component}}$
  \item $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{Ret\ \comptoctx\ \interfacevalue}=\Game',\trg{\overline{\loc'}},\src{delete\ z}$
  \item $\xlangstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}$
  \item $\src{K}=\src{\hole{\cdot};delete\ z;e_{any}}$
  \item $\src{\library}=\left\{\src{main}\mapsto\src{e_{main}}\right\}\src{\linker\library_{comp}}$
  \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:delta} $\delta\left(\src{\loc}\right)=\trg{\loc}$
  \end{assumptions}
  then $\exists \src{X'}\ \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:Xsubset} $\src{X}\subseteq\src{X'}$
  \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:execs} $\exec{\src{\Omega}}{\src{K_{component}[return\ }\mmlAmmlAtbackv[\Game']{\trg{\interfacevalue}}\src{]}}{\src{\commlib;\library;\kontstack;\memstate'}}{\src{e_{any}}}{\src{\trace}}$
  \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:stateeq} $\xlangbackstateeq[\delta;\src{L}]{\Omega'}{\src{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp};\memstate'}}$
  \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:traceeq} $\src{\trace}\thexlangtraceeq[\delta;\src{X'}]\trg{Ret\ \comptoctx\ \interfacevalue}$
  \end{goals}
\end{lemma}
\begin{proof}
  Let $\src{\memstate}=\src{H;\Delta}$.
  Since $\src{\loc}\in\operatorname{dom}\delta$\MK{technical lemma}, we know that we can decompose $\src{\Delta}$ such that $\src{\Delta}=\src{\Delta_{1},x\mapsto\loc_{\poison},\Delta_{2}}$.
  Choose $\src{X'}=\src{X}\cup\left\{\src{Dealloc\ \loc}\right\}, \src{\trace}=\src{Dealloc\ \loc\cdot Ret\ \comptoctx\ }\mmlAmmlAtbackv{\interfacevalue}$, and $\src{\memstate'}=\src{H;\Delta_{1},x\mapsto\loc_{\poisoned},\Delta_{2}}$.
  \Cref{goal:exprbacktranslation:beg:wrapper:correct:Xsubset} is easy.
  For \Cref{goal:exprbacktranslation:beg:wrapper:correct:execs}, first use \Cref{tr:w-e-ectx-ret-value} or \Cref{tr:w-e-ectx-ret-loc} depending on the shape of $\mmlAmmlAtbackv{\interfacevalue}$.
  Then, continue with \Cref{tr:w-e-ectx,tr:w-e-let-x,tr:w-e-delete}, concluding the goal.
  Decompose $\trg{\Omega'}=\trg{\commlib;\library;\kontstack;\memstate}$, which can be backed up by inverting \Cref{asm:exprbacktranslation:beg:wrapper:correct:exect}.
  The relation follows easily.\MK{ref the ctors}
  Noting that $\src{Dealloc\ \loc}\in\src{X'}$, \Cref{goal:exprbacktranslation:beg:wrapper:correct:traceeq} follows using \Cref{tr:ignore-cons-trace-eq,tr:cons-trace-eq,tr:empty-trace-eq}, concluding with \Cref{tr:ret-event-eq}.
\end{proof}

\begin{lemma}[Middle of Backtranslation Correctness]\label{lem:exprbacktranslation:mid:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item $\exect{\Omega}{e}{\Omega'}{e'}{\trace}$
  \item $\mmlAmmlAtbackdetail[\Game]{\trace}=\Game',\src{e}$
  \item $\vdash\trg{\trace}\operatorname{ non-int-}\trg{\trace}$
  \item $\xlangbackstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
%  \item $\src{\library}=\left\{\src{main}\mapsto\src{e_{main}}\right\}\src{\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item $\exec{\src{\Omega}}{\src{K[e]}}{\src{\commlib;\library;\kontstack;\memstate'}}{\src{K[42]}}{\src{\trace}}$
  \item $\xlangbackstateeq[\delta;\src{L}]{\Omega'}{\src{\commlib;\library;\kontstack;\memstate'}}$
  \item $\src{\trace}\thexlangtraceeq[\delta;\src{X}]\trg{\trace}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
  Induction on $\trg{\trace}$.

  \begin{description}
  \item \textbf{Case $\trg{\trace}=\trg{\hole{\cdot}}$}

  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item\label[ass]{asm:backtranscorr:case0:exect} $\exect{\Omega}{e}{\Omega'}{e'}{\hole{\cdot}}$
  \item\label[ass]{asm:backtranscorr:case0:thebacktrans} $\mmlAmmlAtback[\Game]{\hole{\cdot}}=\Game,\src{e}$
  \item\label[ass]{asm:backtranscorr:case0:stateeq} $\xlangbackstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item $\exec{\configs}{\src{K[e]}}{\src{\commlib;\library;\kontstack;\memstate'}}{\src{K[42]}}{\src{\trace}}$
  \item $\xlangbackstateeq[\delta']{\Omega'}{\commlib;\library;\kontstack;\memstate'}$
  \item $\src{\trace}\thexlangtraceeq[\delta']\trg{\hole{\cdot}}$
  \end{goals}

  By inversion on \Cref{asm:backtranscorr:case0:thebacktrans}, what is left to show is:
  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item $\exect{\Omega}{e}{\Omega'}{e'}{\hole{\cdot}}$
  \item $\mmlAmmlAtback[\Game]{\hole{\cdot}}=\Game,\src{42}$
  \item $\xlangbackstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item $\exec{\configs}{\src{K[42]}}{\src{\commlib;\library;\kontstack;\memstate'}}{\src{K[42]}}{\src{\trace}}$
  \item $\xlangbackstateeq[\delta']{\Omega'}{\commlib;\library;\kontstack;\memstate'}$
  \item $\src{\trace}\thexlangtraceeq[\delta']\trg{\hole{\cdot}}$
  \end{goals}

  Instantiate our goal with $\src{\trace}=\src{\hole{\cdot}}$ and $\src{\memstate'}=\src{\memstate}$, the first two goals and the fourth follow immediately by reflexivity, the third goal follows by \Cref{asm:backtranscorr:case0:stateeq} after inverting \Cref{asm:backtranscorr:case0:exect}.

  \item \textbf{Case $\trg{\trace}=\trg{\event\cdot\trace}$:}
  If
  \begin{passumptions}{H^{(0)}}
  \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item\label{asm:backtranscorr:indu:step} $\exect{\Omega}{e}{\Omega'}{e'}{\event\cdot\trace}$
  \item $\mmlAmmlAtback{\msevent\cdot\trace}=\Game',\src{e}$
  \item\label[ass]{asm:backtranscorr:case1:stateeq} $\xlangbackstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
  \end{passumptions}
  then $\exists \src{\trace}$,
  \begin{goals}
  \item $\exec{\configs}{\src{K[e]}}{\src{\configs'}}{\src{K[e']}}{\src{\trace}}$
  \item $\xlangbackstateeq[\delta']{\Omega'}{\Omega'}$
  \item $\src{\trace}\thexlangtraceeq[\delta']\trg{\event}$
  \end{goals}

  The induction hypothesis is:\MK{continue cleaning up here}

          \noindent
  If $\forall \trg{\Omega_{\IH}}\ \trg{\commlib_{\IH}}\ \trg{\library_{\IH}}\ \trg{\library_{ctx}^{\IH}}\ \trg{\kontstack_{\IH}}\ \trg{\memstate^{\IH}}\ \trg{\Omega'_{\IH}}\ \trg{e_{\IH}}\ \trg{\finalexprnoerr_{\IH}}\ \src{\Omega_{\IH}}\ \src{\commlib^{\IH}}\ \src{\library_{\IH}}\ \src{\library_{ctx}^{\IH}}\ \src{\library_{comp}^{\IH}}\ \src{\kontstack_{\IH}}\ \src{\memstate_{\IH}}\ \src{e_{\IH}}\ \delta_{\IH}\ \Game_{\IH}\ \Game_{\IH}',$
  \begin{assumptions}
  \item $\trg{\Omega_{\IH}}=\trg{\commlib_{\IH};\library_{\IH};\kontstack_{\IH};\memstate_{\IH}}$
  \item $\trg{\library_{\IH}}=\trg{\library_{ctx}^{\IH}\linker}\mmlAmmlAtcomp{\library_{comp}^{\IH}}$
  \item $\trg{\commlib_{\IH}}=\mmlAmmlAtcomp{\commlib_{\IH}}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}^{\IH}}$
  \item $\exect{\Omega_{\IH}}{e_{\IH}}{\Omega'_{\IH}}{\finalexprnoerr_{\IH}}{\trace}$
  \item $\mmlAmmlAtback[\Game_{\IH}]{\trace}=\Game_{\IH}',\src{e_{\IH}}$
  \item $\xlangbackstateeq[\delta_{\IH}]{\Omega_{\IH}}{\Omega_{\IH}}$
  \item $\src{\Omega_{\IH}}=\src{\commlib_{\IH};\library_{\IH};\kontstack_{\IH};\memstate_{\IH}}$
  \item $\src{\library_{\IH}}=\src{\library_{ctx}^{\IH}\linker\library_{comp}^{\IH}}$
  \end{assumptions}
  then $\exists \delta'\ \src{\Omega'}\ \src{\trace}\ \src{\finalexprnoerr}$,
  \begin{goals}
  \item $\delta_{\IH}\subseteq\delta'$
  \item $\exec{\src{\Omega_{\IH}}}{\src{e_{\IH}}}{\src{\configs'}}{\src{\finalexprnoerr}}{\src{\trace}}$
  \item $\xlangbackstateeq[\delta']{\Omega'_{\IH}}{\Omega'}$
  \item $\src{\trace}\thexlangtraceeq[\delta']\trg{\trace}$
  \end{goals}

  We proceed by case-analysis on $\trg{\msevent}$.
  \begin{description}
    \item \textbf{Case $\trg{\msevent}=\trg{Call\ \ctxtocomp\ foo\ \interfacevalue}$:}
      Note that:
      \begin{passumptions}{H}
    \item\label[ass]{asm:backtranscorr:freshl} $\fresh{\Game}{\trg{\loc}}$
    \item\label[ass]{asm:backtranscorr:freshz} $\Game_z=\Game[\trg{\loc}]$
    \item $\src{z}=\Game_z(\trg{\loc})$
    \item\label[ass]{asm:backtranscorr:indu:backtrans} $\mmlAmmlAtback[\Game_{z}]{\trace}=\Game',\src{e_a}$
    \item $\src{e} = \src{let\ z = new\ 42\ in\ call\ }\mmlAmmlAtback[\Game_{z}]{foo}\ \mmlAmmlAtbackv[\Game_{z}]{\interfacevalue}\src{;delete\ z;e_{a}}$
    \item $\mmlAmmlAtback[\Game]{Call\ \ctxtocomp\ foo\ \interfacevalue\cdot\mstrace}=\Game',\src{e}$
    \item\label[ass]{asm:backtranscorr:call:origexect} $\exect{\Omega}{e}{\Omega'}{\finalexprnoerr}{Call\ \ctxtocomp\ foo\ \interfacevalue\cdot\trace}$
      \end{passumptions}

      Let $\delta_z=\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\}$, obviously $\delta\subseteq\delta_z$.
      Since the call event is $\ctxtocomp$, we can conclude\MK{technical lemma} that $\trg{foo}\in\mmlAmmlAtcomp{\commlib}$ and, thus, $\trg{foo}\in\operatorname{dom}\mmlAmmlAtcomp{\library_{comp}}$.
      Consequently, $\mmlAmmlAtback[\Game_{z}]{foo}\in\operatorname{dom}\src{\library_{comp}}$\MK{technical lemma}.
      Invert \Cref{asm:backtranscorr:call:origexect}, yielding:
      \begin{passumptions}{H}
        \setcounter{enumi}{7}
        \item\label[ass]{asm:backtranscorr:call:call:exect} $\exect[]{\Omega}{e}{\Omega_{0}}{e_{0}}{Call\ \ctxtocomp\ foo\ \interfacevalue}$
        \item\label[ass]{asm:backtranscorr:call:rest:exect} $\exect{\Omega_{0}}{e_{0}}{\Omega'}{\finalexprnoerr}{\trace}$
      \end{passumptions}

      Let $\src{\Omega}=\src{\commlib;\library;\kontstack;H;\Delta}$ and $\src{H'}=\src{H}\ll\src{42}$.
      Note that $\fresh{\src{\Delta}}{\src{\loc}}$ and $\fresh{\src{\Delta}}{\src{z}}$ using \Cref{asm:backtranscorr:freshl,asm:backtranscorr:freshz}.\MK{technical lemma. Maybe also $\multimap$ needs to know about $\Game$}
      Using that, by \Cref{tr:w-e-let-new}, we know:
      \begin{passumptions}{F}
        \item $\execs[]{\Omega}{e}{\commlib;\library;\kontstack;H';z\mapsto\loc_{\poisonless},\Delta}{e_{b}}{Alloc\ \loc\ 42}$
        \item $\src{e_{b}}=\src{call\ }\mmlAmmlAtback[\Game_{z}]{foo}\ \mmlAmmlAtbackv[\Game_{z}]{\interfacevalue}\ \src{; delete\ z;e_{a}}$
      \end{passumptions}
      Since $\mmlAmmlAtback{foo}=\src{foo}\in\src{\commlib}$, we know that $(\src{let\ foo\ x:\type_{{\color{black}}\lambda}:=e})\in\src{\library_{comp}}$ and, thus, also $\mmlAmmlAtcomp{let\ foo\ x:\type_{{\color{black}}\lambda}:=e}\in\mmlAmmlAtcomp{\library_{comp}}$.
      Let $\src{K}=\src{let\ \_ = \hole{\cdot}\ in\ delete\ z;e_{a}}$. It is easy to see that $\src{K\hole{call\ foo\ \color{black}\mmlAmmlAtbackv{\interfacevalue}\color{\stlccol}}}=\src{e_{b}}$.
      By inverting \Cref{asm:backtranscorr:call:call:exect}, we know $\trg{e_{0}}=\mmlAmmlAtcomp{K\hole{call\ foo\ ...}}$.
          {\color{red}\large TODO: break up call one step for the blue stuff, thus allowing us to apply the lemma approxoflolly}
      Given \Cref{asm:backtranscorr:case1:stateeq}, it is immediate\MK{don't be lazy} that:
      \begin{passumptions}{F}
        \setcounter{enumi}{2}
        \item\label[ass]{asm:backtranscorr:call:src:stateeq:call} $\xlangbackstateeq[\delta;\src{\loc,L}]{\Omega}{\commlib;\library;\kontstack;H';z\mapsto\loc_{\poisonless},\Delta}$
      \end{passumptions}
      Now use \Thmref{lem:relations:call:approxoflolly} with \Cref{asm:backtranscorr:call:call:exect,asm:backtranscorr:call:src:stateeq:call} to get that $\xlangstateeq[\delta,\src{\loc,L}]{\Omega}{\Omega_{0}}$.

      %Use \Thmref{lem:relations:ret:lollyofapprox} and \Thmref{lem:relations:call:approxoflolly}

%     With \Cref{lem:trg:calldecompose}, we can decompose \Cref{asm:backtranscorr:call:origexect} into three parts:
%     \begin{passumptions}{\trg{E}}
%   \item $\exect[]{\commlib;\library;\kontstack;\memstate}{K[e]}{\commlib;\library;K_{\hat{\comm}}^{foo},\kontstack;\memstate}{e_{0}}{Call\ \comm\ foo\ \interfacevalue}$
%   \item $\exect[^{n}]{\commlib;\library;K_{\hat{\comm}}^{foo},\kontstack;\memstate}{e_{0}}{\commlib;\library;\kontstack;\memstate'}{K[\interfacevalue']}{\trace[_{1}]\cdot Ret\ \hat{\comm}\ \interfacevalue'}$
%   \item $\exect{\commlib;\library;\kontstack;\memstate'}{K[\interfacevalue']}{\Omega'}{\finalexpr}{\trace[_{2}]}$
%   \item $\trg{\memstate}\ogreaterthan\trg{\memstate'}$
%   \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
%     \end{passumptions}
      We now instantiate $\IH$ with $\trg{\Omega_{\IH}}=\trg{\commlib;\library;\kontstack;\memstate'}$, $\trg{\Omega_{\IH}'}=\trg{\Omega'}$, $\trg{e_{\IH}}=\trg{K[\interfacevalue']}$, $\trg{\finalexprnoerr_{\IH}}=\trg{\finalexprnoerr}$, $\src{\Omega_{\IH}}=\src{\commlib;\library;\kontstack;H';z\mapsto\loc_{\poisonless},\Delta}$\MK{$\src{Delta}$ may be different}, $\src{e_{\IH}}=\src{delete\ z; e_a}$, $\delta_{\IH}=\delta_z$, $\Game_{\IH}=\Game_z$, and $\Game_{\IH}'=\Game'$.
      {\color{red} ok, this probably breaks because we need the execution in the induction hypothesis to not terminate with an $\src{f}$ but step as we want}

      Using \Cref{asm:backtranscorr:case1:stateeq}, we apply \Cref{tr:back-cons-locmap-eq}\MK{we technically need a lemma that says we can apply it under monotone $\delta$, i.e. for "bigger" $\delta$} to get
      \begin{passumptions}{H}
        \setcounter{enumi}{8}
      \item\label[ass]{asm:backtranscorr:indu:staterel} $\xlangbackstateeq[\delta_x]{H';z\mapsto\loc_{\poisonless},\Delta}{H';z\mapsto\loc_{\poisonless},\Delta}$
      \end{passumptions}
      thereby introducing some fresh $\src{z}$ and $\src{\loc}$.
      Furthermore, the following assumption is easily derivable from the existing ones:
      \begin{passumptions}{H}
        \setcounter{enumi}{9}
      \item\label[ass]{asm:backtranscorr:indu:trace} $\trg{\mstrace}=\thetospecificfilter\left(\trg{\trace}\right)$
      \end{passumptions}

      We now instantiate $\IH$ with $\trg{\Omega_{\IH}}=\trg{H';z,\mapsto\loc_{\poisonless},\Delta}$, $\trg{\Omega_{\IH}'}=\trg{\Omega''}$, $\trg{e_{\IH}}=\trg{e'[z/x]}$, $\trg{\finalexprnoerr_{\IH}}=\trg{\finalexprnoerr}$, $\src{\Omega_{\IH}}=\src{H';z\mapsto\loc_{\poisonless},\Delta}$, $\src{e_{\IH}}=\src{e_a}$, $\delta_{\IH}=\delta_x$, $\Game_{\IH}=\Game_x$, and $\Game_{\IH}'=\Game'$.
      Whence, specialize it with \Cref{asm:backtranscorr:indu:steps,asm:backtranscorr:indu:trace,asm:backtranscorr:indu:backtrans,asm:backtranscorr:indu:staterel}, giving us:
      \begin{passumptions}{F}
      \item\label[ass]{asm:backtranscorr:indu:deltasubset} $\delta_x\subseteq\delta'$
      \item\label[ass]{asm:backtranscorr:indu:afterallocstep} $\exec{\src{H';z\mapsto\loc_{\poisonless},\Delta}}{\src{e'[z/x]}}{\src{\configs''}}{\src{\finalexprnoerr}}{\src{\trace}}$
      \item\label[ass]{asm:backtranscorr:indu:finalstaterel} $\xlangbackstateeq[\delta']{\Omega''}{\Omega''}$
      \item\label[ass]{asm:backtranscorr:indu:tracerel1} $\src{\trace}\thexlangtraceeq[\delta']\trg{\trace}$
      \end{passumptions}

      For the sake of clarity, we repeat our goal:
      $\exists \delta'\ \src{\Omega'}\ \src{\trace}\ \src{\finalexprnoerr}$,
      \begin{goals}
      \item $\delta\subseteq\delta'$
      \item $\exec{\configs}{\src{let\ x=new\ }\mmlAmmlAtbackv{n}\src{\ in\ e'}}{\src{\configs'}}{\src{\finalexprnoerr}}{\src{\trace}}$
      \item $\xlangbackstateeq[\delta']{\Omega''}{\Omega'}$
      \item $\src{\trace}\thexlangtraceeq[\delta']\trg{Alloc\ \loc\ n\cdot\trace}$
      \end{goals}

      Instantiate it with $\delta'=\delta'$, $\src{\Omega'} = \src{\Omega''}$, $\src{\trace}=\src{Alloc\ \loc\ n\cdot\trace}$, and $\src{v}=\src{v}$.
      \begin{goals}
      \item $\delta\subseteq\delta'$

        Follows by definition of $\delta_x$ and \Cref{asm:backtranscorr:indu:deltasubset}.
      \item $\exec{\configs}{\src{let\ x=new\ }\mmlAmmlAtbackv{n}\src{\ in\ e'}}{\src{\configs''}}{\src{\finalexprnoerr}}{\src{Alloc\ \loc\ n\cdot\trace}}$

        Apply \Cref{tr:ws-e-trans-important}, use \Cref{tr:w-e-let-new} and then we are done using \Cref{asm:backtranscorr:indu:afterallocstep} .
      \item $\xlangbackstateeq[\delta']{\Omega''}{\Omega''}$

        By \Cref{asm:backtranscorr:indu:finalstaterel}.
      \item $\src{Alloc\ \loc\ }\mmlAmmlAtbackv{n}\thexlangtraceeq[\delta']\trg{Alloc\ \loc\ n\cdot\trace}$

      Easy using \Cref{tr:empty-trace-eq}, \Cref{tr:cons-trace-eq}, \Cref{tr:alloc-event-eq}, and \Thmref{lem:compvals:insertion}.
      \end{goals}

    \item \textbf{Case $\trg{\msevent}=\specificev{Dealloc\ \loc}$:}
      todo.

    \item \textbf{Case $\trg{\msevent}=\specificev{Use\ \loc\ n}$:}
      todo.

  \end{description}

  \end{description}
\end{incompleteproof}

\clearpage
\begin{lemma}[End of Backtranslation Correctness]\label{lem:exprbacktranslation:end:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item $\exect{\Omega}{K\hole{call\ foo\ \interfacevalue}}{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}{\color{black}\mmlAmmlAtcomp{e_{foo}}}{Call\ \ctxtocomp\ foo\ \interfacevalue}$
  \item $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{Call\ \ctxtocomp\ foo\ \interfacevalue}=\Game',\trg{\overline{\loc'}},\src{let\ z = new\ 42\ in\ call\ foo\ }\mmlAmmlAtbackv{\interfacevalue}$
  \item\label[ass]{lem:exprbacktranslation:end:wrapper:correct:backstateeq} $\xlangbackstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item $\src{let\ foo\ x:\type_{\color{black}\lambda}:=e_{foo}}\in\src{\library_{comp}}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
%  \item $\src{\library}=\left\{\src{main}\mapsto\src{e_{main}}\right\}\src{\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \delta'\ \src{L'}\ \src{X'}\ \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:deltasubset} $\delta\subseteq\delta'$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:Lsubset} $\src{L}\subseteq\src{L'}$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:Xsubset} $\src{X}\subseteq\src{X'}$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:execs} $\exec{\src{\Omega}}{\src{K[let\ x = new\ 42\ in\ call\ foo\ }\mmlAmmlAtbackv{\interfacevalue}\src{]}}{\src{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate'}}{\src{e_{foo}}}{\src{\trace}}$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:stateeq} $\xlangstateeq[\delta';\src{L'}]{\src{\commlib;\library;\kontstack;\memstate'}}{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:traceeq} $\src{\trace}\thexlangtraceeq[\delta';\src{X'}]\trg{Call\ \ctxtocomp\ foo\ \interfacevalue}$
  \end{goals}
\end{lemma}
\begin{proof}
  Note that $\src{\memstate}=\src{H;\Delta}$. Let $\src{\loc}$ and $\src{z}=\trg{z}$ such that $\fresh{\src{\Delta}}{\src{\loc}}$ and $\fresh{\src{\Delta}}{\src{\loc}}$.
  Furthermore, let $\src{\interfacevalue} = \mmlAmmlAtbackv{\interfacevalue}$.
  Choose $\delta'=\delta\cup\left\{\src{\loc}\mapsto\trg{z}\right\}, \src{L'}=\src{L}\cup\left\{\src{\loc}\right\}, \src{X'}=\src{X}\cup\left\{\src{Alloc\ \loc\ 42}\right\}$, and $\src{\trace}=\src{Alloc\ \loc\ 42\cdot Call\ \ctxtocomp\ foo\ \interfacevalue}$.
  \Cref{goal:exprbacktranslation:end:wrapper:correct:deltasubset,goal:exprbacktranslation:end:wrapper:correct:Lsubset,goal:exprbacktranslation:end:wrapper:correct:Xsubset} follow easily.
  For \Cref{goal:exprbacktranslation:end:wrapper:correct:execs}, use \Cref{tr:w-e-ectx,tr:w-e-let-new} and either \Cref{tr:w-e-ectx-call-loc} or \Cref{tr:w-e-ectx-call-value}, depending on the shape of $\mmlAmmlAtbackv{\interfacevalue}$\MK{take care of substitution when calling?}.
  \Cref{goal:exprbacktranslation:end:wrapper:correct:stateeq}, use \Cref{tr:cons-ignore-memstate-eq} once, the rest follows from inverting \Cref{lem:exprbacktranslation:end:wrapper:correct:backstateeq} and making use of \Cref{tr:memstate-qe}.
  Lastly, noting that $\src{Alloc\ \loc\ 42}\in\src{X'}$, apply \Cref{tr:ignore-cons-trace-eq,tr:cons-trace-eq,tr:empty-trace-eq}, concluding with \Cref{tr:ret-event-eq}.
\end{proof}

\clearpage
\begin{lemma}[Very End of Backtranslation Correctness]\label{lem:exprbacktranslation:vend:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item $\exect{\Omega}{K\hole{return\ n}}{\commlib;\library;\hole{\cdot};\memstate}{n}{Ret\ \ctxtocomp\ n}$
  \item\label[ass]{lem:exprbacktranslation:vend:wrapper:correct:backtrans} $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{Ret\ \ctxtocomp\ n}=\Game,\trg{\overline{\loc}},\src{e}$ %$let\ x = new\ 1\ in\ delete\ x;return\ }\mmlAmmlAtbackv{n}$
  \item\label[ass]{lem:exprbacktranslation:vend:wrapper:correct:backstateeq} $\xlangbackstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}$
  \item $\src{\library}=\left\{\src{main}\mapsto\src{e_{main}}\right\}\src{\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \delta'\ \src{L'}\ \src{X'}\ \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item\label[goal]{lem:exprbacktranslation:vend:wrapper:correct:delta} $\delta\subseteq\delta'$
  \item\label[goal]{lem:exprbacktranslation:vend:wrapper:correct:L} $\src{L}\subseteq\src{L'}$
  \item\label[goal]{lem:exprbacktranslation:vend:wrapper:correct:X} $\src{X}\subseteq\src{X'}$
  \item $\exec{\src{\Omega}}{\src{K[e]}}{\src{\commlib;\library;\hole{\cdot};\memstate'}}{\mmlAmmlAtbackv{n}}{\src{\trace}}$
  \item\label[goal]{lem:exprbacktranslation:vend:wrapper:correct:stateeq} $\xlangstateeq[\delta';\src{L'}]{\src{\commlib;\library;\hole{\cdot};\memstate'}}{\commlib;\library;\hole{\cdot};\memstate}$
  \item\label[goal]{lem:exprbacktranslation:vend:wrapper:correct:traceeq} $\src{\trace}\thexlangtraceeq[\delta';\src{X'}]\trg{Ret\ \ctxtocomp\ n}$
  \end{goals}
\end{lemma}
\begin{proof}
  Note that $\src{\memstate}=\src{H;\Delta}$.
  Let $\src{\loc}$ such that $\fresh{\src{\memstate}}{\src{\loc}}$ and also let $\src{z}=\trg{z}$ such that $\fresh{\src{\memstate}}{\src{z}}$\MK{make sure $\src{z}$ here is fresh w.r.t. $\Game$. Relation between $\src{\Delta}$ and $\Game$}.
  Furthermore, let $\src{n}=\mmlAmmlAtbackv{n}$.
  Pick $\delta'=\delta\cup\left\{\src{\loc}\mapsto\trg{z}\right\}$, $\src{L'}=\src{L}\cup\left\{\src{\loc}\right\}$, $\src{X'}=\src{X}\cup\left\{\src{Alloc\ \loc\ 1}, \src{Dealloc\ \loc}\right\}$, and $\src{\trace}=\src{Alloc\ \loc\ 42 \cdot Dealloc\ \loc \cdot Ret\ \comptoctx\ n}$.
  Finally, choose $\src{\memstate'}=\src{H';\Delta'}$, where $\src{H'}=\src{H,0}$ and $\src{\Delta'}=\src{z\mapsto\loc,\Delta}$.
  \Cref{lem:exprbacktranslation:vend:wrapper:correct:delta,lem:exprbacktranslation:vend:wrapper:correct:L,lem:exprbacktranslation:vend:wrapper:correct:X} follow easily.
  Invert \Cref{lem:exprbacktranslation:vend:wrapper:correct:backtrans} to get $\src{e}=\src{let\ z = new\ 1\ in\ delete\ z;return\ }\mmlAmmlAtbackv{n}$.
  Make use of \Cref{tr:w-e-ectx,tr:w-e-let-x,tr:w-e-let-new,tr:w-e-delete,tr:w-e-ectx-ret-value}, arriving at the desired state.
  For \Cref{lem:exprbacktranslation:vend:wrapper:correct:stateeq}, use \Cref{tr:cons-ignore-memstate-eq} once, the rest follows from inverting \Cref{lem:exprbacktranslation:vend:wrapper:correct:backstateeq} and making use of \Cref{tr:memstate-qe}.
  For \Cref{lem:exprbacktranslation:vend:wrapper:correct:traceeq}, apply \Cref{tr:ignore-cons-trace-eq} twice, noting that both $\src{Alloc\ \loc\ 1}\in\src{X'}$ and $\src{Dealloc\ \loc}\in\src{X'}$.
  Lastly, apply \Cref{tr:cons-trace-eq,tr:empty-trace-eq}, concluding with \Cref{tr:ret-event-eq}.
\end{proof}

% \begin{lemma}[Subtoplevel Backtranslation Correctness]\label{lem:subtop:backtranslation:correct}
%   If
%   \begin{assumptions}
%   \item $\exect{\Omega}{e}{\Omega'}{\finalexprnoerr}{\trace}$
%   \item $\mmlAmmlAtback[\Game,\trg{\overline{\loc}}]{\event[\comptoctx]\cdot\trace\cdot\event[\ctxtocomp]}=\Game',\trg{\overline{\loc'}},\src{e_{1}},\src{e_{2}},\src{e_{3}}$
%   \item $\xlangstateeq{\Omega}{\Omega}$
%   \end{assumptions}
%   then $\exists \delta'\ \src{\Omega'}\ \src{\trace}\ \src{X'}\ \src{L'}$,
%   \begin{goals}
%   \item $\delta\subseteq\delta'$
%   \item $\exec{\configs}{\src{e_{1}}}{\src{\configs_{1}}}{\src{\finalexprnoerr_{1}}}{\src{\trace[_{1}]}}$
%   \item $\exec{\src{\configs_{1}}}{\src{e_{2}}}{\src{\configs_{2}}}{\src{\finalexprnoerr_{2}}}{\src{\trace[_{2}]}}$
%   \item $\exec{\src{\configs_{2}}}{\src{e_{3}}}{\src{\configs_{3}}}{\src{\finalexprnoerr_{3}}}{\src{\trace[_{3}]}}$
%   \item $\xlangstateeq[\delta';\src{L'}]{\Omega'}{\Omega'}$
%   \item $\src{\trace}\thexlangtraceeq[\delta';\src{X'}]\trg{\trace}$
%   \end{goals}
% \end{lemma}
% \begin{incompleteproof}
% \end{incompleteproof}

\begin{lemma}[Backtranslation Correctness]\label{lem:backtranslation:correct}
  If
  \begin{assumptions}
  \item $\exect{\Omega}{call\ main\ 0}{\Omega'}{\finalexprnoerr}{\trace}$
  \item\label[ass]{asm:backtrans:correct:backtrans} $\mmlAmmlAtback[\Game]{\trace}=\Game',\src{\library_{ctx}}$
  \item\label[ass]{asm:backtrans:correct:initstaterel} $\xlangstateeq[\emptyset]{\Omega}{\Omega}$
  \item $\trg{\Omega}=\trg{foo,\hole{\cdot};\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}$
  \item\label[ass]{asm:backtrans:correct:omegais} $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item\label[ass]{asm:backtrans:correct:srclinks} $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \delta'\ \src{L'}\ \src{X'}\ \src{\Omega'}\ \src{\trace}$,
  \begin{goals}
  \item $\delta\subseteq\delta'$
  \item $\exec{\configs}{\src{call\ main\ 0}}{\src{\configs'}}{\mmlAmmlAtbackv[\Game']{\finalexprnoerr}}{\src{\trace}}$
  \item $\xlangstateeq[\delta';\src{L'}]{\Omega'}{\Omega'}$
  \item $\src{\trace}\thexlangtraceeq[\delta';\src{X'}]\trg{\trace}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
  Inverting \Cref{asm:backtrans:correct:backtrans} gives\\$\trg{\trace} = \trg{Call\ \comptoctx\ main\ 0\cdot\trace[_{0}]\cdot Call\ \ctxtocomp\ foo\ \interfacevalue_{0}\cdot\trace[_{comp}]\cdot Ret\ \comptoctx\ \interfacevalue_{1}\cdot\trace[_{1}]\cdot Ret\ \ctxtocomp\ \interfacevalue_{2}}$, $\vdash\trg{\trace[^{comp}]}\operatorname{non-int-\trg{\trace}}$, $\mmlAmmlAtbackctxtocomp[\Game,\trg{\hole{\cdot}}]{\trace[_0]} = \Game',\trg{\overline{\loc}},\src{e_0},\src{e_0'},\src{let\ z\ =\ new\ n_0\ in\ e_0''}$, and $\mmlAmmlAtbackcomptoctx[\Game',\trg{\overline{\loc}}]{\trace[_1]} = \Game'',\trg{\hole{\cdot}},\src{e_1},\src{e_1'},\src{e_1''}$, such that $\src{e_{main}}=\src{e_0;e_0';let\ z\ =\ new\ n_0\ in\ \left(e_0'';e_1\right);e_1';e_1''}$ and $\src{\library_{ctx}}=\src{let\ main\ x:\nat\to\nat:=e_{main},\hole{\cdot}}$.

  \noindent
  By transitivity and inversion, $\exect{\Omega}{call\ main\ 0}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_0}{Call\ \comptoctx\ main\ 0}$ and $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_0}{\Omega'}{\finalexprnoerr}{\trace[_a]}$, where $\trg{\trace}=\trg{Call\ \comptoctx\ main\ 0\cdot\trace[_a]}$.

  Now use \Thmref{lem:exprbacktranslation:vbeg:wrapper:correct} to get
  \begin{passumptions}{H}
    \item $\execs{\Omega}{call\ main\ 0}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{main}}{\trace}$
    \item\label[ass]{asm:backtrans:correct:backstaterel0} $\xlangbackstateeq[\emptyset;\src{L}]{\Omega}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}$
    \item $\src{\trace}\thexlangtraceeq[\emptyset;\src{X}]\trg{Call\ \comptoctx\ main}$
  \end{passumptions}

  By inverting the first backtranslation sufficiently, we see that $\src{e_{0}}=\src{42}$, so we can get rid of it in the sequence, because executing the underlying $\src{let}$ produces unobservable events.
  Using \Cref{asm:backtrans:correct:initstaterel,asm:backtrans:correct:omegais,asm:backtrans:correct:srclinks}, we can conclude $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$ and $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\mmlAmmlAtcomp{\library_{comp}}$.\MK{technical lemma}

  By transitivity and inversion\MK{technical lemma making use of $\vdash\trg{\trace[_{0}]}\operatorname{non-int-\trg{\trace}}$},\\ $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_{0}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_1}{\trace[_{0}]}$ and\\ $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_1}{\Omega'}{\finalexprnoerr}{\trace[_b]}$, where $\trg{\trace[_{a}]}=\trg{\trace[_{0}]\cdot\trace[_{b}]}$.

  With \Cref{asm:backtrans:correct:backstaterel0}, we can use \Thmref{lem:exprbacktranslation:mid:wrapper:correct} to obtain:
  \begin{passumptions}{H}
    \setcounter{enumi}{3}
    \item $\emptyset\subseteq\delta_{0}$
    \item $\execs{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{K\hole{e_{0}'}}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K\hole{42}}{\trace[_{0}]}$
    \item $\xlangbackstateeq[\delta_{0};\src{L}]{\Omega_{0}}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}$
    \item $\src{\trace[_{0}]}\thexlangtraceeq[\delta_{0};\src{L}]\trg{\trace[_{0}]}$
  \end{passumptions}

  Note that $\trg{\trace[_{b}]}=\trg{Call\ \ctxtocomp\ foo\ \interfacevalue_{0}\cdot\trace[_{c}]}$, so by inversion on the execution we know $\trg{e_{1}}=\trg{K'\hole{call\ foo\ \interfacevalue_{0}}}$.
  Thus, by transitivity and inversion, $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{1}}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{foo}}{Call\ \ctxtocomp\ foo\ \interfacevalue_{0}}$ and\\ $\exect{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{foo}}{\Omega'}{\finalexprnoerr}{\trace[_c]}$.
  By the fact that $\trg{foo}\in\trg{\commlib}$, we have $\trg{foo}\in\operatorname{dom}\mmlAmmlAtcomp{\library_{comp}}$ and thus $\trg{e_{foo}}=\mmlAmmlAtcomp{e_{foo}}$, where $\src{let\ foo\ x:\type_{\color{black}\lambda}:=e_{foo}}\in\src{\library_{comp}}$.
  We are ready to apply \Thmref{lem:exprbacktranslation:end:wrapper:correct}:
  \begin{passumptions}{H}
    \setcounter{enumi}{7}
    \item $\delta_{0}\subseteq\delta_{1}$
    \item $\src{L}\subseteq\src{L'}$
    \item $\src{X}\subseteq\src{X'}$
    \item $\execs{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{K'[let\ x=new\ 42\ in\ call\ foo\ {\color{black}\mmlAmmlAtback{\interfacevalue_{0}}}]}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{e_{foo}}{\trace[_{1}]}$
    \item $\xlangstateeq[\delta_{1};\src{L'}]{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}$
    \item $\src{\trace[_{1}]}\thexlangtraceeq[\delta_{1};\src{X'}]\trg{Call\ \ctxtocomp\ foo\ \interfacevalue_{0}}$
  \end{passumptions}
  By transitivity and inversion\MK{technical lemma},\\$\exect{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{foo}}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K_{component}\hole{return\ \interfacevalue_{1}}}{\trace[_{comp}]}$ and\\ $\exect{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K_{component}\hole{return\ \interfacevalue_{1}}}{\Omega'}{\finalexprnoerr}{\trace[_c]}$, where $\trg{\trace[_{b}]}=\trg{\trace[_{comp}]\cdot\trace[_{c}]}$.

  With this, we can use\MK{well-typedness of $\src{\library_{comp}}$ is missing} \Thmref{lem:component:correctness} to get:
  \begin{passumptions}{H}
    \setcounter{enumi}{13}
    \item $\delta_{1}\subseteq\delta_{2}$
    \item $\execs{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{e_{foo}}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K_{component}\hole{return\ \interfacevalue_{1}}}{\trace[_{comp}]}$
    \item $\xlangstateeq[\delta_{2};\src{L'}]{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}$
    \item $\src{\trace[_{comp}]}\thexlangtraceeq[\delta_{2};\src{X'}]\trg{\trace[_{comp}]}$
  \end{passumptions}

  By transitivity and inversion,\\$\exect{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K_{component}\hole{return\ \interfacevalue_1}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K'\hole{\interfacevalue_{1}}}{Ret\ \comptoctx\ \interfacevalue_1}$ and\\ $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K'\hole{\interfacevalue_{1}}}{\Omega'}{\finalexprnoerr}{\trace[_d]}$, where $\trg{\trace[_{c}]}=\trg{Ret\ \comptoctx\ \interfacevalue_1\cdot\trace[_{d}]}$.

  Note that $\src{K'}=\src{\hole{\cdot};delete\ z;e_1';e_1''}$
  Now, use \Thmref{lem:exprbacktranslation:beg:wrapper:correct}\MK{check constraint about $\src{K^{foo}}$}:
  \begin{passumptions}{H}
    \setcounter{enumi}{17}
    \item $\delta_2\subseteq\delta_3$
    \item $\src{L'}\subseteq\src{L''}$
    \item $\src{X'}\subseteq\src{X''}$
    \item $\execs{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K_{component}\hole{return\ \interfacevalue_1}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{delete\ z;e_1';e_1''}{\trace[_{2}]}$
    \item $\xlangbackstateeq[\delta_3;\src{L''}]{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}$
    \item $\src{\trace[_2]}\thexlangtraceeq[\delta_3;\src{X''}]\trg{Ret\ \ctxtocomp\ \interfacevalue_1}$ \MK{the wrapper should be eaten away in the lemmas}
  \end{passumptions}

  And again, by transitivity and inversion,\\$\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K'\hole{\interfacevalue_1}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K''\hole{return\ \interfacevalue_{2}}}{\trace[_1]}$ and\\ $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K''\hole{return\ \interfacevalue_{2}}}{\Omega'}{\finalexprnoerr}{Ret\ \ctxtocomp\ \interfacevalue_2}$, where $\trg{\trace[_{d}]}=\trg{\trace[_1]\cdot Ret\ \ctxtocomp\ \interfacevalue_2}$.

  This allows us to use \Thmref{lem:exprbacktranslation:mid:wrapper:correct}:
  \begin{passumptions}{H}
    \setcounter{enumi}{23}
    \item $\delta_3\subseteq\delta_4$
    \item $\execs{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K''\hole{e_1'}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'''}{K''\hole{42}}{\trace[_{3}]}$
    \item $\xlangbackstateeq[\delta_4;\src{L''}]{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'''}$
    \item $\src{\trace[_3]}\thexlangtraceeq[\delta_4;\src{X''}]\trg{\trace[_1]}$
  \end{passumptions}

  Finally, we use \Thmref{lem:exprbacktranslation:vend:wrapper:correct}:\MK{argue that $\src{K''\hole{42}}=\src{K'''\hole{return\ \interfacevalue_{2}}}$}
  \begin{passumptions}{H}
    \setcounter{enumi}{27}
    \item $\delta_{4}\subseteq\delta_{5}$
    \item $\src{L''}\subseteq\src{L'''}$
    \item $\src{X''}\subseteq\src{X'''}$
    \item $\execs{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'''}{K'''\hole{return\ \interfacevalue_{2}}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''''}{\interfacevalue_{2}}{\trace[_{4}]}$
    \item $\xlangstateeq[\delta_{5};\src{L'''}]{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''''}{\Omega'}$
    \item $\src{\trace[_4]}\thexlangtraceeq[\delta_{4};\src{X'''}]\trg{Ret\ \ctxtocomp\ \interfacevalue_{2}}$
  \end{passumptions}

  Stitching everything together, we can conclude by instantiating the goal with $\delta_{5},\src{L'''},\src{X'''}, \src{\trace[_{0}]\cdot\trace[_{1}]\cdot\trace[_{2}]\cdot\trace[_{3}]\cdot\trace[_{4}]}$ and for $\src{\Omega'}$ choose $\src{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''''}$.
  The goals follow by composition and monotonicity.\MK{flesh this out in detail}
\end{incompleteproof}

\begin{scontents}[store-env=buffer]
  If
  \begin{assumptions}
  \item\label[ass]{asm:rtmsp:srctms} $\forall \src{\library_{ctx}}\ \src{\library_{comp}}\ \src{\trace}\ \src{\Omega}\ \src{v}, \wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{\finalexpr}{\trace}\rightarrow\texttt{TMS}(\tospecificevs[_{\emptyset}]{\trace})$
  \item\label[ass]{asm:rtmsp:trgexec} $\wexec{\trg{prog\ \library_{ctx}\ }\mmlAmmlAtcomp{\library_{comp}}}{\trg{\configt}}{\trg{\finalexpr}}{\trg{\trace}}$
  \end{assumptions}
  then
  \begin{goals}
  \item\label[goal]{rtmsp:tms} $\texttt{TMS}(\tospecificevt[_{\emptyset}]{\trace})$
  \end{goals}
\end{scontents}

\realthm{thm:rtmsp}{4}{Robust \gls{tms} Preservation}
\begin{proof}
  Suppose $\trg{\finalexpr}=\trg{\valueexpr}$.\MK{rework}
  Invert \Cref{asm:rtmsp:trgexec}:
  \begin{passumptions}{H}
    \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
    \item $\trg{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
    \item\label[ass]{rtmsp:runt} $\exec{\mmlAmmlAtcomp{\commlib}\trg{;\library;\emptyset;\emptyset;\emptyset}}{\trg{call\ main\ 0}}{\trg{\Omega}}{\trg{\valueexpr}}{\trg{Call\ \comptoctx\ main\ 0\cdot\trace'\cdot Ret\ \ctxtocomp\ \interfacevalue}}$
    \item $\trg{\trace}=\trg{Start\cdot\trace'\cdot End\ \interfacevalue}$
  \end{passumptions}

  We backtranslate $\mmlAmmlAtbackdetail[\emptyset]{\trace}=\Game,\src{let\ main\ z\ := e}$.
  By assumption with respect to the number of calls done, we can decompose $\trg{\trace}$ into\\$\trg{Call\ \comptoctx\ main\ 0\cdot\trace[^{ctx}_{0}]\cdot Call\ \ctxtocomp\ foo\ n\cdot\trace[^{comp}]\cdot Ret\ \comptoctx\ m\cdot\trace[^{ctx}_{1}]\cdot Ret\ \ctxtocomp\ n'}$ such that $\vdash\trg{\trace[^{comp}]}\ \operatorname{non-int-\trg{trace}}$, $\vdash\trg{\trace[^{ctx}_{0}]}\ \operatorname{non-int-\trg{trace}}$, and $\vdash\trg{\trace[^{ctx}_{1}]}\ \operatorname{non-int-\trg{trace}}$.

  Thus, $\trg{foo}\in\mmlAmmlAtcomp{\library_{comp}}$, $\src{foo}\in\src{\library_{comp}}$, and $\trg{main}\in\trg{\library_{ctx}}$.\MK{technical inversion lemma on traces}
  Let $\src{\library_{ctx}}=(\src{let\ main\ z\ := e})\src{,\hole{\cdot}}$.
  Let $\src{\library} = \src{\library_{ctx}\linker\library_{comp}}$ which follows by inverting $\trg{\library_{ctx}\linker\library_{comp}}$.
  Let $\src{\Gamma_0}=\src{\library}\downarrow$ and note that $\src{main}\in\operatorname{dom}\src{\Gamma_0}$.
  We need to verify that $\src{\Gamma_0}\vdash\src{\library}\operatorname{ok}$ to conclude $\vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv\src{\library},\operatorname{dom}\src{\library_{comp}}$.
  This follows from \Thmref{lem:backtranslation:welltyped}.
  By \Cref{tr:state-eq,tr:empty-memstate-eq,tr:cfstate-eq,tr:empty-commlib-eq,tr:cons-commlib-eq,tr:empty-kontstack-eq}, we have $\xlangstateeq{\commlib;\library;\emptyset;\emptyset;\emptyset}{{\color{black}\mmlAmmlAtcomp{\commlib}};\library;\emptyset;\emptyset;\emptyset}$.
  Using these facts, we apply \Thmref{lem:backtranslation:correct} on \Cref{rtmsp:runt}, crucially giving us a $\mmlAs$ execution that yields $\src{\trace}$ such that $\xlangtraceeq{\trace}{\trace}$.
  Finally, use \Cref{lem:traceagreement:with:filter} on \Cref{rtmsp:tms} and follow with \Cref{asm:rtmsp:srctms}, whose assumptions are satisfied by the results we got from applying backtranslation correctness.
\end{proof}

\myfig{
  \begin{center}
    \begin{tikzpicture}[state/.style={minimum height=0.6cm}]
      % relative horizontal/vertical distance between states
      \pgfmathsetmacro{\hdist}{0.85}
      \pgfmathsetmacro{\vdist}{1.25}
      \pgfmathsetmacro{\halfvdist}{0.625}

      % row of src states
      \node[state] (srcempty) {$\src{\emptyset}$};
      \foreach \s [remember=\s as \cur (initially empty)] in {1,w_1,p,w_2,2} {
        \node[state,right=\hdist of src\cur] (src\s) {$\src{\Omega_{\s}}$};
      }
      % row of trg states
      \node[state,below=\vdist of srcempty] (trgempty) {$\trg{\emptyset}$};
      \foreach \s in {1,w_1,p,w_2,2} {
        \node[state,below=\vdist of src\s] (trg\s) {$\trg{\Omega_{\s}}$};
      }
      %% illustrations
        % backtrans wrapper 1
        \draw[thick,loosely dotted,Peach!50,rounded corners] (src1.north east) -- (srcw\string_1.north east)
          -- (trgw\string_1.south east) -- (trg1.south west) -- (src1.north west) -- cycle;
        % backtrans wrapper 2
        \draw[thick,loosely dotted,Peach!50,rounded corners] (srcp.north east) -- (srcw\string_2.north east)
          -- (trgw\string_2.south east) -- (trgp.south west) -- (srcp.north west) -- cycle;
        % compiler correctness
        \draw[thick,loosely dashed,Emerald!50,rounded corners] ($(srcw\string_1.north east)+(0,0.05)$) -- ($(srcp.north east)+(0,0.05)$)
          -- ($(trgw\string_2.north east)+(0.05,0)$) -- ($(trgw\string_2.south east)+(0.05,-0.05)$)
          -- ($(trg1.south west)+(-0.05,-0.05)$) -- ($(trg1.north west)+(-0.05,0)$) -- ($(srcw\string_1.north west)+(0,0.05)$) -- cycle;
      % state relations
      \path (srcempty) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_\emptyset$} (trgempty)
        (src1) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_1}$} (trg1)
        (srcp) edge[draw=gray!25] node[pos=0.5,sloped,fill=white] {\scriptsize$\approx_{\delta_p}$} (trgp)
        (src2) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_2}$} (trg2)
        (srcw\string_1) edge[draw=gray!25] node[pos=0.5,sloped,fill=white] {\scriptsize$\approx_{\delta_{w_1}}$} (trgw\string_1)
        (srcw\string_2) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_{w_2}}$} (trgw\string_2)
        % diagonals
        (srcw\string_1) edge[draw=gray!25] node[pos=0.16,sloped,rotate=180,fill=white] {\scriptsize$\approx_{\delta_{w_1}}$} (trg1)
        (src1) edge[draw=gray!25] node[pos=0.16,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_1}$} (trgw\string_1)
        (srcp) edge[draw=gray!25] node[pos=0.2,sloped,fill=white] {\scriptsize$\approx_{\delta_p}$} (trgw\string_2)
        (trgp) edge[draw=gray!25] node[pos=0.2,sloped,fill=white] {\scriptsize$\multimap_{\delta_{w_2}}$} (srcw\string_2)
        ;
      %\drawpolygon src1,srcw\string_1,trgw\string_1,trg1;
      %\drawpolygon srcp,srcw\string_2,trgw\string_2,trgp;
      %\node[font=\tiny,align=center,above=0.2 of srcw1srcp] (wrapper) {Backtranslation\\Wrapper};
      %\path[->,draw] (wrapper) -- (srcw\string_1);
      %\path[->,draw] (wrapper) -- (srcp);
      % steps
      \path[color=\stlccol] (srcempty) edge[draw=none] node {\ $\xrightarrow{\trace[_1]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (src1)
        (src1) edge[draw=none] node {\ $\xrightarrow{\trace[_c]}{}{\kern-3.5pt}_{\text{ctx}}$} (srcw\string_1)
        (srcw\string_1) edge[draw=none] node {\ $\xrightarrow{\trace[_p]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (srcp)
        (srcp) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\trace[_r]}{}{\kern-3.5pt}_{\text{ctx}}$} (srcw\string_2)
        (srcw\string_2) edge[draw=none] node {\ $\xrightarrow{\trace[_2]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (src2)
        ;
      \path[color=\ulccol] (trgempty) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\phantom{\trace[_1]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trg1)
        (trg1) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgw\string_1)
        (trgw\string_1) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgp)
        (trgp) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgw\string_2)
        (trgw\string_2) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_2]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trg2)
        ;
      % legend
      \node[align=left,below right=0.3 and 0.3 of trgempty,font=\tiny] (legend) {%
        $\xlangtraceeqn{\src{\trace[_c]}}{\mmlAmmlAtback[]{Call\ ?\finalexprnoerr_i}}$\\%
        $\xlangtraceeqn{\src{\trace[_r]}}{\mmlAmmlAtback[]{Ret\ !\finalexprnoerr_o}}$
        };
      \draw[thick,loosely dotted,Peach!50,rounded corners] ($(legend.north east)+(0.5,-0.4)$) -- ($(legend.north east)+(1,-0.4)$);
      \node at ($(legend.north east)+(1.5,-0.4)$) (legendwrapper) {};
      \node[right of=legendwrapper] {\tiny Backtranslation Wrapper};
      \draw[thick,loosely dashed,Emerald!50,rounded corners] ($(legend.south east)+(0.5,0.4)$) -- ($(legend.south east)+(1,0.4)$);
      \node at ($(legend.south east)+(1.5,0.4)$) (legendcorrectness) {};
      \node[right of=legendcorrectness] {\tiny Compiler Correctness};
    \end{tikzpicture}
  \end{center}
}{rtmsp-sketch}{Sketch of the proof of \Thmref{thm:rtmsp}. %
  Arrows in the horizontal direction are the usual step relations, but the term is omitted for aesthetic purposes. %
  Likewise for the emitted target-level traces. %
  Trace $\src{\trace[_1]}$ starts with $\src{Ret\ !0}$ and $\src{\trace[_2]}$ ends with $\src{Call\ ?\valueexpr}$, where $\src{\valueexpr}$ is the final result of the program. %
  Target states $\trg{\Omega_1}$ and $\trg{\Omega_{w_1}}$ are exactly equal, so are $\trg{\Omega_p}$ and $\trg{\Omega_{w_2}}$. They are drawn for aesthetic purposes.}

\clearpage
\cleardoublepage

\bibliographystyle{plain}
\bibliography{library}

\end{document}
