\documentclass[a4paper,names,dvipsnames]{article}

\usepackage[T1]{fontenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{glossaries}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage[capitalize]{cleveref}
\usepackage{bm}
\usepackage{xspace}
\usepackage{etoolbox}

\usepackage{mmmacros}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\loadglsentries{acronyms}
\makeglossaries

\newcommand{\MK}[1]{\todo[color=orange!30]{TODO: #1}}
\newcommand{\MP}[1]{\todo[color=blue!30]{TODO: #1}}


\begin{document}

Let $\propositions$ be the set of propositions.

\begin{definition}\label{def:events}
  $\events$ is the set of atomic propositions hereby called events or actions.
  The internal action is $\emptyevent$.
  The action $\terminationevent$ is program termination.
\end{definition}

\begin{definition}\label{def:pl}
A programming language is a tuple $\left(\partials,\wellf,\singlestep,\linker\right)$ s.t.:

\begin{itemize}
  \item[$\partials$] : Set - is a set of admissible, partial programs.
  \item[$\wellf$] : $\partials\to\propositions$ - a judgement that holds iff a program is not partial.
  \item[$\singlestep$] : $\wholes\to\events\to\wholes$ - a step relation, where $\wholes=\{w\in\partials\ |\ \wellf w\}$.
        For $e\in\events$ and $p,p'\in\wholes$ we say for $\estep{p}{e}{p'}$ that program $p$ performs a step with action $e$ to program $p'$.
        If $e=\emptyevent$, we write $\step{p}{p'}$.
        In case $e=\terminationevent$, we write $\terminates{p}$.
  \item[$\linker$] : $\partials\to\partials\to\partials$ - links two partial programs together in some way, resulting in a new partial program.
\end{itemize}
\end{definition}
Let $\src{S},\irl{I},$ and $\trg{T}$ be any programming language.

\begin{definition}
  A trace $\trace$ is an infinite sequence of events that results from the relation $\singlestep$.
  That is, we obtain the trace $\trace=e_{0}e_{1}\dots$ for the execution sequence $\estep{p}{e_{0}}{\estep{p'}{e_{1}}{\dots}}$ and write $\mktrace{p}{\trace}$.
  The set of all traces is $\traces$.
\end{definition}
\noindent
We assume $\lightning$ to occur at most once in the trace and if it does occur, an infinite sequence of $\emptyevent$ follows.

\begin{definition}
  A finite sequence of events $m$ is a finite trace prefix of $\trace$ iff it satisfies the following judgement.
  We write the empty, finite trace prefix as $\cdot$.

  $$
\inference{}{\cdot\le\trace}\inference{m\le\trace}{e::m\le e::\trace}
  $$
\end{definition}

\begin{definition}
  The behavior of a whole program $p$ is a set of all traces it produces, i.e. $\behav{p}=\{\trace\ |\ \mktrace{p}{\trace}\}$.
\end{definition}

\begin{definition}
  A property $\prop$ is a set of admissible traces. Thus, if $p$ satisfies $\prop$ (written $\sat{p}{\prop}$), then $\behav{p}\subseteq\prop$.
\end{definition}

\begin{definition}
  A hyperproperty $H$ is a set of sets of admissible traces. Thus, if $p$ satisfies $\prop$ (also written $\sat{p}{H}$), then $\behav{p}\in H$.
\end{definition}

\begin{definition}
  A program $p$ robustly satisfies a property $\prop$, written $\rsat{p}{\prop}$, iff $\forall C\in\partials,\sat{C\linker p}{\prop}$. The same notation is used for robust hyperproperty satisfaction.
\end{definition}

\begin{definition}
  A (hyper-)property class $\mathcal{C}$ is a set of (hyper-)properties.
\end{definition}

\begin{definition}
  The class of safety properties contains all properties that can be refuted with a finite trace prefix:
  $$
  \text{Safety} = \left\{\pi\ |\ \forall \trace\in\traces, t\not\in\pi \text{ iff } \exists m\ge\trace,\forall \trace'\in\traces,m\le\trace'\implies\trace'\not\in\pi\right\}
  $$
\end{definition}

\begin{definition}
  A compiler between languages $\S$ and $\T$ is a partial function $\stcomp{\bullet}$ from $\src{\partials}$ to $\trg{\partials}$.
\end{definition}

\begin{definition}
  For a given class $\mathbb{C}$, a compiler from language $\S$ to $\T$ robustly preserves $\mathbb{C}$ iff
  $$
  \forall\pi\in\mathbb{C},\forall\src{p}\in\src{\partials},\sat{\src{p}}{\pi}\implies\sat{\stcomp{\src{p}}}{\pi}
  $$
  We write $\vdash\stcomp{\bullet}:\mathbb{C}$.
\end{definition}

\begin{definition}
  Given two compilers $\sicomp{\bullet}$ and $\itcomp{\bullet}$, their sequential composition is $\sitcomp{\bullet}=\itcompN{\sicomp{\bullet}}$.
\end{definition}

\begin{definition}
  The conjunctive composition of two properties $\pi_{1},\pi_{2}$ is the set-intersection $\pi_{1}\cap\pi_{2}$

  {\Large\color{red}Do the lifting}
\end{definition}

\begin{definition}
  The conjunctive composition of two classes of properties $\mathbb{C}_{1},\mathbb{C}_{2}$ is the set-intersection $\mathbb{C}_{1}\cap\mathbb{C}_{2}$.
\end{definition}

\begin{lemma}
  Given $\rtp{\sicomp{\bullet}}{\mathbb{C}_{1}}$ and $\rtp{\itcomp{\bullet}}{\mathbb{C}_{2}}$, then $\rtp{\sitcomp{\bullet}}{\mathbb{C}_{1}\cap\mathbb{C}_{2}}$.
\end{lemma}

\end{document}
