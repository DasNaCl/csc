\documentclass[a4paper,names,dvipsnames]{article}

\usepackage[T1]{fontenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{glossaries}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage[capitalize]{cleveref}
\usepackage{bm}
\usepackage{xspace}
\usepackage{etoolbox}
\usepackage{cite}

\usepackage{mmmacros}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\loadglsentries{acronyms}
\makeglossaries

\newcommand{\MK}[1]{\todo[color=orange!30]{TODO: #1}}
\newcommand{\MP}[1]{\todo[color=blue!30]{TODO: #1}}


\begin{document}

Let $\propositions$ be the set of propositions.

\begin{definition}[Events]\label{def:events}
  $\events$ is the set of atomic propositions hereby called events or actions.
  The internal action is $\emptyevent$.
  The action $\terminationevent$ is program termination.
\end{definition}

\begin{definition}[Programming Languages]\label{def:pl}
A programming language is a tuple $\left(\partials,\wellf,\singlestep,\linker\right)$ s.t.:

\begin{itemize}
  \item[$\partials$] : Set - is a set of admissible, partial programs.
  \item[$\wellf$] : $\partials\to\propositions$ - a judgement that holds iff a program is not partial.
  \item[$\singlestep$] : $\wholes\to\events\to\wholes$ - a step relation, where $\wholes=\{w\in\partials\ |\ \wellf w\}$.
        For $e\in\events$ and $p,p'\in\wholes$ we say for $\estep{p}{e}{p'}$ that program $p$ performs a step with action $e$ to program $p'$.
        If $e=\emptyevent$, we write $\step{p}{p'}$.
        In case $e=\terminationevent$, we write $\terminates{p}$.
  \item[$\linker$] : $\partials\to\partials\to\partials$ - links two partial programs together in some way, resulting in a new partial program.
\end{itemize}
\end{definition}
Let $\src{S},\irl{I},$ and $\trg{T}$ be any programming language.

\begin{definition}[Notation for Sequences]
  For any sequence of events, let $\seqnil$ denote the empty sequence and $\seqcons{e}{\bar{t}}$ the sequence that starts with $e$ and continues with $\bar{t}$.
  Hereby, it does not matter whether $\bar{t}$ is finite or infinite, it's merely syntactic sugar to work on sequences of events.
\end{definition}

\begin{definition}[Traces]
  A trace $\trace$ is an infinite sequence of events that results from the relation $\singlestep$.
  That is, we obtain the trace $\trace=\seqcons{e_{0}}{\seqcons{e_{1}}{\dots}}$ for the execution sequence $\estep{p}{e_{0}}{\estep{p'}{e_{1}}{\dots}}$ and write $\mktrace{p}{\trace}$.
  The set of all traces is $\traces$.
\end{definition}
\noindent
We assume $\lightning$ to occur at most once in the trace and if it does occur, an infinite sequence of $\emptyevent$ follows.

\begin{definition}[Finite Trace Prefixes]
  A finite sequence of events $m$ is a finite trace prefix of $\trace$ iff it satisfies the following judgement.

  $$
    \inference{}{\cdot\le\trace}\hspace{2em}\inference{m\le\trace}{\seqcons{e}{m}\le \seqcons{e}{\trace}}
  $$
\end{definition}

\begin{definition}[Behavior]
  The behavior of a whole program $p$ is a set of all traces it produces, i.e. $\behav{p}=\{\trace\ |\ \mktrace{p}{\trace}\}$.
\end{definition}

\begin{definition}[Properties]
  A property $\prop$ is a set of admissible traces. For a program $p$ to satisfy $\prop$ it must not produce a trace that is not part of $\prop$. Thus, $p$ satisfies $\prop$ iff $\behav{p}\subseteq\prop$ and we write $\sat{p}{\prop}$.
\end{definition}

\begin{definition}[Hyperproperties]
  A hyperproperty $H$ is a set of admissible sets of traces. Thus, if $p$ satisfies $\prop$ (also written $\sat{p}{H}$), then $\behav{p}\in H$.
\end{definition}

\begin{lemma}[Lifting Properties]
  Given a property $\pi$, there exists a unique hyperproperty $\lift{\pi}$ that satisfies the exact same policy.
\end{lemma}
\begin{proof}
  \begin{align*}
                    && \forall p\in\partials,\sat{p}{\prop}&\equiv&\sat{p}{\lift{\prop}} \\
    \Leftrightarrow && \forall p\in\partials,\behav{p}\subseteq{\prop}&\equiv&\behav{p}\in\lift{\prop} \\
    \Leftrightarrow && \lift{\prop}&=&\left\{p\in\partials\ |\ \behav{p}\subseteq\prop\right\} \\
    \Leftrightarrow && \lift{\prop}&=&\powerset{\prop}
  \end{align*}
  Hereby, $\powerset{\prop}$ is the powerset of $\prop$.
\end{proof}

\begin{lemma}[Property Satisfaction Refinement]
  For a property $\prop$ that refines $\prop'$, i.e. $\prop\subseteq\prop'$, if any $p\in\partials$ satisfies $\sat{p}{\prop'}$, then $\sat{p}{\prop}$.
\end{lemma}
\begin{proof}
  Pick any property $\prop'$ and $p\in\partials$ such that $\sat{p}{\prop}$ and assume $\prop\subseteq\prop'$.
  Simple unfolding reveals $\behav{p}\subseteq\prop\implies\behav{p}\subseteq\prop'$.
\end{proof}
\noindent
For lifted properties, this refinement property also holds on the hyperproperty level.
However, it does not work for any hyperproperty~\cite{clarkson08}.

\begin{definition}[Robust Property Satisfaction]
  A program $p$ robustly satisfies a property $\prop$, written $\rsat{p}{\prop}$, iff $\forall C\in\partials,\sat{C\linker p}{\prop}$. The same notation is used for robust hyperproperty satisfaction.
\end{definition}

\begin{definition}[Classes]
  A class of hyperproperties $\cC$ is a set of hyperproperties.
  Likewise, a class of properties $\cC$ is a set of hyperproperties, where every property is lifted to the hyperproperty level.
  From now on, we use $\nu$ for elements of any class $\cC$ in case it does not matter whether it is a lifted property or any hyperproperty.
\end{definition}


\begin{definition}[Compilers]
  A compiler between languages $\S$ and $\T$ is a partial function $\stcomp{\bullet}$ from $\src{\partials}$ to $\trg{\partials}$.
\end{definition}

\begin{definition}[Robust Trace-Property Preservation]
  For a given class $\cC$, a compiler from languages $\S$ to $\T$ robustly preserves $\cC$ iff
  $$
  \forall\lift{\pi}\in\cC,\forall\src{p}\in\src{\partials},\sat{\src{p}}{\pi}\implies\sat{\stcomp{\src{p}}}{\pi}
  $$
  We write $\rtp{\stcomp{\bullet}}{\cC}$.
\end{definition}

\begin{definition}[Sequential Composition of Compilers]
  Given two compilers $\sicomp{\bullet}$ and $\itcomp{\bullet}$, their sequential composition is $\sitcomp{\bullet}=\itcompN{\sicomp{\bullet}}$.
\end{definition}

\begin{lemma}[Weakening RTP]
  Given classes $\cC_{1}, \cC_{2}$ such that $\cC_{1}\subseteq\cC_{2}$ and $\rtp{\stcomp{\bullet}}{\cC_{2}}$, we have $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
\end{lemma}
\begin{proof}
  Let $\prop\in\cC_{1}$, since $\cC_{1}\subseteq\cC_{2}$ we also know that $\prop\in\cC_{2}$.
  Let $\src{p}\in\src{\partials}$ such that $\sat{\src{p}}{\prop}$, we need to prove $\sat{\stcomp{\src{p}}}{\prop}$.
  This follows immediately from the assumption $\rtp{\stcomp{\bullet}}{\cC_{2}}$.
\end{proof}

\begin{lemma}[Hyperproperty Lattice]
  Hyperproperties with $\subseteq$ form a lattice.
\end{lemma}
\begin{proof}
  Obviously, a partial order. $\cap$ is least upper and $\cup$ greatest lower bound.
\end{proof}

\begin{definition}[Conjunctive Class Composition]
  The conjunctive composition of two classes of properties $\mathbb{C}_{1},\mathbb{C}_{2}$ is their set-intersection $\mathbb{C}_{1}\cap\mathbb{C}_{2}$.
\end{definition}

\begin{lemma}[Sequential Composition of RTP]
  Given $\rtp{\sicomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  $\;$\\
  \begin{tabular}{clcrl}
           &Have & \hspace{3cm} & Want&\\\hline
           & &  &     &\\[-0.2cm]
    $H_{1}$:& $\rtp{\sicomp{\src{\bullet}}}{\cC_{1}}$    &  &  &\\
    $H_{2}$:& $\rtp{\sicomp{\irl{\bullet}}}{\cC_{2}}$    &  & $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$ &\\\hline
    &&''unfold''&&\\[-0.2cm]
           &$\src{p}\in\src{\partials}$             &  & &\\
           &$\lift{\prop}\in\cC_{1}\cap\cC_{2}$       &  & &\\
    H: &$\sat{\src{p}}{\pi}$                    &  & $\sat{\sitcomp{\src{p}}}{\prop}$ &\\\hline
    &&''by $H_{2}$''&&\\[-0.2cm]
    &$\sicomp{\src{p}}\in\trg{\partials}$&&$\sat{\sicomp{\src{p}}}{\prop}$&\\\hline
    &&''by $H_{1}$''&&\\[-0.2cm]
    &&&$\sat{\src{p}}{\prop}$ &$\checkmark_{\tiny \text{by }H}$\\\hline
  \end{tabular}
  $\;$\\
\end{proof}

\begin{definition}[Upper Composition]
  Given two compilers $\stcomp{\bullet}$ and $\itcomp{\bullet}$, their upper composition is

  $$\uhcsitcomp{\bullet}=\lambda p.\begin{cases}\stcomp{p} &\text{if }p\in\src{\partials}\\
                                                \itcomp{p} &\text{if }p\in\irl{\partials}\end{cases}$$.
\end{definition}

\begin{lemma}[Upper Composition of RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\uhcsitcomp{\bullet}}{\cC_{1}\cup\cC_{2}}$.
\end{lemma}
\begin{proof}
  Consider any program $\src{p}$.
  The result of $\uhcsitcomp{\src{p}}$ is exactly the same as of $\stcomp{p}$ and since $\rtp{\stcomp{\bullet}}{\cC_{1}}$, we have that $\rtp{\uhcsitcomp{\src{p}}}{\cC_{1}}$.
  By a completely analogous argument for $\irl{p}$, we get $\rtp{\uhcsitcomp{\irl{p}}}{\cC_{2}}$.
  Since $\uhcsitcomp{\bullet}$ preserves both $\cC_{1}$ and $\cC_{2}$, we know that $\rtp{\uhcsitcomp{\bullet}}{\cC_{1}\cup\cC_{2}}$.
\end{proof}

\begin{definition}[Lower Composition]
  Given two compilers $\stcomp{\bullet}$ and $\sicomp{\bullet}$, their lower composition is $\lhcsitcomp{\bullet}$.
\end{definition}
\MK{this is a bit nonsensical. what should the compiler compile to?}



\begin{definition}[Safety Properties]
  The class of safety properties contains the lifting of all properties that can be refuted with a finite trace prefix:
  $$
  \cSafety = \left\{\lift{\prop}\ |\ \forall \trace\in\traces, t\not\in\prop \text{ iff } \exists m\ge\trace,\forall \trace'\in\traces,m\le\trace'\implies\trace'\not\in\prop\right\}
  $$
\end{definition}

\begin{definition}[Subset Closed Hyperproperties]
  The class of hyperproperties that are closed with respect to the subset relation is
  $$
  \cSS = \left\{H\ |\ \forall X\in H, \forall Y\subseteq X, Y \in H\right\}
  $$
\end{definition}


\bibliographystyle{plain}
\bibliography{library}

\end{document}
