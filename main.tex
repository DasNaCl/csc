\documentclass[a4paper,names,dvipsnames]{article}

\usepackage[T1]{fontenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{glossaries}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage[capitalize]{cleveref}
\usepackage{bm}
\usepackage{xspace}
\usepackage{etoolbox}
\usepackage{cite}

\usepackage{tikz}
\usetikzlibrary{positioning}

\usepackage{mmmacros}
% \usepackage{./../mmmacros}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

% \loadglsentries{./../acronyms}
\loadglsentries{acronyms}
\makeglossaries

\newcommand{\MK}[1]{\todo[color=orange!30]{TODO: #1}}
\newcommand{\MP}[1]{\todo[color=blue!30]{TODO: #1}}

% Definition of Ddots
\makeatletter
\def\Ddots{\mathinner{\mkern1mu\raise\p@
\vbox{\kern7\p@\hbox{.}}\mkern2mu
\raise4\p@\hbox{.}\mkern2mu\raise7\p@\hbox{.}\mkern1mu}}
\makeatother

\begin{document}

\begin{definition}[Events]\label{def:events}
  $\events$ is the set of atomic propositions hereby called events or actions.
  The internal action is $\emptyevent$.
  The action $\terminationevent$ is program termination.
\end{definition}

\begin{definition}[Programming Languages]\label{def:pl}
A programming language is a tuple $\left(\partials,\wellf,\singlestep,\linker\right)$ s.t.:

\begin{itemize}
  \item[$\partials$] : Set - is a set of admissible, partial programs.
  \item[$\wellf$] : $\partials$ - a judgement that holds iff a program is not partial.
  \item[$\singlestep$] : $\wholes\to\events\to\wholes$ - a step relation, where $\wholes=\{w\in\partials\ |\ \wellf w\}$.
        For $e\in\events$ and $p,p'\in\wholes$ we say for $\estep{p}{e}{p'}$ that program $p$ performs a step with action $e$ to program $p'$.
        If $e=\emptyevent$, we write $\step{p}{p'}$.
        In case $e=\terminationevent$, we write $\terminates{p}$.
  \item[$\linker$] : $\partials\to\partials\to\partials$ - links two partial programs together in some way, resulting in a new partial program.
\end{itemize}
\end{definition}
Let $\src{S},\irl{I},$ and $\trg{T}$ be any programming language.

% if we get τ1 and τ2, then there is aontehr program that does τ3 which does τ1 and τ2 in parallel
% define self-composition. and then define it with respect to low-equivalent programs
%

% compilation of n compilers can b e reduced to compilation of two compilers

\begin{definition}[Notation for Sequences]
  For any sequence of events, let $\seqnil$ denote the empty sequence and $\seqcons{e}{\bar{t}}$ the sequence that starts with $e$ and continues with $\bar{t}$.
  Hereby, it does not matter whether $\bar{t}$ is finite or infinite, it's merely syntactic sugar to work on sequences of events.
\end{definition}

\begin{definition}[Traces]
  A trace $\trace$ is an infinite sequence of events that results from the relation $\singlestep$.
  That is, we obtain the trace $\trace=\seqcons{e_{0}}{\seqcons{e_{1}}{\dots}}$ for the execution sequence $\estep{p}{e_{0}}{\estep{p'}{e_{1}}{\dots}}$ and write $\mktrace{p}{\trace}$.
  The set of all traces is $\traces$.
\end{definition}
\noindent
We assume $\lightning$ to occur in traces representing terminating programs such that it occurs infinitely often in a one-by-one sequence.

\begin{definition}[Finite Trace Prefixes]
  A finite sequence of events $m$ is a finite trace prefix of $\trace$ iff it satisfies the following judgement.

  $$
    \inference{}{\cdot\le\trace}\hspace{2em}\inference{m\le\trace}{\seqcons{e}{m}\le \seqcons{e}{\trace}}
  $$
\end{definition}

\begin{definition}[Behavior]
  The behavior of a whole program $p$ is a set of all traces it produces, i.e. $\behav{p}=\{\trace\ |\ \mktrace{p}{\trace}\}$.
\end{definition}

\begin{definition}[Observation]
  An observation is a finite set of finite trace prefixes.
  We say that an observation $o$ is the prefix of a behavior $b$ iff $$\forall m\in o.\exists \trace\in b.m\le t$$.
\end{definition}

\begin{definition}[Properties]
  A property $\prop$ is a set of admissible traces. For a program $p$ to satisfy $\prop$ it must not produce a trace that is not part of $\prop$. Thus, $p$ satisfies $\prop$ iff $\behav{p}\subseteq\prop$ and we write $\sat{p}{\prop}$.
\end{definition}

\begin{definition}[Hyperproperties]
  A hyperproperty $H$ is a set of admissible sets of traces. Thus, if $p$ satisfies $H$ (also written $\sat{p}{H}$), then $\behav{p}\in H$.
\end{definition}

\begin{lemma}[Lifting Properties]
  Given a property $\pi$, there exists a unique hyperproperty $\lift{\pi}$ that satisfies the exact same policy.
\end{lemma}
\begin{proof}
  We want $\forall p \in\partials, \sat{p}{\prop}\equiv\sat{p}{\lift{\prop}}$.
  Henceforth, given a $p\in\partials$, we have $\behav{p}\subseteq\prop$ iff $\behav{p}\in\lift{\prop}$.
  Note that if $\behav{p}\subseteq\prop$, we have $\behav{p}\in\left\{\Pi\ |\ \Pi=\behav{p}\subseteq\prop\right\}$.
  Thus, $\lift{\prop}$ is the set of all possible program behaviors that are a subset of $\prop$.
  This is exactly the powerset of $\prop$ and we conclude $\lift{\prop}=\powerset{\prop}$.
\end{proof}
\noindent
The lifting of properties to a singleton set does not suffice, since the empty behavior trivially satisfies any property $\emptyset\subseteq\prop=\{\trace\}$, but if we would define $\lift{\trace}=\{\{\trace\}\}$, then $\emptyset\not\in\lift{\trace}$.

\begin{lemma}[Property Satisfaction Refinement]
  For a property $\prop$ that refines $\prop'$, i.e. $\prop\subseteq\prop'$, if any $p\in\partials$ satisfies $\sat{p}{\prop'}$, then $\sat{p}{\prop}$.
\end{lemma}
\begin{proof}
  Pick any property $\prop'$ and $p\in\partials$ such that $\sat{p}{\prop}$ and assume $\prop\subseteq\prop'$.
  Simple unfolding reveals $\behav{p}\subseteq\prop\implies\behav{p}\subseteq\prop'$.
\end{proof}
\noindent
For lifted properties, this refinement property also holds on the hyperproperty level.
However, it does not work for any hyperproperty~\cite{clarkson08}.

\begin{definition}[Robust Property Satisfaction]
  A program $p$ robustly satisfies a property $\prop$, written $\rsat{p}{\prop}$, iff $\forall C\in\partials,\sat{C\linker p}{\prop}$. The same notation is used for robust hyperproperty satisfaction.
\end{definition}

\begin{definition}[Classes]
  A class of hyperproperties $\cC$ is a set of hyperproperties.
  Likewise, a class of properties $\cC$ is a set of hyperproperties, where every property is lifted to the hyperproperty level.
  From now on, we use $\Pi$ for elements of any class $\cC$ in case it does not matter whether it is a lifted property or any hyperproperty.
\end{definition}


\begin{definition}[Compilers]
  A compiler between languages $\S$ and $\T$ is a partial function $\stcomp{\bullet}$ from $\src{\partials}$ to $\trg{\partials}$.
\end{definition}

\begin{definition}[Robust Trace-Hyperproperty Preservation]
  For a given class $\cC$, a compiler from languages $\S$ to $\T$ robustly preserves $\cC$ iff
  $$
  \forall\Pi\in\cC,\forall\src{p}\in\src{\partials},\rsat{\src{p}}{\Pi}\implies\rsat{\stcomp{\src{p}}}{\Pi}
  $$
  We write $\rtp{\stcomp{\bullet}}{\cC}$.
\end{definition}

\begin{definition}[Sequential Composition of Compilers]
  Given two compilers $\sicomp{\bullet}$ and $\itcomp{\bullet}$, their sequential composition is $\sitcomp{\bullet}=\itcompN{\sicomp{\bullet}}$.
\end{definition}

\begin{lemma}[Weakening RTP]
  Given classes $\cC_{1}, \cC_{2}$ such that $\cC_{1}\subseteq\cC_{2}$ and $\rtp{\stcomp{\bullet}}{\cC_{2}}$, we have $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
\end{lemma}
\begin{proof}
  We need to show $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
  Let $\Pi\in\cC_{1}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$, so what's left to prove is $\rsat{\stcomp{p}}{\Pi}$.
  Since $\cC_{1}\subseteq\cC_{2}$ and $\Pi\in\cC_{1}$, we know that $\Pi\in\cC_{2}$.
  Thus, we can apply the assumption $\rtp{\stcomp{\bullet}}{\cC_{2}}$ to our goal, leaving us with $\rsat{\src{p}}{\Pi}$ to show, which was an assumption we made.
\end{proof}


\begin{definition}[Safety Properties]
  The class of safety properties contains the lifting of all properties that can be refuted with a finite trace prefix:
  $$
  \cSafety = \left\{\lift{\prop}\ |\ \forall \trace\in\traces, t\not\in\lift{\prop} \text{ iff } \exists m\ge\trace,\forall \trace'\in\traces,m\le\trace'\implies\trace'\not\in\lift{\prop}\right\}
  $$
\end{definition}

\begin{definition}[Hypersafety Properties]
  The class of hypersafety properties contains all hyperpropert that can be refuted with an observation:
  $$
  \cHSafety = \left\{\Pi\ |\ \forall b\in 2^{\traces},b\not\in\Pi\text{ iff  }\exists o\ge b,\forall b'\in 2^{\traces},o\le b'\implies b'\not\in\Pi\right\}
  $$
\end{definition}

\begin{lemma}[Safety is entailed in Hypersafety]
  $\cSafety\subseteq\cHSafety$.
\end{lemma}

\begin{definition}[Subset Closed Hyperproperties]
  The class of hyperproperties that are closed with respect to the subset relation is
  $$
  \cSS = \left\{H\ |\ \forall X\in H, \forall Y\subseteq X, Y \in H\right\}
  $$
\end{definition}

\begin{lemma}[Hypersafety is entailed in SSC]
  $\cHSafety\subseteq\cSS$.
\end{lemma}


\begin{lemma}[Classes Lattice]
  Classes with $\subseteq$ form a lattice.
\end{lemma}
\begin{proof}
  The class with all hyperproperties is the top element $\top$, while the class with no hyperproperties whatsoever is $\bot$.
  Obviously, a partial order due to set inclusion.
  $\cap$ is least upper and $\cup$ greatest lower bound of any given pair of subsets of a given class.
\end{proof}

\begin{figure}[h]
  \centering
\begin{tikzpicture}[node distance=4mm,every node/.style={align=center}]
  \node (top) {$\top$};
  \node[below = of top.south] (SSC) {$\cSS$};
  \node[below = of SSC.south] (HSafe) {$\cHSafety$};
  \node[below = of HSafe.south] (HKSafe) {$\cKHSafety$};
  \node[left = of HKSafe.west] (H2Safe) {$\cTwoHSafety$};
  \node[right = of HKSafe.east] (Safe) {$\cSafety$};

  % Specialized classes
  \node[below left = of Safe.south] (Mutex) {$\mutex$};
  \node[below right = of Safe.south] (NonTerm) {$\nonterm$};

  \node[below left = of H2Safe.south] (Determ) {$\determ$};
  \node[below right = of H2Safe.south] (NI) {$\Ni$};

  \node[below = of HKSafe.south] (emptyspace) {};
  \node[below = of emptyspace.south] (Bot) {$\bot$};

  % edges
  \draw[-] (top.south) to (SSC.north);
  \draw[-] (SSC.south) to (HSafe.north);
  \draw[-] (HSafe.south) to (HKSafe.north);
  \draw[-] (HSafe.south) to (H2Safe.north);
  \draw[-] (HSafe.south) to (Safe.north);
  \draw[-] (H2Safe.south) to (Determ.north);
  \draw[-] (H2Safe.south) to (NI.north);
  \draw[-] (Safe.south) to (Mutex.north);
  \draw[-] (Safe.south) to (NonTerm.north);
  \draw[-] (Determ.south) to (Bot.north);
  \draw[-] (NI.south) to (Bot.north);
  \draw[-] (HKSafe.south) to (Bot.north);
  \draw[-] (Mutex.south) to (Bot.north);
  \draw[-] (NonTerm.south) to (Bot.north);
\end{tikzpicture}
\caption{Sketch of a fraction of the infinitely sized lattice of classes.}
\end{figure}

% get rid of units
% draw similarily as with journey, do the subseteq on a slope

% two instances of safety and hypersafety
% add 2-safety

\begin{definition}[Conjunctive Class Composition]
  The conjunctive composition of two classes of properties $\mathbb{C}_{1},\mathbb{C}_{2}$ is their set-intersection $\mathbb{C}_{1}\cap\mathbb{C}_{2}$.
\end{definition}

\begin{lemma}[Sequential Composition with RTP]\label{lem:seqcompo}
  Given $\rtp{\sicomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  We need to show $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
  By definition, assume $\Pi\in\cC_{1}\cap\cC_{2}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$.
  What is left to show is $\rsat{\sitcomp{\src{p}}}{\prop}$.
  Note that $\Pi\in\cC_{2}$ and that $\sicomp{\src{p}}\in\irl{\partials}$, allowing us to apply $\rtp{\itcomp{\bullet}}{\cC_{2}}$ changing our goal to $\rsat{\sicomp{\src{p}}}{\Pi}$.
  Since $\Pi\in\cC_{1}$ also holds, we can this time apply $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
  What is left to show is $\rsat{\src{p}}{\Pi}$, which is an assumption of ours.
\end{proof}

\begin{definition}[Upper Composition]
  Given two compilers $\stcomp{\bullet}$ and $\itcomp{\bullet}$, their upper composition is

  $$\uhcsitcomp{\bullet}=\lambda p.\begin{cases}\stcomp{p} &\text{if }p\in\src{\partials}\\
                                                \itcomp{p} &\text{if }p\in\irl{\partials}\end{cases}$$.
\end{definition}

\begin{lemma}[Upper Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\uhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Analogous argument as in \Cref{lem:seqcompo}, but with a case distinction on whether the source program is element of $\S$ or $\I$.
\end{proof}

\begin{definition}[Lower Composition]
  Given two compilers $\stcomp{\bullet}$ and $\sicomp{\bullet}$, their lower composition is $\lhcsitcomp{\bullet}$.
\end{definition}

\begin{lemma}[Lower Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\sicomp{\bullet}}{\cC_{2}}$, then $\rtp{\lhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Analogous argument as in \Cref{lem:seqcompo}, but with a case distinction on whether the compiled source program is element of $\I$ or $\T$.
\end{proof}

% spectre : compile one part to v4, the other to v5

% are we always just preserving the lub? can we preserve something stronger?
% => goal is to make target class in composed compiler stronger

% hypersafety implies safety    prove safety preservation, implies hypersafety (for some reasonable constraints)
%

% going a level deeper: what can we say about individual properties? composing individual props
% e.g. prop for spec safety and memsafety, how does their conjunction work out?
%
% speculative safety encompasses hypersafety

% constant time : assumes memsafety, then somethings, thus crypto const time
%
%

\begin{lemma}[Diamond]\label{lem:diamond}
  Given $\rtp{\lhcsiocomp{\bullet}}{\cC_{1}}$ and $\rtp{\uhciotcomp{\bullet}}{\cC_{2}}$ with $\stcomp{\bullet} = \lambda\src{p}.\uhciotcomp{\lhcsiocomp{p}}$, then $\rtp{\stcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Straightforward using \Cref{lem:seqcompo}.
\end{proof}

\begin{lemma}[Swappable]
  Given $\rtp{\ttcomp{\bullet}_{(1)}}{\cC_{1}}$ and $\rtp{\ttcomp{\bullet}_{(2)}}{\cC_{2}}$, then $\rtp{\ttcompN{\ttcomp{\bullet}_{(2)}}_{(1)}}{\cC_{1}\cap\cC_{2}}$ and $\rtp{\ttcompN{\ttcomp{\bullet}_{(1)}}_{(2)}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Both follow from \Cref{lem:seqcompo}.
\end{proof}

\begin{definition}[Low-Equivalence]
  Two traces $\trace_{1}$,$\trace_{2}$ are low-equivalent $\loweq{\trace_{1}}{\trace_{2}}$ iff all their public events coincide.
\end{definition}

\begin{definition}[Non-Interference ($\Ni$)]
  We define the class containing the non-interference hyperproperty as:
  $$
  \Ni = \left\{ H | \forall \trace_{1},\trace_{2}\in H. \loweq{\trace_{1}}{\trace_{2}}\implies\trace_{1}=\trace_{2} \right\}
  $$
\end{definition}
Note that $=$ may not be strict equality, but some suitable trace equivalence that checks both public and private actions, instead of just public.

% TODO: glossaries....? :^)
\begin{definition}[Speculative Safety~\cite{exorcisingSpectres}]
  Given a set $\policy$, we define speculative safety as follows:

  $$
  \ss = \left\{ \lift{\prop}\ |\ \forall\trace\in \prop.\trace=e_{0}e_{1}\dots\implies e_{0}\in\policy\wedge e_{1}\in\policy\wedge\dots\right\}
  $$
\end{definition}

\begin{lemma}[$\ss$ over-approximates $\RNi$~\cite{exorcisingSpectres}]
  Provided that a suitable language $\T$ fulfills the overapproximation lemma $\forall\trg{p}\in\trg{\partials}.\rsat{\trg{p}}{\rss}\implies\rsat{\trg{p}}{\RNi}$, it holds that,
  given $\rtp{\sicomp{\bullet}}{\RNi}$ and $\rtp{\itcomp{\bullet}}{\rss}$, $\rtp{\sitcomp{\bullet}}{\RNi}$.
\end{lemma}
\begin{proof}

  {\large\color{red} doesn't work}, we need at some point show that given $\prop\in\RNi$ we have $\prop\in\rss$, which isn't true.
  Proving $\rtp{\sitcomp{\bullet}}{\rss}$ is easy, thought, it's just the lub again...


\end{proof}


\begin{definition}[Finer Conjunctive Class Composition]
  The finer conjunctive class composition of two classes $\cC_{1},\cC_{2}$ is
  $$
  \fccomp{\cC_{1}}{\cC_{2}} := \left\{H\ |\ \forall H_{1}\in\cC_{1},H_{2}\in\cC_{2}.H=H_{1}\cap H_{2}\right\} \cup (\cC_{1}\cap\cC_{2})
  $$
\noindent
  Likewhise, we define a new less-than operation for the lattice as follows
  $$
  \fcleq{\cC_{1}}{\cC_{2}} := \cC_{1}\subseteq\fccomp{\cC_{1}}{\cC_{2}}
  $$
\end{definition}

\begin{lemma}[Finer Sequential Composition with RTP]\label{lem:fseqcompo}
  Given $\cC_{1}$ and $\cC_{2}$ are subset-closed with respect to $\subseteq$, $\rtp{\sicomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\sitcomp{\bullet}}{\fccomp{\cC_{1}}{\cC_{2}}}$.
\end{lemma}
\begin{proof}
  We need to show $\rtp{\sitcomp{\bullet}}{\fccomp{\cC_{1}}{\cC_{2}}}$.
  By definition, assume $\Pi\in\fccomp{\cC_{1}}{\cC_{2}}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$.
  By definition of $\fccomp{}{}$, $\Pi\in\cC_{1}\cap\cC_{2}$, which is analogous case as with \Cref{lem:seqcompo}, or $\Pi\in\left\{H\ |\ \forall H_{1}\in\cC_{1},H_{2}\in\cC_{2}.H=H_{1}\cap H_{2}\right\}$.
  So, pick any $H_{1}\in\cC_{1},H_{2}\in\cC_{2}$, such that $\Pi=H_{1}\cap H_{2}$.
  Since $\cC_{2}$ is subset closed, we can apply $\rtp{\itcomp{\bullet}}{\cC_{2}}$ to our goal, leaving us with $\rsat{\sicomp{\src{p}}}{\Pi}$.
  Since $\cC_{1}$ is also subset closed, we know that $\Pi\in\cC_{1}$ and, thus, can apply $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
  What is left to show is $\rsat{\src{p}}{\Pi}$, which is an assumption of ours.
\end{proof}


% if language has a form of parallel self-composition and the compiler preserves RTP(Safety), then it also preserves k-RSHP
%   -> self composition is on the program graph level. we can always write an interpreter that allows this

\clearpage
Experimental
\begin{definition}[Encoders]
  An encoder $\tenc{\src{\bullet}}$ from language $\S$ to $\T$ is a function that constructs an abstract representation of the given $\S$ program as a $\T$ program.
\end{definition}
\noindent
Think of encoders as parsers.

\begin{definition}[Interpreters]
  An interpreter $\stinterp$ is a $\T$ program that faithfully implements the semantics of $\S$.
  That is, given $\src{p}\in\src{\partials}$ and some encoding function $\tenc{\src{\bullet}}$, then $\mktrace{\stinterp \trg{\linker} \tenc{\src{p}}}{\tau} \Leftrightarrow \mktrace{\src{p}}{\tau}$.
\end{definition}
Note: For an interpreter to \textit{faithfully} realize the semantics of $\S$, we really need the equivalence.
Say we only consider the $\Leftarrow$ direction as defining characteristic, then an interpreter that e.g. tosses a coin and thus $\behav{\stinterp\trg{\linker}\tenc{\src{p}}}=\{\trace_{1},\trace_{2}\}$ given $\behav{\src{p}}=\{\trace_{1}\}$ would be acceptable.
However, an interpreter that 99\% of the time emits $\trace_{2}$ is certainly not what we want.
Consider the converse, so $\Rightarrow$ as defining characteristic.
Then, swapping the behaviors from the previous example, the interpreter does not \textit{faithfully} simulate non-determinism that is present in the source language.
% Due to this, interpreters in our world always robustly satisfy relational hyperproperties

\begin{definition}[Specializers]
  A specializer $\ttspec{\bullet}$ is a $\T$ program that, given an encoding of another $\T$ program as input, emits a specialized version of that $\T$ program.
  So, given a partial program $\trg{p}$ and some set of inputs $\trg{x}\in\trg{\partials}$, $\ttspec{\tenc{p \linker x}}$ always terminates with a residual program $\trg{p'}$ such that $\behav{\trg{p\linker x}}=\behav{\trg{p'}}$.
\end{definition}
\noindent

\begin{definition}[2nd Futamura Projection]
  Given a specializer $\ttspec{\bullet}$, an interpreter $\stinterp$, and an encoding $\tenc{\src{\bullet}}$, we can compose them to a compiler $\stcomp{\bullet} = \ttspec{\stinterp \tenc{\src{\bullet}}}$.~\cite{Futamura1999}
\end{definition}

\clearpage

Next up:

compositionality of different robust preservation properties (?)


\bibliographystyle{plain}
\bibliography{library}

\end{document}
