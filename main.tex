\documentclass[a4paper,names,dvipsnames]{article}

\usepackage[T1]{fontenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{glossaries}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{marvosym}
\usepackage{halloweenmath}
\usepackage[capitalize]{cleveref}
\usepackage{bm}
\usepackage{xspace}
\usepackage{etoolbox}
\usepackage{natbib}
\usepackage{xfrac}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{scontents}

% workaround to use extpfeil and stmaryrd together.
% see https://tex.stackexchange.com/questions/297108/
\expandafter\def\csname opt@stmaryrd.sty\endcsname
{only,shortleftarrow,shortrightarrow}
\usepackage{extpfeil}

\usepackage{tikz}
\usetikzlibrary{positioning,calc}

\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newcounter{theoremcounter}
\newtheorem{theorem}[theoremcounter]{Theorem}

\input{includes}
\makeglossaries

\newcommand{\MK}[1]{\todo[color=orange!30]{TODO: #1}}
\newcommand{\MP}[1]{\todo[color=blue!30]{TODO: #1}}

% Definition of Ddots
\makeatletter
\def\Ddots{\mathinner{\mkern1mu\raise\p@
\vbox{\kern7\p@\hbox{.}}\mkern2mu
\raise4\p@\hbox{.}\mkern2mu\raise7\p@\hbox{.}\mkern1mu}}
\makeatother

\begin{document}
\tableofcontents
\clearpage

\section{Preliminaries}

\begin{definition}[Events]\label{def:events}
  $\events$ is the set of atomic propositions hereby called events or actions.
  The internal action is $\emptyevent$.
  The action $\terminationevent$ is program termination.
\end{definition}


We assume that any programming language can be enriched with a self-composition operator in the style of \citet{barthe11}.
Furthermore, we also assume the existence of a low-equivalence relation that distinguishes program states only by their public memory.
Two traces $\trace_{1}$,$\trace_{2}$ are low-equivalent $\loweq{\trace_{1}}{\trace_{2}}$ iff all their public events coincide.

\begin{definition}[Programming Languages]\label{def:pl}
A programming language is a tuple $\left(\partials,\wellf,\singlestep,\linker\right)$ s.t.:

\begin{itemize}
  \item[$\partials$] : Set - is a set of admissible, partial programs.
  \item[$\wellf$] : $\partials$ - a judgement that holds iff a program is not partial.
  \item[$\singlestep$] : $\wholes\to\events\to\wholes$ - a step relation, where $\wholes=\{w\in\partials\ |\ \wellf w\}$.
        For $e\in\events$ and $p,p'\in\wholes$ we say for $\estep{p}{e}{p'}$ that program $p$ performs a step with action $e$ to program $p'$.
        If $e=\emptyevent$, we write $\step{p}{p'}$.
        In case $e=\terminationevent$, we write $\terminates{p}$.
  \item[$\linker$] : $\partials\to\partials\to\partials$ - links two partial programs together in some way, resulting in a new partial program.
\end{itemize}
\end{definition}
Let $\src{S},\irl{I},$ and $\trg{T}$ be any programming language.

% if we get τ1 and τ2, then there is aontehr program that does τ3 which does τ1 and τ2 in parallel
% define self-composition. and then define it with respect to low-equivalent programs
%

\begin{definition}[Notation for Sequences]
  For any sequence of events, let $\seqnil$ denote the empty sequence and $\seqcons{e}{\bar{t}}$ the sequence that starts with $e$ and continues with $\bar{t}$.
  Hereby, it does not matter whether $\bar{t}$ is finite or infinite, it's merely syntactic sugar to work on sequences of events.
\end{definition}

\begin{definition}[Traces]
  A trace $\trace$ is an infinite sequence of events that results from the relation $\singlestep$.
  That is, we obtain the trace $\trace=\seqcons{e_{0}}{\seqcons{e_{1}}{\dots}}$ for the execution sequence $\estep{p}{e_{0}}{\estep{p'}{e_{1}}{\dots}}$ and write $\mktrace{p}{\trace}$.
  The set of all traces is $\traces$.
\end{definition}
\noindent
We assume $\lightning$ to occur in traces representing terminating programs such that it occurs infinitely often in a one-by-one sequence.

\begin{definition}[Finite Trace Prefixes]
  A finite sequence of events $m$ is a finite trace prefix of $\trace$ iff it satisfies the following judgement.

  $$
    \inference{}{\cdot\le\trace}\hspace{2em}\inference{m\le\trace}{\seqcons{e}{m}\le \seqcons{e}{\trace}}
  $$
\end{definition}

\begin{definition}[Behavior]
  The behavior of a whole program $p$ is a set of all traces it produces, i.e. $\behav{p}=\{\trace\ |\ \mktrace{p}{\trace}\}$.
\end{definition}

\begin{definition}[Observation]
  An observation is a finite set of finite trace prefixes.
  We say that an observation $o$ is the prefix of a behavior $b$ iff $$\forall m\in o.\exists \trace\in b.m\le t$$.
\end{definition}

\begin{definition}[Properties]
  A property $\prop$ is a set of admissible traces. For a program $p$ to satisfy $\prop$ it must not produce a trace that is not part of $\prop$. Thus, $p$ satisfies $\prop$ iff $\behav{p}\subseteq\prop$ and we write $\sat{p}{\prop}$.
\end{definition}

\begin{definition}[Hyperproperties]
  A hyperproperty $H$ is a set of admissible sets of traces. Thus, if $p$ satisfies $H$ (also written $\sat{p}{H}$), then $\behav{p}\in H$.
\end{definition}

\begin{lemma}[Lifting Properties]
  Given a property $\pi$, there exists a unique hyperproperty $\lift{\pi}$ that satisfies the exact same policy.
\end{lemma}
\begin{proof}
  We want $\forall p \in\partials, \sat{p}{\prop}\equiv\sat{p}{\lift{\prop}}$.
  Henceforth, given a $p\in\partials$, we have $\behav{p}\subseteq\prop$ iff $\behav{p}\in\lift{\prop}$.
  Note that if $\behav{p}\subseteq\prop$, we have $\behav{p}\in\left\{\Pi\ |\ \Pi=\behav{p}\subseteq\prop\right\}$.
  Thus, $\lift{\prop}$ is the set of all possible program behaviors that are a subset of $\prop$.
  This is exactly the powerset of $\prop$ and we conclude $\lift{\prop}=\powerset{\prop}$.
\end{proof}
\noindent
The lifting of properties to a singleton set does not suffice, since the empty behavior trivially satisfies any property $\emptyset\subseteq\prop=\{\trace\}$, but if we would define $\lift{\trace}=\{\{\trace\}\}$, then $\emptyset\not\in\lift{\trace}$.

\begin{lemma}[Property Satisfaction Refinement]
  For a property $\prop$ that refines $\prop'$, i.e. $\prop\subseteq\prop'$, if any $p\in\partials$ satisfies $\sat{p}{\prop'}$, then $\sat{p}{\prop}$.
\end{lemma}
\begin{proof}
  Pick any property $\prop'$ and $p\in\partials$ such that $\sat{p}{\prop}$ and assume $\prop\subseteq\prop'$.
  Simple unfolding reveals $\behav{p}\subseteq\prop\implies\behav{p}\subseteq\prop'$.
\end{proof}
\noindent
For lifted properties, this refinement property also holds on the hyperproperty level.
However, it does not work for any hyperproperty~\cite{clarkson08}.

\begin{definition}[Robust Property Satisfaction]
  A program $p$ robustly satisfies a property $\prop$, written $\rsat{p}{\prop}$, iff $\forall C\in\partials,\sat{C\linker p}{\prop}$. The same notation is used for robust hyperproperty satisfaction.
\end{definition}

\begin{lemma}[Weakening Robust Satisfaction]\label{lem:weaken-rsat}
  Given classes $\cC_{1}, \cC_{2}$ and any program $p$ such that
  \begin{assumptions}
    \item\label{lem:weaken-rsat:ass:a} $\cC_{1}\subseteq\cC_{2}$
    \item\label{lem:weaken-rsat:ass:b} $\rsat{p}{\cC_{2}}$
  \end{assumptions}
  We show
  \begin{goals}
    \item\label{lem:weaken-rsat:goal:i} $\rsat{p}{\cC_{1}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Unfolding \Thmref{lem:weaken-rsat:goal:i}, let $\Pi\in\cC_{2}$ and $p$ be a program, we want to show that $\rsat{p}{\Pi}$.
  By \Thmref{lem:weaken-rsat:ass:a}, we also know that $\Pi\in\cC_{1}$.
  Thus, we can use \Thmref{lem:weaken-rsat:ass:b} to conclude.
\end{proof}

\begin{definition}[Classes]
  A class of hyperproperties $\cC$ is a set of hyperproperties.
  Likewise, a class of properties $\cC$ is a set of hyperproperties, where every property is lifted to the hyperproperty level.
  From now on, we use $\Pi$ for elements of any class $\cC$ in case it does not matter whether it is a lifted property or any hyperproperty.
\end{definition}

\begin{definition}[Compilers]
  A compiler between languages $\S$ and $\T$ is a partial function $\stcomp{\bullet}$ from $\src{\partials}$ to $\trg{\partials}$.
\end{definition}

\section{Compositionality of Secure Compilers}

\begin{definition}[Robust Trace-Hyperproperty Preservation]\label{def:rtp}
  For a given class $\cC$, a compiler from languages $\S$ to $\T$ robustly preserves $\cC$ iff
  $$
  \forall\Pi\in\cC,\forall\src{p}\in\src{\partials},\rsat{\src{p}}{\Pi}\implies\rsat{\stcomp{\src{p}}}{\Pi}
  $$
  We write $\rtp{\stcomp{\bullet}}{\cC}$.
  In case we write $\rtp{\stcomp{\bullet}}{\collapse{\cC}}$, substitute the $\cC$ in above definition with $\left\{ \collapse{\cC} \right\}$.
\end{definition}

\begin{definition}[Sequential Composition of Compilers]
  Given two compilers $\sicomp{\bullet}$ and $\itcomp{\bullet}$, their sequential composition is $\sitcomp{\bullet}=\itcompN{\sicomp{\bullet}}$.
\end{definition}
% we can propagate through the assumptions from src langs to intermediate langs
%

\begin{lemma}[Weakening RTP]\label{lem:weaken}
  Given classes $\cC_{1}, \cC_{2}$ such that
  \begin{assumptions}
    \item $\cC_{1}\subseteq\cC_{2}$
    \item $\rtp{\stcomp{\bullet}}{\cC_{2}}$
  \end{assumptions}
  We show
  \begin{goals}
    \item $\rtp{\stcomp{\bullet}}{\cC_{1}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Using \Cref{def:rtp} on the goal, let $\Pi\in\cC_{1}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$, so what's left to prove is $\rsat{\stcomp{p}}{\Pi}$.
  Since $\cC_{1}\subseteq\cC_{2}$ and $\Pi\in\cC_{1}$, we know that $\Pi\in\cC_{2}$.
  Thus, we can apply the assumption $\rtp{\stcomp{\bullet}}{\cC_{2}}$ to our goal, leaving us with $\rsat{\src{p}}{\Pi}$ to show, which was an assumption we made.
\end{proof}

\begin{definition}[Safety Properties]
  The class of safety properties contains the lifting of all properties that can be refuted with a finite trace prefix:
  $$
  \cSafety = \left\{\lift{\prop}\ |\ \forall \trace\in\traces, t\not\in\lift{\prop} \text{ iff } \exists m\ge\trace,\forall \trace'\in\traces,m\le\trace'\implies\trace'\not\in\lift{\prop}\right\}
  $$
\end{definition}

\begin{definition}[Hypersafety Properties]\label{def:hsafety}
  The class of hypersafety properties contains all hyperpropert that can be refuted with an observation:
  $$
  \cHSafety = \left\{\Pi\ |\ \forall b\in 2^{\traces},b\not\in\Pi\text{ iff  }\exists o\ge b,\forall b'\in 2^{\traces},o\le b'\implies b'\not\in\Pi\right\}
  $$
\end{definition}

\begin{lemma}[Safety is entailed in Hypersafety]
  $\cSafety\subseteq\cHSafety$.
\end{lemma}

\begin{definition}[Subset Closed Hyperproperties]
  The class of hyperproperties that are closed with respect to the subset relation is
  $$
  \cSS = \left\{H\ |\ \forall X\in H, \forall Y\subseteq X, Y \in H\right\}
  $$
\end{definition}

\begin{lemma}[Hypersafety is entailed in SSC]
  $\cHSafety\subseteq\cSS$.
\end{lemma}

\begin{definition}[K-Hypersafety]
  Exactly the same as \Cref{def:hsafety}, but the observations $o$ are restricted to cardinality $k$.
  2-Hypersafety is simply $k=2$. \Cref{def:ni} gives an example instance of a classic 2-hypersafe property.
\end{definition}

\begin{definition}[Nontermination]
  Nontermination is a safety property: Any finite trace prefix with $\terminationevent$ violates this property.
\end{definition}

\begin{definition}[Mutual Exclusion]
  Mutual Exclusion (MutEx) means that no two processes during a program execution enter the same critical section.
\end{definition}

\begin{definition}[Determinism]
  Determinism is a 2-hypersafety property, since any two program executions with the same input must yield the same output.
\end{definition}

\begin{definition}[Non-Interference ($\Ni$)]\label{def:ni}
  We define the class containing the non-interference hyperproperty as:
  $$
  \Ni = \left\{ H | \forall \trace_{1},\trace_{2}\in H. \loweq{\trace_{1}}{\trace_{2}}\implies\trace_{1}=\trace_{2} \right\}
  $$
\end{definition}
Note that $=$ may not be strict equality, but some suitable trace equivalence that checks both public and private actions, instead of just public.

\begin{definition}[Average Response Time (ART)]
  The average response time over all executions less than some arbitrary constant~\cite{clarkson08} is a practically useful hyperproperty that is not subset closed.
\end{definition}
Consider the behavior $\{\trace_{1},\trace_{2},\trace_{3}\}$ where $\trace_{1},\trace_{2}$ each take 1 second and $\trace_{3}$ 4 seconds to run.
If the chosen constant is 2, the hyperproperty would be fulfilled. However, the subset behavior $\{\trace_{3}\}$ has an average time of 4, double the bound set by the property.

\begin{lemma}[Classes Lattice]
  Classes with $\subseteq$ form a lattice.
\end{lemma}
\begin{proof}
  The class with all hyperproperties is the top element $\top=\powerset{\traces}$, while the class with no hyperproperties whatsoever is $\bot=\{\}$.
  Obviously, a partial order due to set inclusion.
  $\cap$ is least upper and $\cup$ greatest lower bound of any given pair of subsets of a given class.
\end{proof}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance=4mm,every node/.style={align=center}]
    \node (top) {$\top$};
    \node[below = of top.south] (SSC) {$\cSS$};
    \node[below = of SSC.south] (HSafe) {$\cHSafety$};
    \node[below = of HSafe.south] (HKSafe) {$\cKHSafety$};
    \node[below = of HKSafe.south] (H2Safe) {$\cTwoHSafety$};
    \node[below = of H2Safe.south] (Safe) {$\cSafety$};

    % Specialized classes
    \node[below right = of Safe.south] (Mutex) {$\mutex$};
    \node[below left = of Safe.south,xshift = 0.75em] (NonTerm) {$\nonterm$};

    \node[below left = of H2Safe.south west] (Determ) {$\determ$};
    \node[below right = of H2Safe.south east] (NI) {$\Ni$};

    \node[below = of Safe.south] (emptyspace) {};
    \node[below = of emptyspace.south] (Bot) {$\bot$};

    % edges
    \draw[-] (top.south) -- (SSC.north);
    \draw[-] (SSC.south) -- (HSafe.north);
    \draw[-] (HSafe.south) -- (HKSafe.north);
    \draw[-] (HKSafe.south) -- (H2Safe.north);
    \draw[-] (H2Safe.south) -- (Safe.north);
    \draw[-] (H2Safe.south) -- (Determ.north);
    \draw[-] (H2Safe.south) -- (NI.north);
    \draw[-] (Safe.south) -- (Mutex.north);
    \draw[-] (Safe.south) -- (NonTerm.north);
    \draw[-] (Determ.south) |- (Bot.west);
    \draw[-] (NI.south) |- (Bot.east);
    \draw[-] (Mutex.south) -- (Bot.north);
    \draw[-] (NonTerm.south) -- (Bot.north);
  \end{tikzpicture}
  \caption{Sketch of a fraction of the infinitely sized lattice of classes. The diagram should be read from top to bottom. A connecting edge between two nodes means that the bottom one is a subset of the top one.}
\end{figure}

\begin{lemma}[Sequential Composition with RTP]\label{lem:seqcompo}
  Given $\rtp{\sicomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  We need to show $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
  By definition, assume $\Pi\in\cC_{1}\cap\cC_{2}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$.
  What is left to show is $\rsat{\sitcomp{\src{p}}}{\prop}$.
  Note that $\Pi\in\cC_{2}$ and that $\sicomp{\src{p}}\in\irl{\partials}$, allowing us to apply $\rtp{\itcomp{\bullet}}{\cC_{2}}$ changing our goal to $\rsat{\sicomp{\src{p}}}{\Pi}$.
  Since $\Pi\in\cC_{1}$ also holds, we can this time apply $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
  What is left to show is $\rsat{\src{p}}{\Pi}$, which is an assumption of ours.
\end{proof}

\begin{definition}[Upper Composition]
  Given two compilers $\stcomp{\bullet}$ and $\itcomp{\bullet}$, their upper composition is

  $$\uhcsitcomp{\bullet}=\lambda p.\begin{cases}\stcomp{p} &\text{if }p\in\src{\partials}\\
                                                \itcomp{p} &\text{if }p\in\irl{\partials}\end{cases}$$.
\end{definition}

\begin{lemma}[Upper Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\uhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Analogous argument as in \Thmref{lem:seqcompo}, but with a case distinction on whether the source program is element of $\S$ or $\I$.
\end{proof}
% S = while,    I = while with exceptions           => modularization

% another idea: certified nugget -> minimal RSP compiler

\begin{definition}[Lower Composition]
  Given two compilers $\stcomp{\bullet}$ and $\sicomp{\bullet}$, their lower composition is $\lhcsitcomp{\bullet}$.
\end{definition}

\begin{lemma}[Lower Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\sicomp{\bullet}}{\cC_{2}}$, then $\rtp{\lhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Analogous argument as in \Thmref{lem:seqcompo}, but with a case distinction on whether the compiled source program is element of $\I$ or $\T$.
\end{proof}

\begin{lemma}[Diamond]\label{lem:diamond}
  Given $\rtp{\lhcsiocomp{\bullet}}{\cC_{1}}$ and $\rtp{\uhciotcomp{\bullet}}{\cC_{2}}$ with $\stcomp{\bullet} = \lambda\src{p}.\uhciotcomp{\lhcsiocomp{p}}$, then $\rtp{\stcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Straightforward using \Thmref{lem:seqcompo}.
\end{proof}

\begin{lemma}[Swappable]\label{lem:swappable}
  Given $\rtp{\ttcomp{\bullet}_{(1)}}{\cC_{1}}$ and $\rtp{\ttcomp{\bullet}_{(2)}}{\cC_{2}}$, then $\rtp{\ttcompN{\ttcomp{\bullet}_{(2)}}_{(1)}}{\cC_{1}\cap\cC_{2}}$ and $\rtp{\ttcompN{\ttcomp{\bullet}_{(1)}}_{(2)}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\begin{proof}
  Both follow from \Thmref{lem:seqcompo}.
\end{proof}

\begin{lemma}[Mingle]
  Given
  \begin{assumptions}
  \item\label[ass]{lem:sandwich:ass:a} $\forall\Pi\in\cC_{2}.\forall\src{p}\in\src{\partials}.\rsat{\src{p}}{\Pi}\implies \Pi\in\cC_{1}$
  \item\label[ass]{lem:sandwich:ass:b} $\forall\Pi\in\cC_{1}.\forall\trg{p}\in\trg{\partials}.\rsat{\trg{p}}{\Pi}\implies \Pi\in\cC_{2}$ (not needed)
  \item\label[ass]{lem:sandwich:ass:c} $\rtp{\stcomp{\bullet}}{\cC_{1}}$
  \end{assumptions}
  we have
  \begin{goals}
  \item\label[goal]{lem:sandwich:goal:i} $\rtp{\stcomp{\bullet}}{\cC_{2}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Unfolding \Cref{lem:sandwich:goal:i}; Let $\Pi\in\cC_{2}$ and $\src{p}\in\src{\partials}$ such that $\rsat{\src{p}}{\Pi}$, leaving us with $\rsat{\stcomp{\src{p}}}{\Pi}$ to prove.

  Apply \Cref{lem:sandwich:ass:c}, giving us as new goals $\Pi\in\cC_{1}$ and $\rsat{\src{p}}{\Pi}$, the latter following easily by the exact same assumption made before.

  However, we still need to argue that $\Pi\in\cC_{1}$.

  Instatiate the universal quantifications in \Cref{lem:sandwich:ass:a} with $\Pi$ and $\src{p}$. Apply that to our goal.
  What is left to show is $\rsat{\src{p}}{\Pi}$, which we've proven before already.
\end{proof}

\begin{lemma}[RSP may imply k-RSHP]
  Given
  \begin{assumptions}
  \item\label[ass]{lem:rspimplkrshp:ass:a} $\S$ and $\T$ have $\loweq{}{}$ and $\selfcompo{}{}$ operators
  \item\label[ass]{lem:rspimplkrshp:ass:b} $\Pi\in\cSafety$
  \item\label[ass]{lem:rspimplkrshp:ass:c} $\src{p}\in\src{\partials}$ with $\rsat{\src{p}}{\Pi}$
  \item\label[ass]{lem:rspimplkrshp:ass:d} $\rtp{\stcomp{\bullet}}{\cSafety}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{lem:rspimplkrshp:goal:i} $\exists\stcomp{\bullet}.\sat{\stcomp{\src{p}}}{\text{k-RSHP}}$
  \end{goals}
\end{lemma}
\begin{proof}
  (intuition)

  Take $\src{p}\in\src{\partials}$ and construct the k-product program according to \citet{barthe11}.
  Feed the input into the compiler from \Cref{lem:rspimplkrshp:ass:d}.
  Instantiate the existential in \Cref{lem:rspimplkrshp:goal:i} with the modified compiler.
  Since the product program reflects the behavior of $\src{p}$, the transformation does not interfere with robust property satisfaction.
  Furthermore, \Cref{lem:rspimplkrshp:ass:d} guarantees us that the compiled k-product program of $\src{p}$ is safe.
  Since the k-product construction soundly embeds $k-RSHP$ properties into $\cSafety$, the claim follows.
\end{proof}


\begin{definition}[Instrumentation]\label{def:instrumentation}
  A source code instrumentation done by a compiler takes a program in language $\T$ and emits an altered version of the same program in $\T$ such that it does not go wrong for some class of security relevant (hyper-)properties.
  Formally, given a $\cC$ a compiler $\ttcomp{\bullet}$ is an instrumentation for $\cC$ iff:

  $$
  \forall \trg{p}\in\trg{\partials}, \rsat{\ttcomp{p}}{\cC}
  $$

  We write $\instr{\ttcomp{\bullet}}{\cC}$.
\end{definition}
% S -> I and I -> T
% I -> T preserves memory safety


% enrich pipeline from source to target to see how to do the preservation from source in intermediate/target lang

\begin{definition}[Secure Instrumentation with Respect to $\cC$]\label{def:secure-instrumentation}
  A secure instrumentation with respect to some class $\cC$ ensures (hyper-)properties described by some class $\cC'$ without violating $\cC$-satisfying programs. We write $\sinstr{\ttcomp{\bullet}}{\cC}{\cC'}$.
  Thus, a compiler $\ttcomp{\bullet}$ is a secure instrumentation for $\cC'$ respecting $\cC$ iff:

  $$
  \rtp{\ttcomp{\bullet}}{\cC}\text{ and } \instr{\ttcomp{\bullet}}{\cC'}
  $$

\end{definition}

\begin{lemma}[Sequential Composition with a Secure Instrumentation]\label{lem:seqcompsecinstr}
  Given compilers $\sicomp{\bullet}$, $\itcomp{\bullet}$ and classes $\cC_{0},\cC_{1}$ such that
  \begin{assumptions}
  \item\label[ass]{lem:seqcompsecinstr:ass:a} $\rtp{\sicomp{\bullet}}{\cC_{0}}$
  \item\label[ass]{lem:seqcompsecinstr:ass:b} $\sinstr{\itcomp{\bullet}}{\cC_{1}}{\cC_{0}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{lem:seqcompsecinstr:goal:i} $\rtp{\sitcomp{\bullet}}{\cC_{0}\cup\cC_{1}}$
  \end{goals}
\end{lemma}

%\begin{definition}[No-v* Classes]
%  Let $\nvOne$ denote the singleton-class such that no SPECTRE v1 attack can happen.
%  Analgously, define $\nvFour$ as a singleton-class that disallows SPECTRE v4 attacks and $\nvOneFour$ as the class that disallows both v1 and v4 attacks, i.e. $\nvOneFour=\nvOne\cap\nvFour$.
%\end{definition}

% \begin{example}
%   Consider a compiler $\ttcomp{\bullet}_{1}$ such that $\sinstr{\ttcomp{\bullet}_{1}}{\nvOne}{\nvFour}$ and, similarily,
%   $\ttcomp{\bullet}_{4}$ such that $\sinstr{\ttcomp{\bullet}_{4}}{\nvFour}{\nvOne}$.

%   \begin{lemma}\label{lem:vOnevFourSafe}
%     Using above compilers, we now show that $\rtp{\ttcompN{\ttcomp{\bullet}_{1}}_{4}}{\nvOneFour}$.
%   \end{lemma}
%   \begin{proof}
%     By \Cref{lem:seqcompo} we get two goals, $\rtp{\ttcomp{\bullet}_{1}}{\nvOneFour}$ and $\rtp{\ttcomp{\bullet}_{4}}{\nvOneFour}$.

%     Since both cases are symmetrical, we only consider $\rtp{\ttcomp{\bullet}_{1}}{\nvOneFour}$ now.

%     Unfolding the definition of the goal, suppose there is a $\Pi\in\nvOneFour$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, while our new goal is $\rsat{\ttcomp{p}_{1}}{\Pi}$.

%     Strengthen the goal so that we need to show $\rsat{\ttcomp{p}_{1}}{\Pi}\wedge\Pi\in\nvOneFour$. Now, apply \Cref{def:secure-instrumentation}, so the only things left to show are $\Pi\in\nvOne$ and $\rsat{\trg{p}}{\Pi}$.
%     Both follow easily from our assumptions.
%   \end{proof}
%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{4}}_{1}}{\nvOneFour}$
%   \end{lemma}
%   \begin{proof}
%     By \Cref{lem:vOnevFourSafe} and \Cref{lem:swappable}.
%   \end{proof}

%   We now consider what happens if one of the two instrumentations is not secure with respect to the respective other class.
%   However, we focus on the case where the v1-instrumentation is insecure with respect to v4, due to symmetry.

%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{1}}_{4}}{\nvOneFour}$
%   \end{lemma}
%   \begin{proof}
%     Note that $\ttcomp{p}_{1}$ is a secure $\T$ program with respect to SPECTRE v1 attacks, given any $\trg{p}\in\trg{\partials}$.

%     Unfolding, let $\Pi\in\nvOneFour$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, our goal changes to $\rsat{\ttcompN{\ttcomp{\trg{p}}_{1}}_{4}}{\Pi}$.

%     Strengthen what we want to prove to $\rsat{\ttcompN{\ttcomp{\trg{p}}_{1}}_{4}}{\Pi}\wedge\Pi\in\nvOneFour$.
%     Apply \Cref{def:secure-instrumentation}, giving us proof-obligations that are already part of our assumptions.
%   \end{proof}

%   \begin{lemma}
%     $\rtp{\ttcompN{\ttcomp{\bullet}_{4}}_{1}}{\nvOne}$
%   \end{lemma}
%   \begin{proof}
%     Let $\trg{p}=\ttcomp{p'}_{4}$ be some program that is the result of plugging $\trg{p'}\in\trg{\partials}$ into $\ttcomp{\bullet}_{4}$.

%     Our goal becomes $\rtp{\ttcomp{p}_{1}}{\nvOne}$. Unfolding it, let $\Pi\in\nvOne$ and $\trg{p}\in\trg{\partials}$ such that $\rsat{\trg{p}}{\Pi}$, where what is left to prove is $\rsat{\ttcomp{p}_{1}}{\nvOne}$.

%     The goal follows immediately by \Cref{def:instrumentation}, since $\ttcomp{p}_{1}$ is an instrumentation for $\nvOne$.
%   \end{proof}

%   Finally, if both are insecure instrumentations, the strongest result one can get is either the robust preservation of $\nvOne$ or $\nvFour$, depending on which compiler is run last.
% \end{example}

We have seen that we can already swap robust compilers with same input and output language in a compilation pipeline.
Now, we want to formalize this idea of ``being able to swap things around'' for source code instrumentations.

\begin{definition}[Swappable Instrumentations]
  We define vertical compositionality as follows.
  Let $\bar{\cC}$ be a set of classes that are eventually used in the compilation pipeline.
  Given a class $\cC\in\bar{\cC}$ the particular instrumentation $\ttcomp{\bullet}$ ensures any program to robustly satisfy, we can swap the instrumentation in the pipeline \textit{freely} around iff:

  $$
  \forall\cC'\in\bar{\cC}. \sinstr{\ttcomp{\bullet}}{\cC}{\cC'}
  $$
\end{definition}
\MK{it'd be nice to have a property-free version of this, since this here is TEDIOUS to prove in real-world}

\section{Case Study}

\myfig{
  \begin{center}
    \begin{tikzpicture}[state/.style={minimum height=0.6cm}]
      \node (mmlAs) {$\mmlAs$};
      \node[right=1 of mmlAs] (mmlAt) {$\mmlAt$};
      \node[right=1 of mmlAt] (mmlAtmemsafe) {$\mmlAt$};
      \node[below=1 of mmlAtmemsafe] (asm) {$\ctASM$};%{$\nospecASM$};

      \path[->,very thick] (mmlAs) edge[sloped,above] node {TMS} (mmlAt);
      \path[->,dotted,very thick] (mmlAt) edge[sloped,above] node {SMS} (mmlAtmemsafe);
      \path[->,dashed,very thick] (mmlAs) edge[sloped,below,bend right=15] node {MS} (mmlAtmemsafe);
      \path[->,very thick] (mmlAtmemsafe) edge[sloped,above] node {SS+MS} (asm);
      \path[->,dashed,very thick] (mmlAs) edge[sloped,below,bend right=33] node {SS+MS} (asm);


      \node[draw=none,right=3 of mmlAt] (legend0) {};
      \node[draw=none,right=1 of legend0] (legend1) {RTP};
      \path[->,very thick] (legend0) edge node{} (legend1);

      \node[draw=none,below=0.5 of legend0] (legend2) {};
      \node[draw=none,right=1 of legend2] (legend3) {SENF};
      \path[->,dotted,very thick] (legend2) edge node{} (legend3);

      \node[draw=none,below=0.5 of legend2] (legend4) {};
      \node[draw=none,right=1 of legend4] (legend5) {Composition};
      \path[->,dashed,very thick] (legend4) edge node{} (legend5);
    \end{tikzpicture}
  \end{center}
}{outline-sketch}{Compilation Pipeline}


\subsection{Source Language}
\subsubsection{Syntax}

\myfig{
	\vspace{-1em}
  \begin{gather*}
  \begin{aligned}
  \mi{Final\ Result}\ \src{\finalexprnoerr} \bnfdef&\ \src{\valueexpr} \mid \src{x} \hspace{0.5cm}
  \mi{May\ be\ a\ Result}\ \src{\finalexpr} \bnfdef\ \src{\finalexprnoerr} \mid \src{stuck} \\
  %
  \mi{Expressions}~\src{e} \bnfdef&\ \src{\finalexpr} \mid \src{e_{1} \oplus e_{2}} \mid \src{x[e]} \mid \src{let\ x = e_{1}\ in\ e_{2}}\mid \src{x[e_{1}]\leftarrow e_{2}} \\
  & \mid \src{let\ x=new\ e_{1}\ in\ e_{2}} \mid \src{delete\ x} \mid \src{return\ e} \mid \src{call\ foo\ e} \\
  & \mid \src{ifz\ e_1\ then\ e_2\ else\ e_3} \hspace{0.5cm} \text{where } \src{\oplus}\in\{\src{+},\src{-},\src{\times},\src{<}\}\\
  %
  \mi{Functions}~\src{\asymbol} \bnfdef&\ \src{let\ foo\ x : \type}_{\lambda}\src{:= e} \\
  %
  \mi{Expr.\ Types}~\types_{\src{e}} \bnfdef&\ \src{\nat} \mid \src{ref_q\ \nat} \hspace{0.25cm}
  %
  \mi{Qualifier}~\src{q} \bnfdef\ \full \mid \half\hspace{0.25cm}
  \mi{Values}~\src{\valueexpr} \bnfdef\ \src{n}\in\src{\nat} \\
  %
  \mi{Ectx\ Types}~\types_{\lambda}\ \bnfdef& \types_{\src{e}}\to\types_{\src{e}} \hspace{0.25cm}
  \mi{Types}~\types \bnfdef \types_{\src{e}}\mid\types_{\lambda}\mid\types_{\src{e}}\src{\to\bot} \hspace{0.25cm}
  %
  \mi{References}~\src{\loc}\in\src{\nat} \\
  \mi{Eval. Ctx.}~\src{K}\bnfdef &\ \src{\hole{\cdot}}\mid \src{K\oplus e}\mid \src{v\oplus K}\mid \src{x[K]}\mid \src{let\ x=K\ in\ e}\\
                     &\ \mid\src{x[K]\leftarrow e}\mid \src{x[v]\leftarrow K}\mid \src{let\ x=new\ K\ in\ e} \\
                     &\ \mid\src{ifz\ K\ then\ e_1\ else\ e_2} \mid \src{call\ foo\ K}\mid \src{return\ K} \\
  %
  \mi{Variables}~\ &\src{x} \mid \src{y} \mid \src{foo} \mid \dots \hspace{0.5cm}
  %
  \mi{Poison}~\ \src{\poison}~\bnfdef\ \src{\poisonless} \mid \src{\poisoned}\\
  \mi{Sandbox\ Tag}~&\ \src{\sandboxtag}~\bnfdef\ \src{\ctx} \mid \src{\comp}\\
  %
  \mi{Typing. Env.}~\src{\Gamma} \bnfdef&\ \src{\hole{\cdot}} \mid \Gammas,\src{x:\type}\hspace{0.5cm}
  \mi{Store}~\src{\Delta} \bnfdef\ \src{\hole{\cdot}} \mid \src{x\mapsto(\loc;\sandboxtag;\poison;n)},\Deltas\\
  %
  \mi{Communication}~\src{\comm} \bnfdef&\ \src{\ctxtocomp} \mid \src{\comptoctx} \mid \src{\nocomm} \hspace{0.5cm}
  \mi{Heaps}~\src{H} \bnfdef\ \src{\hole{\cdot}} \mid \src{H}::\src{n} \\
  %
  \mi{Cont.\ Stack}~\src{\kontstack} \bnfdef&\ \src{\hole{\cdot}} \mid (\src{K};\src{foo}),\src{\kontstack} \hspace{0.5cm}
  \mi{Library}~\src{\library} \bnfdef\ \src{\hole{\cdot}} \mid \src{\asymbol},\src{\library} \\
  \mi{Relevant}\ \src{\commlib} \bnfdef& \src{\hole{\cdot}} \mid \src{foo},\src{\commlib}\hspace{0.5cm}
  \mi{State}~\configs\ \bnfdef\ \src{\cfstate;\sandboxtag;\memstate}\\
  \mi{Flow\ State}~\src{\cfstate}\bnfdef&\ \src{\commlib;\library;\kontstack}\hspace{0.5cm}
  \mi{Memory\ State}~\src{\memstate}\bnfdef\ \src{H^{\ctx};H^{\comp};\Delta} \\
  %
  \mi{Programs}\ &\src{prog\ \library_{ctx}\ \library_{comp}} \\
  \end{aligned}
  \end{gather*}
}{mmla-syntax}{Syntax of $\mmlAs$}

Most of the syntax is more or less standard.
Qualifiers $\src{q}$ can be attached to pointers to signal ownership.
Hereby, the qualifier $\src{\full}$ means "fully owned", meaning we may and also must delete the pointer at some point, while we cannot do the same for $\src{\half}$, which forbids us to delete.
Poison $\src{\poison}$ marks locations in the execution-context $\src{\Omega}$ as ,,to-be-deleted'' ($\src{\poisonless}$) or ,,deleted'' ($\src{\poisoned}$).
$\src{\commlib}$ contains a list of identifiers referencing what functions are considered a component.
Anything not present in $\src{\commlib}$ is considered to be a context.
We describe the act of calling or returning from component to context or vice versa as ,,crossing the boundary''.
The heap is split into two parts, such that any component listed in $\src{\commlib}$ will allocate in $\src{H^{\comp}}$ and anything else in $\src{H^{\ctx}}$.
Objects pointed at by a location $\src{\loc}$ are marshalled when they are passed across the boundary.
Without the heap sandboxing, contexts can arbitrarily rewrite a component's memory, which incurs compiler correctness issues.
We chose to distinguish between successful final results ($\src{\finalexprnoerr}$) and potentially crashed results ($\src{\finalexpr}$).
Note that a final result may also be an identifier, which we keep around as abstract representation for locations of pointers.
However, we still distinct them from ordinary values ($\src{\valueexpr}$), since they don't behave like normal values.
For example, we cannot make canonical typing lemmas for them without the additional information contained in a non-empty typing-context.
When discussing secure compilation, there is a notion of ,,context'' and ,,component'', where the latter is usually the part one cares about.
We use the term ,,context-switching'' with its usual meaning, i.e. change in control flow to some other procedure.
For $\src{\comm}$, the representation $\src{\ctxtocomp}$ signalizes a context switch from context to component, $\src{\comptoctx}$ from component to context, and $\src{\nocomm}$ signals an internal change, either inside the context or inside the component.
The state $\configs$ carries information on what the current context is and the continuation stack $\src{\kontstack}$ is used in the semantics to mark events with above policy accordingly.
Continuations $\src{K}$ in the stack are annotated with the name of the function $\src{foo}$ the continuation originates from.
Programs $\src{prog\ \library_{ctx}\ \library_{comp}}$ contain two lists of top-level definitions $\src{\library_{ctx}}$ and $\src{\library_{comp}}$.
$\src{\library_{ctx}}$ takes the role as attacker code.

\subsubsection{Static Semantics}
\begin{definition}[NoOwnedPtr]
  We write $\src{\noptr{\Gamma}}$ iff for any $\src{x}, \src{\type}$, if $\src{x} : \src{\type}\in\src{\Gamma}$, then $\types\not=\ptr$.
\end{definition}
\myfig{
  \begin{center}
    \judgbox{\vdash\src{\tau}\operatorname{int}}{,,$\src{\tau}$ is an interface type.''}$\;$\\
  \typerule{int-$\src{\nat}$}{
  }{
    \vdash\src{\nat}\operatorname{int}
  }{src-int-type-nat}
  \end{center}
}{src-int-types}{Interface types of $\mmlAs$.}

We introduce interface types to explicitly disallow passing owned pointers.

\myfig{
  \begin{center}
  \judgbox{\Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}}{,,Environment $\Gammas$ can be split into $\src{\Gamma_1}$ and $\src{\Gamma_2}$.''}
  %
  $\;$\\
  \typerule{splitEmpty}{
  }{
    \src{\hole{\cdot}} \equiv \src{\hole{\cdot}}\circ\src{\hole{\cdot}}
  }{t-empty-split}
  %
  \typerule{splitEmptyL}{
  }{
    \src{\Gamma} \equiv \src{\hole{\cdot}}\circ\src{\Gamma}
  }{t-empty-splitL}
  %
  \typerule{splitEmptyR}{
  }{
    \src{\Gamma} \equiv \src{\Gamma}\circ\src{\hole{\cdot}}
  }{t-empty-splitR}
  %
  \typerule{$\nat$split}{
    \Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\nat},\Gammas \equiv \src{x:\nat},\src{\Gamma_1}\circ\src{x:\nat},\src{\Gamma_2}
  }{t-nat-split}
  %
  \typerule{weakPtrSplit}{
    \Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\wptr},\Gammas \equiv \src{x:\wptr},\src{\Gamma_1}\circ\src{x:\wptr},\src{\Gamma_2}
  }{t-wptr-split}
  %
  \typerule{ptrLSplit}{
    \Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\ptr},\Gammas \equiv \src{x:\ptr},\src{\Gamma_1}\circ\src{\Gamma_2}
  }{t-ptr-l-split}
  %
  \typerule{ptrRSplit}{
    \Gammas \equiv \src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{x:\ptr},\Gammas \equiv \src{x:\wptr,\Gamma_1}\circ\src{x:\ptr},\src{\Gamma_2}
  }{t-ptr-r-split}
  %
  \typerule{arrowSplit}{
    \vdash\src{\type_e^{(1)}}\ \operatorname{int} &
    \vdash\src{\type_e^{(2)}}\ \operatorname{int} &
    \src{\Gamma}\equiv\src{\Gamma_1}\circ\src{\Gamma_2}
  }{
    \src{foo:\type_e^{(1)}\to\type_e^{(2)}},\Gammas \equiv \src{foo:\type_e^{(1)}\to\type_e^{(2)}},\src{\Gamma_1}\circ\src{foo:\type_e^{(1)}\to\type_e^{(2)}},\src{\Gamma_2}
  }{t-arrow-split}
  \end{center}
}{w-ctx-split}{Context Splitting of $\mmlAs$ typing contexts.}

The splitting of contexts takes care to propagate owned-pointers towards the end.
This way, no non-owned pointer occurs in the context after an owned one, where both have the same identifier.
Note that non-owned pointers and values may be freely duplicated and that we can generate non-owned pointers if we have ownership.

\myfig{
  \judgbox{\typechecks{\Gamma}{e}{\types}}{,,Under environment $\Gammas$ the expression $\src{e}$ has type $\types$.''}

  \begin{center}
  \typerule{$t-\src{var}$}{
  \src{\noptr{\Gamma_1}}&
  \src{\noptr{x:\type,\hole{\cdot}}}&
  \src{\noptr{\Gamma_2}}
	}{
    \typechecks{\Gamma_1,x:\type,\Gamma_2}{x}{\type}
	}{t-var}
  %
  \typerule{$t-\src{\nat}$}{
    \src{\noptr{\Gamma}}
  }{
    \typechecks{\Gamma}{n}{\nat}
  }{t-nat}
  %
  \typerule{$t-\src{\oplus}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{e_1\oplus e_2}{\nat}
  }{t-binop}
  %
  \typerule{$t-$get}{
    \typechecks{\Gamma_2}{x}{\wptr} &
    \typechecks{\Gamma_1}{e}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{x[e]}{\nat}
  }{t-get}
  %
  \typerule{$t-$set}{
    \typechecks{\Gamma_3}{x}{\wptr} &
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{(\Gamma_1\circ\Gamma_2)\circ\Gamma_3}{x[e_1]\leftarrow e_2}{\nat}
  }{t-set}
  %
  \typerule{$t-\src{let}$}{
    \typechecks{\Gamma_1}{e_1}{\type_{e}^{(1)}} &
    \typechecks{x:\type_{e}^{(1)},\Gamma_2}{e_2}{\type^{(2)}}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{let\ x=e_1\ in\ e_2}{\type^{(2)}}
  }{t-let}
  %
  \typerule{$t-\src{new}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{x:\ptr,\Gamma_2}{e_2}{\nat}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{let\ x=new\ e_1\ in\ e_2}{\nat}
  }{w-t-new}
  %
  \typerule{$t-\src{delete}$}{
    \src{\noptr{\Gamma_1}} & \src{\noptr{\Gamma_2}}
  }{
    \typechecks{\Gamma_1,x:\ptr,\Gamma_2}{delete\ x}{\nat}
  }{w-t-delete}
  %
  \typerule{$t-\src{call}$}{
    \vdash\src{\type_e^{(1)}}\ \operatorname{int} &
    \vdash\src{\type_e^{(2)}}\ \operatorname{int} \\
    \typechecks{\Gamma}{foo}{\type_e^{(1)}\to\type_e^{(2)}} &
    \typechecks{\Gamma}{e}{\type_e^{(1)}}
  }{
    \typechecks{\Gamma}{call\ foo\ e}{\type_e^{(2)}}
  }{t-call}
  %
  \typerule{$t-\src{return}$}{
    \src{\type_e}\ \operatorname{int} &
    \typechecks{\Gamma}{e}{\type_e}
  }{
    \typechecks{\Gamma}{return\ e}{\type_e\to\bot}
  }{t-return}
  %
  \typerule{$t-\src{ifz}$}{
    \typechecks{\Gamma_1}{e_1}{\nat} &
    \typechecks{\Gamma_2}{e_2}{\type} &
    \typechecks{\Gamma_2}{e_3}{\type}
  }{
    \typechecks{\Gamma_1\circ\Gamma_2}{ifz\ e_1\ then\ e_2\ else\ e_3}{\type}
  }{w-t-if}
  \end{center}
}{w-expr-ty}{Checking of $\mmlAs$ expressions.}
The context splitting takes care that for e.g. \Cref{tr:t-binop} it cannot happen that we do something like $\src{(delete\ x) + x[0]}$.
For \Cref{tr:t-var,tr:t-nat} we require that the contexts do not contain any owned pointer.
Intuitively, an owned pointer is useless upto getting a non-owned version from context splitting, because we cannot do anything with it besides deleting.
This is inspired by linear logic.

\myfig{
  \judgbox{\typechecks{\Gamma}{K}{\types^{(1)}\to\types^{(2)}}}{,,Under environment $\Gammas$ the evaluation context $\src{K}$ requires an\\object of type $\src{\type^{(1)}}$ and yields one of type $\src{\type^{(2)}}$.''}
  \begin{center}
    \typerule{et-$\src{\hole{\cdot}}$}{
    }{
      \typechecks{\Gamma}{\hole{\cdot}}{\type\to\type}
    }{w-te-hole}
    %
    \typerule{et-$\src{\oplus}$R}{
      \typechecks{\Gamma}{\valueexpr}{\nat} &
      \typechecks{\Gamma}{K}{\type\to\nat}
    }{
      \typechecks{\Gamma}{\valueexpr\oplus K}{\type\to\nat}
    }{w-te-bionpR}
    %
    \typerule{et-$\src{\oplus}$L}{
      \typechecks{\Gamma}{K}{\type\to\nat} &
      \typechecks{\Gamma}{e}{\nat}
    }{
      \typechecks{\Gamma}{K\oplus e}{\type\to\nat}
    }{w-te-bionpL}
    %
    \typerule{et-get}{
      \typechecks{\Gamma}{x}{\wptr} &
      \typechecks{\Gamma}{K}{\type\to\nat}
    }{
      \typechecks{\Gamma}{x[K]}{\type\to\nat}
    }{w-te-get}
    %
    \typerule{et-setR}{
      \typechecks{\Gamma}{v}{\nat} &
      \typechecks{\Gamma}{K}{\type\to\nat}
    }{
      \typechecks{\Gamma}{x[\valueexpr]\leftarrow K}{\type\to\nat}
    }{w-te-setR}
    %
    \typerule{et-setL}{
      \typechecks{\Gamma}{K}{\type\to\nat} &
      \typechecks{\Gamma}{e}{\nat}
    }{
      \typechecks{\Gamma}{x[K]\leftarrow e}{\type\to\nat}
    }{w-te-setL}
    %
    \typerule{et-let}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\type_{e}'} &
      \typechecks{x:\type_{e}',\Gamma}{e}{\type^{(2)}}
    }{
      \typechecks{\Gamma}{let\ x=K\ in\ e}{\type^{(1)}\to\type^{(2)}}
    }{w-te-let}
    %
    \typerule{et-new}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\nat} &
      \typechecks{x:\ptr,\Gamma}{e}{\type^{(2)}}
    }{
      \typechecks{\Gamma}{let\ x=new\ K\ in\ e}{\type^{(1)}\to\type^{(2)}}
    }{w-te-new}
    %
    \typerule{et-ifz}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\nat} &
      \typechecks{\Gamma}{e_2}{\type^{(2)}}&
      \typechecks{\Gamma}{e_3}{\type^{(2)}}&
    }{
      \typechecks{\Gamma}{ifz\ K\ then\ e_2\ else\ e_3}{\type^{(1)}\to\type^{(2)}}
    }{w-te-ifz}
    %
    \typerule{et-call}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\type'} &
      \typechecks{\Gamma}{foo}{\type'\to\type^{(2)}}
    }{
      \typechecks{\Gamma}{call\ foo\ K}{\type^{(1)}\to\type^{(2)}}
    }{w-te-call}
    %
    \typerule{et-ret}{
      \typechecks{\Gamma}{K}{\type^{(1)}\to\type^{(2)}}
    }{
      \typechecks{\Gamma}{return\ K}{\type^{(1)}\to(\type^{(2)}\to\bot)}
    }{w-te-ret}
  \end{center}
}{w-ectx-ty}{Checking of $\mmlAs$ evaluation contexts.}

\myfig{
  \judgbox{\src{\library}\downarrow=\src{\Gamma}}{,,Project $\mmlAs$ library to static typing context.''}$\;$\\
  \begin{center}
    \typerule{$\src{\library}$-proj-$\src{\hole{\cdot}}$}{
    }{
      \src{\hole{\cdot}}\downarrow = \src{\hole{\cdot}}
    }{w-lib-proj-empty}
    %
    \typerule{$\src{\library}$-proj-cons}{
      \src{\library}\downarrow = \src{\Gamma}
    }{
      (\src{let\ foo\ x : \type}_\lambda\src{:= e})\src{,\library}\downarrow = (\src{foo \mapsto \type}_\lambda),\src{\Gamma}
    }{w-lib-proj-cons}
  \end{center}
  %
  \judgbox{\operatorname{dom}\ \src{\library}=\src{foo},\dots,\src{bar}}{,,Collect function names.''}$\;$\\
  \begin{center}
    \typerule{$\src{\library}$-dom-$\src{\hole{\cdot}}$}{
    }{
      \operatorname{dom}\ \src{\hole{\cdot}} = \src{\hole{\cdot}}
    }{w-lib-dom-empty}
    %
    \typerule{$\src{\library}$-dom-cons}{
      \operatorname{dom}\ \src{\library} = \src{D}
    }{
      \operatorname{dom}\ (\src{let\ foo\ x : \type}_\lambda\src{:= e})\src{,\library} = \src{foo},\src{D}
    }{w-lib-dom-cons}
  \end{center}
}{w-gamma-of-symbols}{Extracting type annotations and function names.}

\myfig{
  \begin{center}
    \judgbox{\src{\library}\equiv\src{\library_1}\cup\src{\library_2}}{,,Merging $\mmlAs$ libraries.''}$\;$\\
    \typerule{lib-merge-empty}{
      \src{\library}=\src{\library_1}
    }{
      \src{\library}\equiv\src{\library_1}\cup\src{\hole{\cdot}}
    }{src-lib-merge-empty}
    %
    \typerule{lib-merge-cons}{
      \src{\library}\equiv\src{\library_1}\cup\src{\library_2}
    }{
      \src{\asymbol,\library}\equiv\src{\library_1}\cup\src{\asymbol,\library_2}
    }{src-lib-merge-cons}

    \judgbox{\src{\library_1\linker\library_2}=\src{\library}}{,,Syntactically linking $\mmlAs$ libraries.''}$\;$\\
    \typerule{syntactic-plugging}{
      \operatorname{dom}\src{\library_1}\cap\operatorname{dom}\src{\library_2} = \emptyset &
      \src{\library}\equiv\src{\library_1}\cup\src{\library_2}
    }{
      \src{\library_1\linker\library_2} = \src{\library}
    }{src-plugging}
  \end{center}
}{w-plugging-s}{$\mmlAs$ plugging of libraries.}

\myfig{
  \begin{center}
    \judgbox{\src{\Gamma}\vdash\src{\library}\ \operatorname{ok}}{,,$\mmlAs$ library typechecks.''}$\;$\\
    %
    \typerule{t-$\src{\library}$-empty}{
    }{
      \src{\Gamma}\vdash\src{\hole{\cdot}}\ \operatorname{ok}
    }{w-t-lib-empty}
    %
    \typerule{t-$\src{\library}$-cons}{
      \src{\type_e^{(1)}}\ \operatorname{int} &
      \src{\type_e^{(2)}}\ \operatorname{int} &
      \src{\Gamma}\vdash\src{\library}\ \operatorname{ok} &
      \typechecks{x:\type_e^{(1)},\Gamma}{e}{\type_{e}^{(2)}\to\bot}
    }{
      \src{\Gamma}\vdash(\src{let\ foo\ x : \type_e^{(1)}}\to\src{\type_e^{(2)}:= e}),\src{\library}\ \operatorname{ok}
    }{w-t-lib-cons}\\[0.33cm]
    %
    \judgbox{\vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv\src{\library},\src{\commlib}}{,,$\mmlAs$ program $\src{prog\ \library_{ctx}\ \library_{comp}}$ typechecks. $\src{\library}$ is the\\result of linking $\src{\library_{ctx}}$ and $\src{\library_{comp}}$. $\src{\commlib}$ is $\operatorname{dom}\ \src{\library_{comp}}$.''}$\;$\\
    %
    \typerule{$t-\text{prog}$}{
      \src{\library}=\src{\library_{ctx}\linker\library_{comp}} &
      \src{\library}\downarrow = \src{\Gamma_0} &
      \src{main}\in\operatorname{dom} \src{\Gamma_0} &
      \src{\Gamma_0}\vdash\src{\library}\ \operatorname{ok} &
      \typechecks{\Gamma_0}{call\ main\ 0}{\nat\to\bot}
    }{
      \vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv \src{\library},\operatorname{dom}\ \src{\library_{comp}}
    }{w-t-wprog}
    %
    \judgbox{\typechecks{}{\configs\triangleright e}{\type}}{,,$\mmlAs$ runtime program $\src{\configs\triangleright e}$ typechecks.''}$\;$\\
    \typerule{$t-\text{prog}-\text{runtime}$}{
      \typechecks{\library}{\Delta}{\Gamma}&
      \typechecks{\Gamma}{e}{\type}
    }{
      \typechecks{}{\commlib;\library;\kontstack;\sandboxtag;H^\ctx;H^\comp;\Delta\triangleright e}{\type}
    }{w-t-prog-runtime}
  \end{center}
}{w-program-ty}{Checking of $\mmlAs$ contexts, components, programs, and whole programs.}
Perhaps most interesting is \Cref{tr:w-t-prog} which generates a suitable typing context from the execution context.
\Cref{fig:store-ty} shows how this works exactly.

\myfig{
  \begin{center}
    \judgbox{\typechecks{\library}{\Delta}{\Gamma}}{,,$\mmlAs$ location map $\Deltas$ yields static typing environment $\Gammas$.''}
    \typerule{$T\text{empty}\src{\Delta}$}{
      \src{\library}\downarrow=\src{\Gamma}
    }{
      \typechecks{\library}{\hole{\cdot}}{\Gammas}
    }{t-empty-store}
    %
    \typerule{$T\ptr$}{
    \typechecks{\library}{\Delta}{\Gamma}
    }{
    \typechecks{\library}{x\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}{x:\ptr,\Gamma}
    }{t-ptr-store}
    %
    \typerule{$T\ptr\text{poison}$}{
    \typechecks{\library}{\Delta}{\Gamma}
    }{
    \typechecks{\library}{x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta}{\Gamma}
    }{t-poison-store}
  \end{center}
}{store-ty}{$\mmlAs$ store typing.}
Here, we want to populate the typing context with all {\em valid} pointers, which are those that are not poisoned.
Pointers of type $\src{\wptr}$ are implicitly generated during elaboration, see \Cref{fig:w-ctx-split}.

\subsubsection{Dynamic Semantics}

\myfig{
  \begin{gather*}
  \begin{aligned}
  \mi{Base\ Events}~\src{\event_{b}} \bnfdef&\ \src{Alloc\ \loc\ \valueexpr} \mid \src{Dealloc\ \loc} \mid \src{Get\ \loc\ \valueexpr} \mid \src{Set\ \loc\ \valueexpr\ \valueexpr'} \mid \src{\lightning} \\
                                  & \mid \src{Call\ \comm\ foo\ \valueexpr} \mid \src{Ret\ \comm\ \valueexpr} \mid \src{Start} \mid \src{End\ \valueexpr}\\
  \mi{Events}~\src{\event} \bnfdef&\ \src{\emptyevent} \mid \src{\event_{b};\sandboxtag}
  \end{aligned}
  \end{gather*}
}{w-events}{Events of $\mmlAs$.}

\myfig{
  \judgbox{\exprevals{\configs}{e}{\configs'}{e'}{\event}}{,,Expression $\src{e}$ evaluates under configuration $\configs$ to $\src{e'}$ and new\\configuration $\src{\configs'}$, emitting event $\src{\event}$.''}
  %
  \typerule{$e-\src{\oplus}$}{
    \src{n_1}\oplus\src{n_2}=\src{n_3}
  }{
    \exprevals{\configs}{n_1 \oplus n_2}{\configs}{n_3}{\emptyevent}
  }{w-e-oplus}
  %
  \typerule{$e-\src{get}-\in$}{
    \src{\memstate}=\src{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2} &
    \src{\loc}+\src{n}\in\text{dom }\src{H^{\sandboxtag}}
  }{
    \exprevals{\cfstate;\sandboxtag';\memstate}{x[n]}{\cfstate;\sandboxtag';\memstate}{H^{\sandboxtag}(\loc+n)}{Get\ \loc\ n;\sandboxtag}
  }{w-e-get-in}
  %
  \typerule{$e-\src{get}-\notin$}{
    \src{\memstate}=\src{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2} &
    \src{\loc}\notin\text{dom }\src{H^{\sandboxtag}}
  }{
    \exprevals{\cfstate;\sandboxtag';\memstate}{x[n]}{\cfstate;\sandboxtag';\memstate}{1729}{Get\ \loc\ n;\sandboxtag}
  }{w-e-get-notin}
  %
  \typerule{$e-\src{set}-\ctx$}{
    \src{\memstate}=\src{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\ctx;\poison;n),\Delta_2} &
    \src{H^{\ctx'}} = \src{H^{\ctx}}(\src{\loc+n}\mapsto \src{v}) \\
    \src{\memstate'}=\src{H^{\ctx'};H^{\comp};\Delta_1,x\mapsto(\loc;\ctx;\poison;n),\Delta_2}
  }{
    \exprevals{\cfstate;\ctx;\memstate}{x[n]\leftarrow v}{\cfstate;\ctx;\memstate'}{v}{Set\ \loc\ n\ v;\ctx}
  }{w-e-set-ctx}
  %
  \typerule{$e-\src{set}-\comp$}{
    \src{\memstate}=\src{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\comp;\poison;n),\Delta_2} &
    \src{H^{\comp'}} = \src{H^{\comp}}(\src{\loc+n}\mapsto \src{v}) \\
    \src{\memstate'}=\src{H^{\ctx};H^{\comp'};\Delta_1,x\mapsto(\loc;\comp;\poison;n),\Delta_2}
  }{
    \exprevals{\cfstate;\comp;\memstate}{x[n]\leftarrow v}{\cfstate;\comp;\memstate'}{v}{Set\ \loc\ n\ v;\comp}
  }{w-e-set-comp}
  %
  \typerule{$e-\src{let}-\src{\finalexprnoerr}$}{
  }{
    \exprevals{\Omega}{let\ x=\finalexprnoerr\ in\ e}{\Omega}{e[\finalexprnoerr/x]}{\emptyevent}
  }{w-e-let-x}
  %
  \typerule{$e-\src{delete}$}{
    \src{\memstate}=\src{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta_2} \\
    \src{\memstate}=\src{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}
  }{
    \exprevals{\cfstate;\sandboxtag;\memstate}{delete\ x}{\cfstate;\sandboxtag;\memstate'}{0}{Dealloc\ \loc;\sandboxtag}
  }{w-e-delete}
  %
  \typerule{$e-\src{new}-ctx$}{
    \fresh{\src{\Delta}}{\src{\loc}} &
    \fresh{\src{\Delta}}{\src{z}} &
    \src{H^{\ctx'}} = \src{H^{\ctx}} \ll \src{n} \\
    \src{\memstate} = \src{H^{\ctx'};H^{\comp};z\mapsto (\loc;\ctx;\poisonless;n),\Delta}
  }{
    \exprevals{\cfstate;\ctx;H^{\ctx};H^{\comp};\Delta}{let\ x=new\ n\ in\ e}{\cfstate;\ctx;\memstate}{e[z/x]}{Alloc\ \loc\ n;\ctx}
  }{w-e-let-new-ctx}
  %
  \typerule{$e-\src{new}-comp$}{
    \fresh{\src{\Delta}}{\src{\loc}} &
    \fresh{\src{\Delta}}{\src{z}} &
    \src{H^{\comp'}} = \src{H^{\comp}} \ll \src{n} \\
    \src{\memstate} = \src{H^{\ctx};H^{\comp'};z\mapsto (\loc;\ctx;\poisonless;n),\Delta}
  }{
  \exprevals{\cfstate;\comp;H^{\ctx};H^{\comp};\Delta}{let\ x=new\ n\ in\ e}{\cfstate;\comp;\memstate}{e[z/x]}{Alloc\ \loc\ n;\comp}
  }{w-e-let-new-comp}
  %
  \typerule{$e-\src{ifz}-$true}{
  }{
  \exprevals{\Omega}{ifz\ 0\ then\ e_1\ else\ e_2}{\Omega}{e_1}{\emptyevent}
  }{w-e-if-true}
  %
  \typerule{$e-\src{ifz}-$false}{
  }{
  \exprevals{\Omega}{ifz\ S(n)\ then\ e_1\ else\ e_2}{\Omega}{e_2}{\emptyevent}
  }{w-e-if-false}
  %
%  \typerule{$e-\src{abort}$}{
%  }{
%    \exprevals{\Omega}{abort()}{\Omega}{stuck}{\lightning}
%  }{w-e-abort}
}{w-expr-prim-eval}{Primitive Evaluation of $\mmlAs$ expressions.}
Evaluation is mostly straightforward, the only interesting cases involve the pointers.
Specifically, \Cref{tr:w-e-delete} demonstrates why we need the poison-tag on the locations: Regardless of the current tag, emit a $\src{Dealloc\ \loc}$ event and mark $\src{\loc}$ as poisoned ($\src{\poisoned}$).
The intuitive solution, removing the mapping on deletion, doesn't allow to run programs that delete twice.
However, we want to model memory effects and show that such situations never happen, even though they {\em could}.
Given a poisoned location, we can still do everything with it: reading, writing, or deletion.
When generating the static context from the execution context, \Cref{tr:t-poison-store} allows us to disregard deleted locations which will help us reason that the given execution could not have been happening if the program was well-typed to begin with.

\myfig{
  \begin{center}
    \judgbox{\execs[]{\configs}{K[e]}{\configs'}{K[e']}{\event}}{,,Given an evaluation context $\src{K}$ and an expression $\src{e}$,\\it evaluates under configuration $\configs$ to $\src{e'}$ and new\\configuration $\src{\configs'}$ in context $\src{K}$, emitting event $\src{\event}$.''}
    %
    \typerule{$e-\text{ctx}$}{
      \exprevals{\Omega}{e}{\Omega'}{e'}{\event}
    }{
      \execs[]{\Omega}{K[e]}{\Omega'}{K[e']}{\event}
    }{w-e-ectx}
    %
    \typerule{$e-\text{ctx}-\src{stuck}$}{
      \exprevals{\Omega}{e}{\Omega'}{stuck}{\lightning}
    }{
      \execs[]{\Omega}{K[e]}{\Omega'}{stuck}{\lightning}
    }{w-e-ectx-stuck}
    %
    \typerule{$e-\text{ctx}-\src{call}-$main}{
      \src{\Omega}=\src{\commlib;\library;\hole{\cdot};\comp;\memstate} &
      \src{\library}=\src{\library_1,}(\src{let\ main\ x:\type}_\lambda\src{:=e})\src{,\library_2}\\
      \src{\Omega'}=\src{\commlib;\library;\ctx;K^{main},\hole{\cdot};\memstate}
    }{
      \execs[]{\Omega}{K[call\ main\ \valueexpr]}{\Omega'}{e[x/\valueexpr]}{Start;\comp}
    }{w-e-ectx-call-main}
    %
    \typerule{$e-\text{ctx}-\src{call}-\text{notsame}$}{
      \src{\Omega}=\src{\commlib;\library;\kontstack;\sandboxtag;\memstate} &
      \src{\library}=\src{\library_1,}(\src{let\ foo\ x:\type}_\lambda\src{:=e})\src{,\library_2} \\
      %\rho_{\tiny call}(\src{\commlib},\src{foo},\src{\kontstack},\src{v}) = \src{\event},\src{\comm} &
      \src{foo}\in_{\src{\neg\sandboxtag}}\src{\commlib} &
      \rho\left(\src{\neg\sandboxtag}\right) = \src{\comm} &
      \src{\Omega'}=\src{\commlib;\library;K^{foo},\kontstack;\neg\sandboxtag;\memstate} \\
    }{
      \execs[]{\Omega}{K[call\ foo\ \valueexpr]}{\Omega'}{e[x/\valueexpr]}{Call\ \comm\ foo\ \valueexpr;\sandboxtag}
    }{w-e-ectx-call-notsame}
    %
    \typerule{$e-\text{ctx}-\src{call}-\text{same}$}{
      \src{\Omega}=\src{\commlib;\library;\kontstack;\sandboxtag;\memstate} &
      \src{\library}=\src{\library_1,}(\src{let\ foo\ x:\type}_\lambda\src{:=e})\src{,\library_2} \\
      %\rho_{\tiny call}(\src{\commlib},\src{foo},\src{\kontstack},\src{v}) = \src{\event},\src{\comm} &
      \src{foo}\in_{\src{\sandboxtag}}\src{\commlib} &
      \src{\Omega'}=\src{\commlib;\library;K^{foo},\kontstack;\sandboxtag;\memstate} \\
    }{
      \execs[]{\Omega}{K[call\ foo\ \valueexpr]}{\Omega'}{e[x/\valueexpr]}{Call\ \nocomm\ foo\ \valueexpr;\sandboxtag}
    }{w-e-ectx-call-same}
    %
    \typerule{$e-\text{ctx}-\src{return}-$main}{
    }{
      \exec[]{\src{\commlib;\library;\hole{\cdot}^{main},\hole{\cdot};\ctx;\memstate}}{\src{K'[return\ \valueexpr]}}{\src{\commlib;\library;\hole{\cdot};\comp;\memstate}}{\src{\valueexpr}}{\src{End\ \valueexpr;\sandboxtag}}
    }{w-e-ectx-ret-main}
    %
    \typerule{$e-\text{ctx}-\src{return}-\text{notsame}$}{
      \src{foo}\in_{\src{\neg\sandboxtag}}\src{\commlib} &
      \rho\left(\src{\neg\sandboxtag}\right) = \src{\comm;\sandboxtag}
    }{
      \exec[]{\src{\commlib;\library;K^{foo},\kontstack;\sandboxtag;\memstate}}{\src{K'[return\ \valueexpr]}}{\src{\commlib;\library;\kontstack;\neg\sandboxtag;\memstate}}{\src{K[\finalexprnoerr]}}{\src{Ret\ \comm\ \valueexpr;\sandboxtag}}
    }{w-e-ectx-ret-notsame}
    %
    \typerule{$e-\text{ctx}-\src{return}-\text{same}$}{
      \src{foo}\in_{\src{\sandboxtag}}\src{\commlib}
    }{
      \exec[]{\src{\commlib;\library;K^{foo},\kontstack;\sandboxtag;\memstate}}{\src{K'[return\ \valueexpr]}}{\src{\commlib;\library;\kontstack;\sandboxtag;\memstate}}{\src{K[\finalexprnoerr]}}{\src{Ret\ \nocomm\ \valueexpr;\sandboxtag}}
    }{w-e-ectx-ret-same}
    %
    \judgbox{\rho(\src{\sandboxtag})=\src{\comm}}{,,Returns either $\src{\ctxtocomp}$ or $\src{\comptoctx}$ depending on $\src{\sandboxtag}$.''}\\
    %
    \typerule{comm-ctxtocomp}{
    }{
      \rho(\src{\ctx})=\src{\ctxtocomp}
    }{w-comm-ctxtocomp}
    %
    \typerule{comm-comptoctx}{
    }{
      \rho(\src{\comp})=\src{\comptoctx}
    }{w-comm-comptoctx}\\[0.33cm]
    %
    \judgbox{\src{\neg\sandboxtag}=\src{\sandboxtag'}}{,,Negation of $\src{\sandboxtag}$.''}\\
    %
    \typerule{neg-ctx}{
    }{
      \src{\neg\ctx}=\src{\comp}
    }{w-neg-ctx}
    %
    \typerule{neg-comp}{
    }{
      \src{\neg\comp}=\src{\ctx}
    }{w-neg-ctx}
  \end{center}
}{w-expr-ctx-eval}{Contextual Evaluation of $\mmlAs$ expressions.}
\myfig{
  \begin{center}
    \judgbox{\execs{\configs}{e}{\configs'}{e'}{\trace}}{,,Expression $\src{e}$ evaluates under configuration $\configs$ to $\src{e'}$ and\\new configuration $\src{\configs'}$, emitting list of events $\src{\trace}$.''}
    %
    \typerule{$es-\text{refl}$}{
    }{
      \execs{\configs}{\finalexpr}{\configs}{\finalexpr}{\hole{\cdot}}
    }{ws-e-refl}
    \typerule{$es-\text{trans}-$important}{
      \execs[]{\configs}{e}{\configs'}{e'}{\event}&
      \execs{\configs'}{e'}{\configs''}{e''}{\trace}&
      \src{\event}\not=\src{\emptyevent}
    }{
      \execs{\configs}{e}{\configs''}{e''}{\event \cdot \trace}
    }{ws-e-trans-important}
    \typerule{$es-\text{trans}-$unimportant}{
      \execs[]{\configs}{e}{\configs'}{e'}{\emptyevent}&
      \execs{\configs'}{e'}{\configs''}{e''}{\trace}&
    }{
      \execs{\configs}{e}{\configs''}{e''}{\trace}
    }{ws-e-trans-unimportant}
  \end{center}
}{w-steps}{Trace prefix generation given a $\mmlAs$ program using the reflexive-transitive closure.}

\myfig{
  \begin{center}
    \judgbox{\wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{\finalexprnoerr}{\trace}}{,,Run $\mmlAs$ program $\src{prog\ \library_{ctx}\ \library_{comp}}$, giving dynamic state\\$\configs$ and emitting trace $\src{\trace}$.''}
    \typerule{$e-\text{wprog}$}{
      \vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv \src{\commlib},\src{\library} &
      \src{main}\notin\src{\commlib}\\
      \execs{\commlib;\library;\hole{\cdot};\sandboxtag;\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexpr}{\trace}
    }{
      \wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{\finalexpr}{\trace}
    }{ws-e-prog}
    %
    \typerule{$e-\text{wprog}-\lightning$}{
      \vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv \src{\commlib},\src{\library} &
      \src{main}\notin\src{\commlib}\\
      \execs{\commlib;\library;\hole{\cdot};\sandboxtag;\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexpr}{\trace\cdot\lightning;\sandboxtag}
    }{
      \wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{\finalexpr}{\trace\cdot\lightning;\sandboxtag}
    }{ws-e-prog-crash}
  \end{center}
}{wprog-run}{Running a whole $\mmlAs$ program.}

\subsubsection{\gls*{ms}-Specific Events}
We introduce another set of actions that allows us to abstract over reading or writing at a certain location.

\myfig{
  \begin{gather*}
  \begin{aligned}
    \mi{Events}~\msevent \bnfdef&\ \specificev{\emptyevent}\mid \specificev{Alloc\ \loc\ n} \mid \specificev{Dealloc\ \loc} \mid \specificev{Use\ \loc\ n} \mid \specificev{\lightning}
  \end{aligned}
  \end{gather*}
}{w-specific-events}{\gls*{ms}-Specific Events.}
In addition to the actions, we also need a way to translate from concrete actions, as emitted by a program's execution, to these more abstract actions.
The translation is, however, standard.
The empty action $\specificev{\emptyevent}$ is necessary. When proving lemmas by structural induction on the primitive steps (\Cref{fig:w-expr-prim-eval}), we get a concrete event $\src{\emptyevent}$ that needs to be related to some $\msevent$. The natural candidate is $\specificev{\emptyevent}$.
We also use it to project the call/return events onto it.

\myfig{
  \begin{center}
    \judgbox{\delta(\src{\loc})=\specificev{\loc}}{,,A map from $\mmlAs$ memory locations $\src{\loc}$ to MS-specific locations $\specificev{\loc}$.''}
    \judgbox{\tospecificevs[_{\delta_{MS}}]{\event} = \msevent}{,,Project an $\mmlAs$ event to MS-specific events.''}
    %
    \typerule{filter-context}{
      \src{\event_b} \not= \src{\lightning}
    }{
      \tospecificevs[_{\delta_{MS}}]{\event_b;\ctx} = \specificev{\emptyevent}
    }{filter-context}
    %
    \typerule{filter-comp-start}{
    }{
      \tospecificevs[_{\delta_{MS}}]{Start;\comp} = \specificev{\emptyevent}
    }{filter-comp-start}
    %
    \typerule{filter-comp-alloc}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n}
    }{
      \tospecificevs[_{\delta_{MS}}]{Alloc\ \loc\ n;\comp} = \specificev{Alloc\ \loc\ n}
    }{filter-comp-alloc}
    %
    \typerule{filter-comp-dealloc}{
      \delta_{MS}(\src{\loc})=\specificev{\loc}
    }{
      \tospecificevs[_{\delta_{MS}}]{Dealloc\ \loc;\comp} = \specificev{Dealloc\ \loc}
    }{filter-comp-dealloc}
    %
    \typerule{filter-comp-get}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n}
    }{
      \tospecificevs[_{\delta_{MS}}]{Get\ \loc\ n;\comp} = \specificev{Use\ \loc\ n}
    }{filter-comp-get}
    %
    \typerule{filter-comp-set}{
      \delta_{MS}(\src{\loc})=\specificev{\loc} &
      \specificev{n}=\src{n}
    }{
      \tospecificevs[_{\delta_{MS}}]{Set\ \loc\ n\ \valueexpr;\comp} = \specificev{Use\ \loc\ n}
    }{filter-comp-set}
    %
    \typerule{filter-comp-call}{
    }{
      \tospecificevs[_{\delta_{MS}}]{Call\ \comm\ foo\ \interfacevalue;\comp} = \specificev{\emptyevent}
    }{filter-comp-call}
    %
    \typerule{filter-comp-ret}{
    }{
      \tospecificevs[_{\delta_{MS}}]{Ret\ \comm\ \interfacevalue;\comp} = \specificev{\emptyevent}
    }{filter-comp-ret}
    %
    \typerule{filter-abort}{
    }{
      \tospecificevs[_{\delta_{MS}}]{\lightning;\sandboxtag} = \specificev{\lightning}
    }{filter-abort}
    %
    \judgbox{\tospecificevs[^*_{\delta_{MS}}]{\trace} = \mstrace}{,,Project an $\mmlAs$ trace to MS-specific traces.''}
    %
    \typerule{filter-empty}{
    }{
      \tospecificevs[^*_{\delta_{MS}}]{\hole{\cdot}} = \specificev{\hole{\cdot}}
    }{filter-empty}
    %
    \typerule{filter-cons-relevant}{
      \tospecificevs[_{\delta_{MS}}]{\event} = \specificev{\event} &
      \tospecificevs[^*_{\delta_{MS}}]{\trace} = \mstrace &
      \specificev{\event} \not= \specificev{\emptyevent}
    }{
      \tospecificevs[^*_{\delta_{MS}}]{\event\cdot\trace} = \specificev{\event}\cdot\mstrace
    }{filter-cons-relevant}
    %
    \typerule{filter-cons-relevant}{
      \tospecificevs[_{\delta_{MS}}]{\event} = \specificev{\emptyevent} &
      \tospecificevs[^*_{\delta_{MS}}]{\trace} = \mstrace
    }{
      \tospecificevs[^*_{\delta_{MS}}]{\event\cdot\trace} = \mstrace
    }{filter-cons}
  \end{center}
}{w-events-project-to-specific}{Projection of $\mmlAs$ events to \gls*{ms}-specific events.}

\subsubsection{\gls*{tms} Monitor}
In order to just talk about temporal memory safety, we introduce a monitor that works on more abstract monitor-actions, without any other events besides those relevant to temporal memory safety.

\myfig{
  \begin{gather*}
    \begin{aligned}
      \mi{Abstract\ Store}~\tmsmonitor =&\{A : \specificev{L}, F : \specificev{L}\} \\
      \mi{Abstract\ Events}~\absevent \bnfdef&\ \bm{\varepsilon} \mid \textbf{Alloc}\ \specificev{\loc} \mid \textbf{Dealloc}\ \specificev{\loc} \mid \textbf{Use}\ \specificev{\loc} \mid \abstermination\\[0.3cm]
      \tmsmonitor\subseteq_F \tmsmonitor['] &\text{ iff } \tmsmonitor[.F] \subseteq \tmsmonitor['.F]\\
      \absevent\in \tmsmonitor['] &\text{ iff } \absevent \in {\tmsmonitor['.A]} \wedge \absevent \notin {\tmsmonitor['.F]}\\
      \absevent\notin \tmsmonitor['] &\text{ iff } \absevent \notin {\tmsmonitor['.A]} \wedge \absevent \notin {\tmsmonitor['.F]}\\
      \{\specificev{\loc}\}\cup \tmsmonitor &= \{A : \{\specificev{\loc}\}\cup \tmsmonitor[.A], F : \tmsmonitor[.F]\}\\
      \tmsmonitor\setminus\{\specificev{\loc}\} &= \{A : \tmsmonitor[.A]\setminus\{\specificev{\loc}\}, F : \tmsmonitor[.F]\cup\left\{\specificev{\loc}\right\}\}\\
      \tmsmonitor\cup \tmsmonitor' &= \{A : \tmsmonitor[.A]\cup \tmsmonitor['.A], F : \tmsmonitor[.F]\cup \tmsmonitor['.F]\}\\
    \end{aligned}
  \end{gather*}
}{tms-monitor}{\gls{tms} Monitor.}

As before, when doing structural induction over primitive steps (\Cref{fig:w-expr-prim-eval}) we may encounter the $\src{\emptyevent}$, for which $\tospecificevs{\emptyevent}=\specificev{\emptyevent}$, which needs a ,,partner'' in the abstract events as defined in \Cref{fig:tms-monitor}: $\bm{\varepsilon}$.

\myfig{
  \begin{center}
    \judgbox{\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}}{,,Given abstract state $\tmsmonitor$, step to abstract state $\tmsmonitor'$\\ emitting an abstract event $\absevent$.''}
    \judgbox{\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\abstrace}}{,,Reflexive-Transitive closure of above judgement.\\$\abstrace$ is a list of abstract events.''}
    \typerule{TMS-Uninteresting}{
    }{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\bm{\varepsilon}}
    }{tms-uninteresting}
    %
    \typerule{TMS-Use}{
      \specificev{\loc}\in \tmsmonitor
    }{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\textbf{Use}\ \specificev{\loc}}
    }{tms-use}
    %
    \typerule{TMS-Alloc}{
      \tmsmonitor[']=\left\{\specificev{\loc}\right\}\cup\tmsmonitor&
      \specificev{\loc}\notin \tmsmonitor
    }{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Alloc}\ \specificev{\loc}}
    }{tms-alloc}
    %
    \typerule{TMS-Dealloc}{
      \specificev{\loc}\in \tmsmonitor &
      \tmsmonitor[']=\tmsmonitor\setminus\left\{\specificev{\loc}\right\}
    }{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}
    }{tms-dealloc}
    %
    \typerule{TMS-Refl}{
    }{
      \monitorcheck{\tmsmonitor}{\tmsmonitor}{\hole{\cdot}}
    }{tms-refl}
    %
    \typerule{TMS-Trans}{
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}&
      \monitorcheck{\tmsmonitor[']}{\tmsmonitor['']}{\abstrace}&
    }{
      \monitorcheck{\tmsmonitor}{\tmsmonitor['']}{\absevent\cdot\abstrace}
    }{tms-trans}
  \end{center}
}{tms-step}{Steps of \gls{tms} Monitor.}

The monitor-state contains two sets of locations that represent the ones that are active and the ones that have been deallocated, respectively.
As seen in \Cref{tr:tms-dealloc}, the monitor only steps if the intuitive condition is true: a location can only be deallocated if it is part of the set of allocated locations.
\Cref{tr:tms-use} ensures that only allocated locations occur in events representing usage, the monitor cannot step if the location has been deallocated before.

As before, we need a way to translate one set of actions to another:

\myfig{
  \begin{center}
    \judgbox{\tmstraceagree{\msevent}{\absevent}}{,,Memory-Safety specific event $\msevent$ describes same action as $\absevent$.''}
    \judgbox{\tmstraceagree[^*]{\mstrace}{\abstrace}}{,,Memory-Safety specific trace $\mstrace$ describes same trace as $\abstrace$.''}
    %
    \typerule{TMS-Alloc-Authentic}{
    }{
      \tmstraceagree{\specificev{Alloc\ \loc\ n}}{\textbf{Alloc}\ \specificev{\loc}}
    }{tms-alloc-auth}
    %
    \typerule{TMS-Dealloc-Authentic}{
    }{
      \tmstraceagree{\specificev{Dealloc\ \loc}}{\textbf{Dealloc}\ \specificev{\loc}}
    }{tms-dealloc-auth}
    %
    \typerule{TMS-Use-Authentic}{
    }{
      \tmstraceagree{\specificev{Use\ \loc\ n}}{\textbf{Use}\ \specificev{\loc}}
    }{tms-use-auth}
    %
    \typerule{TMS-None-Authentic}{
    }{
      \tmstraceagree{\specificev{\varepsilon}}{\bm{\varepsilon}}
    }{tms-use-auth}
    %
    \typerule{TMS-Refl-Authentic}{
    }{
      \tmstraceagree[^*]{\hole{\cdot}}{\hole{\cdot}}
    }{tms-refl-auth}
    %
    \typerule{TMS-Trans-Authentic}{
      \tmstraceagree{\msevent}{\absevent} &
      \tmstraceagree[^*]{\mstrace}{\abstrace}
    }{
      \tmstraceagree[^*]{\msevent\cdot\mstrace}{\absevent\cdot\abstrace}
    }{tms-trans-auth}
  \end{center}
}{tms-trace-agreement}{Trace Agreement.}

\myfig{
  \begin{center}
    \judgbox{\delta_{MS}(\src{\loc})=\specificev{\loc}}{,,Map $\mmlAs$ locations $\src{\loc}$ to abstract locations $\specificev{\loc}$.''}
    \judgbox{\storeagreetms{\tmsmonitor}{\src{\Delta}}}{,,Abstract memory state $\tmsmonitor$ describes the concrete state $\src{\Delta}$.''}
    \typerule{Empty-Agree}{
    }{
      \storeagreetms{\emptyset}{\src{\hole{\cdot}}}
    }{store-empty-agree}
    %
    \typerule{Cons-Agree}{
      \delta_{MS}(\src{\loc})=\specificev{\loc}&
      \specificev{\loc}\notin\tmsmonitor&
      \storeagreetms{\tmsmonitor}{\src{\Delta}}
    }{
      \storeagreetms{\left\{\specificev{\loc}\right\}\cup \tmsmonitor}{\src{x\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}}
    }{store-cons-agree}
    %
    \typerule{Poison-Agree}{
      \delta_{MS}(\src{\loc})=\specificev{\loc}&
      \storeagreetms{\tmsmonitor}{\src{\Delta}}
    }{
      \storeagreetms{\tmsmonitor}{\src{x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta}}
    }{store-poison-agree}
  \end{center}
}{tms-store-agreement}{Store Agreement.}

\subsubsection{\gls*{sms} Monitor}

\myfig{
  \begin{gather*}
    \begin{aligned}
      \mi{Abstract\ Store}~\smsmonitor =&\ \specificev{L}\times\nat \\
      \mi{Abstract\ Events}~\absevent \bnfdef&\ \bm{\varepsilon}\mid \textbf{Alloc}\ \specificev{\loc}\ \bm{n} \mid \textbf{Dealloc}\ \specificev{\loc} \mid \textbf{Use}\ \specificev{\loc}\ \bm{n} \mid \abstermination\\
    \end{aligned}
  \end{gather*}
}{sms-monitor}{\gls{sms} Monitor.}

\myfig{
  \begin{center}
    \judgbox{\monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\absevent}}{,,Given abstract state $\smsmonitor$, step to abstract state $\smsmonitor'$\\ emitting an abstract event $\absevent$.''}
    \judgbox{\monitorcheck{\smsmonitor}{\smsmonitor[']}{\abstrace}}{,,Reflexive-Transitive closure of above judgement.\\$\abstrace$ is a list of abstract events.''}
    %
    \typerule{sms-Use}{
      (\specificev{\loc},m) \in \smsmonitor&
      n < m
    }{
      \monitorcheck[]{\smsmonitor}{\smsmonitor}{\textbf{Use}\ \loc\ \bm{n}}
    }{sms-use}
    %
    \typerule{sms-Alloc}{
      \specificev{\loc} \notin \text{dom }\smsmonitor&
      \smsmonitor[']=\smsmonitor \cup \left\{(\specificev{\loc},n)\right\}
    }{
      \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\textbf{Alloc}\ \specificev{\loc}\ \bm{n}}
    }{sms-alloc}
    %
    \typerule{sms-Dealloc}{
      (\specificev{\loc},m) \in \smsmonitor &
      \smsmonitor[']=\smsmonitor\setminus\left\{(\specificev{\loc},m)\right\}
    }{
      \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}
    }{sms-dealloc}
    %
    \typerule{sms-Refl}{
    }{
      \monitorcheck{\smsmonitor}{\smsmonitor}{\hole{\cdot}}
    }{sms-refl}
    %
    \typerule{sms-Trans}{
      \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\absevent}&
      \monitorcheck{\smsmonitor[']}{\smsmonitor['']}{\abstrace}
    }{
      \monitorcheck{\smsmonitor}{\smsmonitor['']}{\absevent\cdot\abstrace}
    }{sms-trans}
  \end{center}
}{sms-step}{Steps of \gls{sms} Monitor.}

\myfig{
  \begin{center}
    \judgbox{\smstraceagree{\msevent}{\absevent}}{,,Memory-Safety specific event $\msevent$ describes same action as $\absevent$.''}
    \judgbox{\smstraceagree{\mstrace}{\abstrace}}{,,Memory-Safety specific trace $\mstrace$ describes same trace as $\abstrace$.''}
    %
    \typerule{SMS-Alloc-Authentic}{
    }{
      \smstraceagree{\specificev{Alloc\ \loc\ n}}{\textbf{Alloc}\ \specificev{\loc}\ \bm{n}}
    }{sms-alloc-auth}
    %
    \typerule{SMS-Dealloc-Authentic}{
    }{
      \smstraceagree{\specificev{Dealloc\ \loc}}{\textbf{Dealloc}\ \specificev{\loc}}
    }{sms-dealloc-auth}
    %
    \typerule{SMS-Use-Authentic}{
    }{
      \smstraceagree{\specificev{Use\ \loc\ n}}{\textbf{Use}\ \specificev{\loc}\ \bm{n}}
    }{sms-use-auth}
    %
    \typerule{SMS-Refl-Authentic}{
    }{
      \smstraceagree{\hole{\cdot}}{\hole{\cdot}}
    }{sms-refl-auth}
    %
    \typerule{SMS-Trans-Authentic}{
      \smstraceagree{\msevent}{\absevent} &
      \smstraceagree{\mstrace}{\abstrace}
    }{
      \smstraceagree{\msevent \cdot \mstrace}{\absevent \cdot \abstrace}
    }{sms-trans-auth}
  \end{center}
}{sms-trace-agreement}{Trace Agreement.}


\myfig{
  \begin{center}
    \typerule{abstract-agree-dealloc}{
    }{
    \textbf{Dealloc}\ \specificev{\loc} \prec \textbf{Dealloc}\ \specificev{\loc}
    }{aagree-dealloc}
    %
    \typerule{abstract-agree-alloc}{
    }{
    \textbf{Alloc}\ \specificev{\loc}\ \bm{n} \prec \textbf{Alloc}\ \specificev{\loc}
    }{aagree-alloc}
    %
    \typerule{abstract-agree-use}{
    }{
    \textbf{Use}\ \specificev{\loc}\ \bm{n} \prec \textbf{Use}\ \specificev{\loc}
    }{use-dealloc}
    %
    \typerule{tms-sms-E}{
      \monitorcheck[]{\smsmonitor}{\smsmonitor}{\absevent} &
      \absevent\prec \absevent['] &
      \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\absevent[']} &
    T = \tmsmonitor\times\smsmonitor
    }{
      \monitorcheck[]{T}{T}{\absevent}
    }{tms-sms-empty}
    %
    \typerule{tms-sms-Refl}{
    }{
      \monitorcheck{T}{T}{\hole{\cdot}}
    }{tms-sms-refl}
    %
    \typerule{tms-sms-Trans}{
      \monitorcheck[]{T}{T'}{\absevent}&
      \monitorcheck{T'}{T''}{\abstrace}&
    }{
      \monitorcheck{T}{T''}{\absevent\cdot\abstrace}
    }{tms-sms-trans}
  \end{center}
}{tms-sms-step}{Steps of combined \gls{tms} + \gls{sms} Monitor.}


We now define temporal and spatial memory safety in terms of $\mstrace$ traces.

\begin{definition}[Once]
  Given an event $\msevent$ and a trace $\mstrace$, we say $\msevent$ appears exactly once in the trace, written $\msevent\in_{!}\mstrace$, iff

  If $n\in\nat$ such that $\trace{[n]}=\msevent$, then for any $m\in\nat$ such that $\trace{[m]}=\msevent$ we have $n = m$.
\end{definition}

\begin{definition}[Before]
  Given two events $\msevent[_0],\msevent[_1]$ and a trace $\mstrace$, event $\msevent[_0]$ occurs before $\msevent[_1]$ in $\mstrace$, written
  $\event{_0}\le_{\trace}\event{_1}$, iff

  If $n\in\nat$ such that $\mstrace{[n]} = \msevent[_{0}]$, then $\exists m\in\nat, \mstrace{[m]} = \msevent[_1] \wedge n< m$
\end{definition}

\begin{definition}[\gls{tms} on Traces]\label{def:tempmemsafe}
  We define the property $\operatorname{tmsafe}$ as a conjunction of the following conditions for any given $\mstrace$:
  \begin{itemize}
    \item $\specificev{Alloc\ \loc\ s}\le_{{\mstrace}}\specificev{Dealloc\ \loc}$
    \item $\neg(\specificev{Use\ \loc\ n}\le_{{\mstrace}}\specificev{Alloc\ \loc\ s})$
    \item $\neg(\specificev{Dealloc\ \loc}\le_{{\mstrace}}\specificev{Use\ \loc\ n})$
    \item $\specificev{Alloc\ \loc\ s}\in_{!}\mstrace$
    \item $\specificev{Dealloc\ \loc}\in_{!}\mstrace$
  \end{itemize}
\end{definition}

\begin{definition}[Spatial Memory Safety]\label{def:spatmemsafe}
  We define the property $\operatorname{smsafe}$ as follows for any given $\mstrace$:
  \begin{itemize}
    \item If $\specificev{Alloc\ \loc\ s}\in{\mstrace}$ and $\specificev{Use\ \loc\ n}\in{\mstrace}$, then ${n}<{s}$
  \end{itemize}
\end{definition}

\begin{definition}[Trace is temporal memory safe via monitor.]\label{def:src:trace:tms}
  We say $\texttt{TMS}(\mstrace)$ iff $\exists \delta_{\text{tms}}\ \abstrace\ \tmsmonitor$ such that:
  \begin{itemize}
    \item $\tmstraceagree{\mstrace}{\abstrace}$
    \item and $\monitorcheck{\emptyset}{\tmsmonitor}{\abstrace}$
  \end{itemize}
\end{definition}

\begin{lemma}[$\texttt{TMS}(\mstrace)$ implies $\mstrace\in\operatorname{tmsafe}$]\label{lem:tmssafe-tracetms}
  If
  \begin{assumptions}
    \item\label[ass]{asm:tmssafe-tracetms:tms} $\texttt{TMS}(\mstrace)$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\mstrace\in\operatorname{tmsafe}$
  \end{goals}
\end{lemma}
\begin{proof}
  Induction on \Cref{asm:tmssafe-tracetms:tms}.
\end{proof}

\begin{scontents}[store-env=buffer]
  If
  \begin{assumptions}
  \item\label[ass]{asm:mmlatmsviamonitor:run} $\wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{v}{\trace}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\tospecificevs[_{\delta_{ms}}]{\trace}\in\operatorname{tmssafe}$
  \end{goals}.
\end{scontents}
\mockthm{thm:mmlAs:tmssafe}{1}

\begin{scontents}[store-env=buffer]
  There is a well-typed $\mmlAs$ component that does not robustly satisfy \Cref{def:spatmemsafe}:
  $\rsat{\src{\library}}{smsafe}$
\end{scontents}

\realthm{thm:mmlAs:not:smssafe}{2}{$\mmlAs$ is not spatially memory safe}
\begin{proof}
  We pick:
  $$\src{\library_{comp}} = \src{let\ foo\ x:\nat\to\nat:=let\ z=new\ x\ in\ let\ w = z[1337]\ in\ let\ \_ = delete\ z\ in\ w},\src{\hole{\cdot}}$$
  and
  $
  \src{\library_{ctx}} = \src{let\ main\ z:\nat\to\nat:=call\ foo\ 42},\src{\hole{\cdot}}
  $.
  Let $\src{\library} \equiv \src{\library_{comp}}\cup\src{\library_{ctx}}$.
  We show $\vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv\src{\library},\left\{\src{foo}\right\}$.
  First note that $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$, since $\operatorname{dom}\ \src{\library_{ctx}}\cap\operatorname{dom\ \src{\library_{comp}}}=\emptyset$ and $\src{\library}\equiv\src{\library_{ctx}\cup\library_{comp}}$ by definition.
  Now, $\operatorname{dom}\ \src{\library_{comp}}=\left\{\src{foo}\right\}$ and $\src{\library}\downarrow=\src{foo\mapsto\nat\to\nat,main\mapsto\nat\to\nat,\hole{\cdot}}=\src{\Gamma_{0}}$ by \Cref{tr:w-lib-proj-empty,tr:w-lib-proj-cons}.
  Consequently, $\src{main}\in\operatorname{dom}\src{\Gamma_{0}}=\left\{\src{foo},\src{main}\right\}$.
  Note that \Cref{tr:src-int-type-nat} gives $\src{\nat}\ \operatorname{int}$.
  Using \Cref{tr:w-t-lib-empty,tr:w-t-lib-cons}, what is left to show are the following:
  \begin{enumerate}
    \item $\typechecks{x:\nat,\Gamma_{0}}{let\ z=new\ x\ in\ let\ w = z[1337]\ in\ delete\ z; w}{\nat}$
    \item $\typechecks{z:\nat,\Gamma_{0}}{call\ foo\ 42}{\nat}$
  \end{enumerate}

  Let $\src{e_w}=\src{let\ w=z[1337]\ in\ delete\ z; w}$, $\Gammas=\src{z:\ptr,x:\nat,\hole{\cdot}}$, and $\src{\Gamma'}=\src{z:\wptr,x:\nat,\hole{\cdot}}$ due to space constraints.

  \bigskip
  \noindent\makebox[\textwidth]{%
    \typerulederiv{$\text{\Cref{tr:w-t-new}}$}{
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{x:\nat,\hole{\cdot}}{x}{\nat}
      } &
      \typerulederiv{$\text{\Cref{tr:t-let}}$}{
        \typechecks{\Gamma'}{z[1337]}{\nat} &
        \typechecks{w:\nat,\Gamma}{delete\ z;w}{\nat}
      }{
        \typechecks{\Gamma'\circ\Gamma}{e_w}{\nat}
      }
    }{
      \typechecks{x:\nat,\hole{\cdot}\circ x:\nat,\hole{\cdot}}{let\ z=new\ x\ in\ let\ w = z[1337]\ in\ delete\ z; w}{\nat}
    }}
  \bigskip

  Observe that:

  \bigskip
  \noindent\makebox[\textwidth]{%
    \typerulederiv{$\text{\Cref{tr:t-get}}$}{
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{
        \src{\wptr}\not=\src{\ptr}&
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{\Gamma'}{z}{\wptr}
      } &
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{
        \src{\wptr}\not=\src{\ptr}&
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{\Gamma'}{x}{\nat}
      }
    }{
      \typechecks{\Gamma'\circ\Gamma'}{z[1337]}{\nat}
  }}
  \bigskip

  And:

  \bigskip
  \noindent\makebox[\textwidth]{%
    \typerulederiv{$\text{\Cref{tr:t-let}}$}{
      \typerulederiv{$\text{\Cref{tr:w-t-delete}}$}{
        \src{\nat}\not=\src{\ptr} &
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{w:\nat,z:\ptr,x:\nat,\hole{\cdot}}{delete\ z}{\nat}
      }&
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{
        \src{\nat}\not=\src{\ptr} &
        \src{\nat}\not=\src{\ptr}
      }{
        \typechecks{w:\nat,x:\nat,\hole{\cdot}}{w}{\nat}
      }
    }{
      \typechecks{w:\nat,z:\ptr,x:\nat,\hole{\cdot}\circ w:\nat,x:\nat,\hole{\cdot}}{delete\ z;w}{\nat}
    }}
  \bigskip

  Thus, it typechecks.\\[0.3cm]
  Now consider the other case:

  \bigskip
  \noindent\makebox[\textwidth]{%
    \typerulederiv{$\text{\Cref{tr:t-call}}$}{
      \typerulederiv{$\text{\Cref{tr:t-var}}$}{}{\typechecks{z:\nat,\Gamma_0}{foo}{\nat}}&
      \typerulederiv{$\text{\Cref{tr:t-nat}}$}{}{\typechecks{z:\nat,\Gamma_0}{42}{\nat}}&
      \typerulederiv{$\text{\Cref{tr:src-int-type-nat}}$}{}{\src{\nat}\ \operatorname{int}}
    }{
      \typecheck{\src{z:\nat,\Gamma_0}}{\src{call\ foo\ 42}}{\src{\nat}}
    }}
  \bigskip

  Note that $\src{NoOwnedPtr\ z:\nat,\Gamma_{0}}$ holds by $\src{\nat}\not=\src{\ptr}$ and $\src{\nat\to\nat}\not=\src{\ptr}$

  Running the whole program via \Cref{tr:ws-e-prog} yields trace prefix\\$\src{\trace}=\src{Start;\comp}\cdot\src{Call\ !foo\ 42;\ctx}\cdot\src{Alloc\ \loc\ 42;\comp}\cdot\src{Get\ \loc\ 1337;\comp}\cdot\src{Dealloc\ \loc;\comp}\cdot\src{Ret\ ?1729;\comp}\cdot\src{End\ 1729;\ctx}$.
  We omit the precise derivation for brevity, but note that \thmref{lem:toplevel:progress} gives us the necessary execution.\\[0.3cm]
  By \Cref{fig:w-events-project-to-specific}, $\tospecificevs{\trace}=\specificev{Alloc\ \loc\ 42}\cdot\specificev{Use\ \loc\ 1337}\cdot\specificev{Dealloc\ \loc}$.\\[0.3cm]
  \Cref{def:spatmemsafe} requires $\specificev{Alloc\ \loc\ 42}\in\tospecificevs{\trace}$ and $\specificev{Use\ \loc\ 1337}\in\tospecificevs{\trace}$, which hold.\\[0.3cm]
  But, ${1337}\not<{42}$, hence $\nrsat{\src{\library_{comp}}}{{smsafe}}$.
\end{proof}

\subsubsection{Auxiliary Definitions and Lemmas}\label{sec:mmla:aux}

\begin{lemma}[Static Typing implies Runtime Timing (Toplevel)]\label{lem:static-implies-runtime:toplevel}
  If
  \begin{assumptions}
    \item\label[ass]{asm:static-implies-runtime:gamma} $\src{\library}\downarrow=\src{\Gamma_{0}}$
    \item\label[ass]{asm:static-implies-runtime:static} $\typechecks{\Gamma_0}{call\ main\ 0}{\nat}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\commlib;\library;\hole{\cdot};\comp;\hole{\cdot}^{\ctx};\hole{\cdot}^{\comp};\hole{\cdot}\triangleright call\ main\ 0}{\nat}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Typed Linking Recomposition]\label{lem:typed:linking:recomposition}
  If
  \begin{assumptions}
    \item $\src{\library} = \src{\library_{1}\linker\library_{2}}$
    \item $\Gammas\vdash\src{\library_{1}}\operatorname{ok}$
    \item $\Gammas\vdash\src{\library_{2}}\operatorname{ok}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\Gammas\vdash\src{\library}\operatorname{ok}$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy.
\end{proof}

\begin{lemma}[Typing Decomposition]\label{lem:ctxtyping:plugged}
  If
  \begin{assumptions}
    \item $\typechecks{\Gamma}{K[e]}{\type}$
  \end{assumptions}
  Then $\exists \src{\type_{e}}$,
  \begin{goals}
    \item $\typechecks{\Gamma}{K}{\type_{e}\to\type}$
    \item $\typechecks{\Gamma}{e}{\type_{e}}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Store Agree Weaken]\label{lem:store-agree-weaken}
  If
  \begin{assumptions}
    \item $\storeagreetms{\tmsmonitor}{\src{\Delta}}$
    \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor}{\src{\Delta}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Induction on $\storeagreetms{\tmsmonitor}{\src{\Delta}}$.
\end{proof}

\begin{lemma}[Filter Weaken]\label{lem:filter-weaken}
  If
  \begin{assumptions}
    \item $\theta_{\delta}\left(\src{\trace}\right) \not=\hole{\cdot}$
    \item $\delta\subseteq\delta'$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\theta_{\delta}\left(\src{\trace}\right) = \theta_{\delta'}\left(\src{\trace}\right)$
  \end{goals}
\end{lemma}

\begin{lemma}[\gls{tms}-$\src{\Delta}$-split]\label{lem:tms:store:split}
  If
  \begin{assumptions}
    \item $\storeagreetms{\tmsmonitor}{\src{\Delta_{1},x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_{2}}}$
  \end{assumptions}
  Then $\exists \tmsmonitor[_{1}]\ \tmsmonitor[_{2}]\ \specificev{\loc}$,
  \begin{goals}
    \item $\storeagreetms{\tmsmonitor[_{1}]}{\src{\Delta_{1}}}$
    \item $\storeagreetms{\{\specificev{\loc}\}\cup\emptyset}{\src{x\mapsto(\loc;\sandboxtag;\poison;n),\hole{\cdot}}}$
    \item $\storeagreetms{\tmsmonitor[_{2}]}{\src{\Delta_{2}}}$
    \item $\tmsmonitor=\tmsmonitor_{1}\cup\{\specificev{\loc}\}\cup\tmsmonitor_{2}$
  \end{goals}
\end{lemma}
\begin{proof}
  Trivial.
\end{proof}


\begin{lemma}[Trace-based Transitivity Authentic]\label{lem:trace-agree-trans}
  If
  \begin{assumptions}
    \item $\tmstraceagree[^{*}]{\mstrace[_{1}]}{\abstrace_{1}}$
    \item $\tmstraceagree[^{*}]{\mstrace[_{2}]}{\abstrace_{2}}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmstraceagree[^{*}]{\mstrace[_{1}]\cdot\mstrace[_{2}]}{\abstrace_{1}\cdot\abstrace_{2}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy using \Cref{tr:tms-trans-auth}.
\end{proof}

\begin{lemma}[Monitor Step Subset]\label{lem:monitor-step-subset}
  If
  \begin{assumptions}
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmsmonitor\subseteq_F \tmsmonitor[']$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy induction on $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$.
\end{proof}

\begin{lemma}[Monitor Steps Subset]\label{lem:monitor-steps-subset}
  If
  \begin{assumptions}
    \item $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\tmsmonitor\subseteq_F \tmsmonitor[']$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy induction on $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\absevent}$ using \Thmref{lem:monitor-step-subset}.
\end{proof}

\begin{lemma}[$\alpha$-conv. Typing]\label{lem:alpha-conv-typing}
  If
  \begin{assumptions}
    \item $\typechecks{\Gamma}{e}{\type}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{\Gamma[z:\type'/x:\type]}{e[z/x]}{\type}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Substitution]\label{lem:substitution}
  If
  \begin{assumptions}
    \item $\typechecks{x:\type',\Gamma_1}{e}{\type}$
    \item $\typechecks{\Gamma_2}{v}{\type'}$
    \item $\src{\Gamma_3}=\src{\Gamma_1}\circ\src{\Gamma_2}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{\Gamma_3}{e[v/x]}{\type}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Base Preservation]\label{lem:base-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item $\exprevals{\configs}{e}{\configs'}{e'}{\event}$
    \item $\configs'\not=\src{\lightning}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\type}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Ctx Preservation]\label{lem:ctx-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item $\execs[]{\configs}{e}{\configs'}{e'}{\event}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\type}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Steps Preservation]\label{lem:steps-preservation}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item $\execs{\configs}{e}{\configs'}{e'}{\trace}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\typechecks{}{\src{\Omega'}\triangleright e'}{\src{\type}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Progress]\label{lem:progress}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\src{e}=\src{\finalexprnoerr}$ or $\exists \src{\Omega'}\ \src{\finalexprnoerr}\ \src{\trace}, \execs{\configs}{e}{\configs'}{\finalexprnoerr}{\trace}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{scontents}[store-env=buffer]
  If
  \begin{assumptions}
  \item $\typechecks{}{e}{\type}$
  \end{assumptions}
  Then $\exists \src{\Omega}\ \src{\trace}\ \src{\finalexprnoerr}$,
  \begin{goals}
  \item $\execs{\hole{\cdot};\hole{\cdot}}{e}{\Omega}{\finalexprnoerr}{\trace}$
  \item $\typechecks{}{\finalexprnoerr}{\type}$
  \end{goals}.
\end{scontents}
\realthm{thm:mmlAs:typesafe}{3}{Type Safety}

\begin{lemma}[Top-Level Progress]\label{lem:toplevel:progress}
  If
  \begin{assumptions}
    \item $\vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv\src{\library},\src{\commlib}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\exists \configs\ \src{\finalexprnoerr}\ \src{\trace}, \wexecs{prog\ \library_{ctx}\ \library_{comp}}{\Omega}{\finalexprnoerr}{\trace}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Base \gls{tms} via Monitor]\label{lem:basetmsmonitor}
  If
  \begin{assumptions}
    \item $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item $\exprevals{\configs}{e}{\configs'}{e'}{\event}$
    \item $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
  \begin{goals}
    \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
    \item $\tmstraceagree{\tospecificevs[_{\delta_{\text{MS}}'}]{\event}}{\absevent}$
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
    \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{proof}
  First, we note
  \begin{itemize}
    \item $\src{\Omega}=\src{\cfstate;\sandboxtag;\memstate}$
    \item $\src{\cfstate}=\src{\commlib;\library;\kontstack}$
    \item $\src{\memstate}=\src{H;\Delta}$
  \end{itemize}
  Induction on $\exprevals{\configs}{e}{\configs'}{e'}{\event}$.
  \begin{description}
    \item[$\src{e}=\src{delete\ x}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\cfstate;\sandboxtag;H;\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2}\triangleright \src{delete\ x}}{\type}$
        \item\label[ass]{asm:basetmsmonitor:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item\label[goal]{goal:basetmsmonitor:subseteq} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item\label[goal]{goal:basetmsmonitor:tmstraceagree} $\traceagree{\specificev{Dealloc\ }\delta_{\text{MS}}'(\src{\loc})}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}}$
      \end{goals}

      Apply \Thmref{lem:tms:store:split} on \Cref{asm:basetmsmonitor:storeagree}:
      \begin{passumptions}{F}
        \item $\storeagreetms{\tmsmonitor[_{1}]}{\src{\Delta_{1}}}$
        \item\label[ass]{asm:basetmsmonitor:storeagree:unfolded} $\storeagreetms{\{\specificev{\loc}\}\cup\emptyset}{\src{x\mapsto(\loc;\sandboxtag;\poison;n),\hole{\cdot}}}$
        \item $\storeagreetms{\tmsmonitor[_{2}]}{\src{\Delta_{2}}}$
        \item $\tmsmonitor=\tmsmonitor_{1}\cup\{\specificev{\loc}\}\cup\tmsmonitor_{2}$
      \end{passumptions}
      Invert \Cref{asm:basetmsmonitor:storeagree:unfolded} to conclude $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$.
      Choose $\absevent=\textbf{Dealloc\ }\specificev{\loc}$ and $\delta_{\text{MS}}'=\delta_{\text{MS}}$.

      \Cref{goal:basetmsmonitor:subseteq}, $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}$, follows trivially.

        For $\tmstraceagree{\specificev{Dealloc\ }\delta_{\text{MS}}'(\src{\loc})}{\textbf{Dealloc}\ \specificev{\loc}}$ (\Cref{goal:basetmsmonitor:tmstraceagree}), apply \Cref{tr:tms-dealloc-auth}.

      The inversion yields two cases:
      \begin{description}
      \item[\Cref{tr:store-cons-agree}:] \ \\
        If
        \begin{passumptions}{F}
        \item $\typechecks{}{\src{\cfstate;\sandboxtag;H;\Delta_1},\src{x\mapsto(\loc;\sandboxtag;\poisonless;n),\src{\Delta_2}\triangleright \src{delete\ x}}}{\type}$
        \item $\storeagreetms{\tmsmonitor[_1]}{\src{\Delta_1}}$
        \item $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$
        \item $\storeagreetms{\tmsmonitor[_2]}{\src{\Delta_2}}$
        \item $\tmsmonitor=\tmsmonitor[_1]\cup\left\{\specificev{\loc}\right\}\cup \tmsmonitor[_2]$
        \end{passumptions}
        then $\exists \tmsmonitor[']$,
        \begin{goals}
        \item\label[goal]{goal:basetmsmonitor:monitorcheck1} $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}$
        \item\label[goal]{goal:basetmsmonitor:storeagree1} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}}$
        \end{goals}
        Choose $\tmsmonitor[']=\tmsmonitor[_1]\cup \tmsmonitor[_2]$.

        \Cref{goal:basetmsmonitor:monitorcheck1}, $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}$, follows immediately by \Cref{tr:tms-dealloc}.

        \Cref{goal:basetmsmonitor:storeagree1}, $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}}$, follows immediately by \Cref{tr:store-poison-agree}.

      \item[\Cref{tr:store-poison-agree}:] \ \\
        If
        \begin{passumptions}{F}
        \item\label[ass]{asm:basetmsmonitor:typing} $\typechecks{}{\src{\cfstate;\sandboxtag;H;\Delta_1},\src{x\mapsto(\loc;\sandboxtag;\poisoned;n)},\src{\Delta_2}\triangleright \src{delete\ x}}{\type}$
        \item $\storeagreetms{\tmsmonitor[_1]}{\src{\Delta_1}}$
        \item $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$
        \item $\storeagreetms{\tmsmonitor[_2]}{\src{\Delta_2}}$
        \item $\tmsmonitor=\tmsmonitor[_1]\cup \tmsmonitor[_2]$
        \end{passumptions}
        then $\exists \tmsmonitor[']$,
        \begin{goals}
        \item\label[goal]{goal:basetmsmonitor:monitorcheck2} $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\textbf{Dealloc}\ \specificev{\loc}}$
        \item\label[goal]{goal:basetmsmonitor:storeagree2} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}}$
        \end{goals}.

        Invert \Cref{asm:basetmsmonitor:typing} to get
        \begin{passumptions}{F}
          \setcounter{enumi}{6}
          \item\label[ass]{asm:basetmsmonitor:storechecks} $\typechecks{\library}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}}{\Gammas}$
          \item\label[ass]{asm:basetmsmonitor:freechecks} $\typechecks{\Gammas}{delete\ x}{\nat}$
        \end{passumptions}

      Due to \Cref{asm:basetmsmonitor:storechecks}, we know $\src{x:\ptr}\not\in\Gammas$.

      But, that contradicts \Cref{asm:basetmsmonitor:freechecks}.
      \end{description}

    \item[$\src{e}=\src{n_1+n_2}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}\triangleright\src{n_1+n_2}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{\varepsilon}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega}}$
      \end{goals}
      Choose $\absevent=\bm{\varepsilon}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.

      All goals are completely trivial.

    \item[$\src{e}=\src{let\ x=\finalexprnoerr\ in\ e'}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}\triangleright\src{let\ x=\finalexprnoerr\ in\ e'}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{\varepsilon}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega}}$
      \end{goals}
      Choose $\absevent=\bm{\varepsilon}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.

      All goals are completely trivial.

    \item[$\src{e}=\src{ifz\ 0\ then\ e_1\ else\ e_2}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}\triangleright\src{ifz\ 0\ then\ e_1\ else\ e_2}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{\varepsilon}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega}}$
      \end{goals}
      Choose $\absevent=\bm{\emptyevent}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.

      All goals are completely trivial.

    \item[$\src{e}=\src{ifz\ S(n)\ then\ e_1\ else\ e_2}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}\triangleright\src{ifz\ S(n)\ then\ e_1\ else\ e_2}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree[]{\specificev{\varepsilon}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega}}$
      \end{goals}
      Choose $\absevent=\bm{\emptyevent}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.

      All goals are completely trivial.

    \item[$\src{e}=\src{let\ x=new\ n\ in\ e'}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\Omega}}{\type}$
        \item\label[ass]{asm:basetmsmonitor:case4:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Omega}}$
        \item $\fresh{\src{\Delta}}{\src{\loc}}$
        \item $\fresh{\src{\Delta}}{\src{z}}$
        \item $\src{H'}=\src{H}\ll\src{n}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{Alloc\ }\delta_{\text{MS}}'(\loc)\specificev{\ n}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}}$
      \end{goals}
      Let $\specificev{\loc}$ be such that $\fresh{\operatorname{dom} \delta_{\text{MS}}}{\specificev{\loc}}$.
      Choose $\absevent=\bm{Alloc\ }\specificev{\loc}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}\cup\left\{\src{\loc}\mapsto\specificev{\loc}\right\}$, and $\tmsmonitor[']=\left\{\specificev{\loc}\right\}\cup\tmsmonitor$.
      The goals become:
      \begin{goals}
        \item\label[goal]{goal:basetmsmonitor:case4:subseteq} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}\cup\left\{\src{\loc}\mapsto\specificev{\loc}\right\}$
        \item\label[goal]{goal:basetmsmonitor:case4:tmstraceagree} $\traceagree{\specificev{Alloc\ \loc\ n}}{\bm{Alloc\ }\specificev{\loc}}$
        \item\label[goal]{goal:basetmsmonitor:case4:monitorstep} $\monitorcheck[]{\tmsmonitor}{\left\{A:\tmsmonitor.A\cup\left\{\specificev{\loc}\right\},F:\tmsmonitor.F\right\}}{\bm{Alloc\ }\specificev{\loc}}$
        \item\label[goal]{goal:basetmsmonitor:case4:storeagree} $\storeagreetms[\delta_{MS}\cup\left\{\src{\loc}\mapsto\specificev{\loc}\right\}]{\left\{\specificev{\loc}\right\}\cup\tmsmonitor}{\src{z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}}$
      \end{goals}

      \Cref{goal:basetmsmonitor:case4:subseteq} is trivial.

      \Cref{goal:basetmsmonitor:case4:tmstraceagree} follows immediately by \Cref{tr:tms-alloc-auth}.

      \Cref{goal:basetmsmonitor:case4:monitorstep} follows by \Cref{tr:tms-alloc}.

      \Cref{goal:basetmsmonitor:case4:storeagree} follows by \Cref{tr:store-cons-agree}.

    \item[$\src{e}=\src{x[n]}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\cfstate};\sandboxtag;\src{H};\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;m),\Delta_2}\triangleright\src{x[n]}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;m),\Delta_2}}$
        \item $\src{\loc}\in\operatorname{dom}\src{H}\implies \src{v}=\src{H}\left(\src{\loc+n}\right)$
        \item $\src{\loc}\not\in\operatorname{dom}\src{H}\implies \src{v}=\src{1729}$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree[\delta_{\text{MS}}']{\specificev{Use\ }\delta_{\text{MS}}'(\loc)\specificev{\ n}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;m),\Delta_2}}$
      \end{goals}

      Apply \Thmref{lem:tms:store:split} on \Cref{asm:basetmsmonitor:storeagree}:
      \begin{passumptions}{F}
        \item $\storeagreetms{\tmsmonitor[_{1}]}{\src{\Delta_{1}}}$
        \item\label[ass]{asm:basetmsmonitor:storeagree:unfolded} $\storeagreetms{\{\specificev{\loc}\}\cup\emptyset}{\src{x\mapsto(\loc;\sandboxtag;\poison;m),\hole{\cdot}}}$
        \item $\storeagreetms{\tmsmonitor[_{2}]}{\src{\Delta_{2}}}$
        \item $\tmsmonitor=\tmsmonitor_{1}\cup\{\specificev{\loc}\}\cup\tmsmonitor_{2}$
      \end{passumptions}
      Invert \Cref{asm:basetmsmonitor:storeagree:unfolded} to conclude $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$.
      Choose $\absevent=\bm{Use\ }\specificev{\loc}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.
      The goals become:
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}$
        \item $\traceagree{\specificev{Use\ \loc\ n}}{\bm{Use\ }\specificev{\loc}}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\bm{Use\ }\specificev{\loc}}$
        \item $\storeagreetms[\delta_{\text{MS}}]{\tmsmonitor}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;m),\Delta_2}}$
      \end{goals}
      All goals follow easy.

    \item[$\src{e}=\src{x[n]\leftarrow\valueexpr}$:]
      If
      \begin{passumptions}{H}
        \item $\typechecks{}{\src{\cfstate};\sandboxtag;\src{H};\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;m),\Delta_2}\triangleright\src{x[n]}}{\type}$
        \item $\storeagreetms{\tmsmonitor}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;m),\Delta_2}}$
        \item $\src{H'}=\src{H}\left(\src{\loc+n}\mapsto\src{\valueexpr}\right)$
      \end{passumptions}
      Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
        \item $\traceagree{\specificev{Use\ \loc\ n}}{\absevent}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;m),\Delta_2}}$
      \end{goals}
      Apply \Thmref{lem:tms:store:split} on \Cref{asm:basetmsmonitor:storeagree}:
      \begin{passumptions}{F}
        \item $\storeagreetms{\tmsmonitor[_{1}]}{\src{\Delta_{1}}}$
        \item\label[ass]{asm:basetmsmonitor:storeagree:unfolded} $\storeagreetms{\{\specificev{\loc}\}\cup\emptyset}{\src{x\mapsto(\loc;\sandboxtag;\poison;m),\hole{\cdot}}}$
        \item $\storeagreetms{\tmsmonitor[_{2}]}{\src{\Delta_{2}}}$
        \item $\tmsmonitor=\tmsmonitor_{1}\cup\{\specificev{\loc}\}\cup\tmsmonitor_{2}$
      \end{passumptions}
      Invert \Cref{asm:basetmsmonitor:storeagree:unfolded} to conclude $\delta_{\text{MS}}(\src{\loc})=\specificev{\loc}$.
      Choose $\absevent=\bm{Use\ }\specificev{\loc}$, $\delta'_{\text{MS}}=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.
      The goals become:
      \begin{goals}
        \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}$
        \item $\traceagree[\delta_{\text{MS}}']{\specificev{Use\ \loc\ n}}{\bm{Use\ }\specificev{\loc}}$
        \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\bm{Use\ }\specificev{\loc}}$
        \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor}{\src{\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;m),\Delta_2}}$
      \end{goals}
      All goals follow easy.
  \end{description}
\end{proof}

\begin{lemma}[Ctx \gls{tms} via Monitor]\label{lem:ctxsteptmsmonitor}
  If
  \begin{assumptions}
    \item\label[ass]{asm:ctxtmsmonitor:typechecks} $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item\label[ass]{asm:ctxtmsmonitor:ctxstep} $\execs[]{\configs}{e}{\configs'}{e'}{\event}$
    \item\label[ass]{asm:ctxtmsmonitor:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists \absevent\ \delta_{\text{MS}}'\ \tmsmonitor['],$
  \begin{goals}
    \item $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
    \item $\tmstraceagree{\tospecificevs[_{\delta_{\text{MS}}'}]{\event}}{\absevent}$
    \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
    \item $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{incompleteproof}
% Induction on \Cref{asm:ctxtmsmonitor:ctxstep}.
% \begin{passumptions}{H}
%   \item $\src{\Omega}\not=\src{\lightning}$
%   \item $\src{e_0}=\src{K}[\src{e}]$
%   \item $\src{e_0'}=\src{K}[\src{e'}]$
%   \item\label[ass]{asm:ctxtmsmonitor:step} $\exprevals{\Omega}{e_0}{\Omega'}{e_0'}{a}$
% \end{passumptions}

% Use \Cref{asm:ctxtmsmonitor:step} and \Cref{asm:ctxtmsmonitor:typechecks,asm:ctxtmsmonitor:storeagree} for \Thmref{lem:basetmsmonitor}:
% \begin{passumptions}{F}
%   \item $\delta_{\text{tms}}\subseteq\delta_{\text{tms}}'$
%   \item $\tmstraceagree[\delta']{\tospecificevs{\event}}{\absevent}$
%   \item $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}$
%   \item $\storeagreetms[\delta']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
% \end{passumptions}
% These premises solve our goal immediately.
\end{incompleteproof}

\begin{lemma}[Steps \gls{tms} via Monitor]\label{lem:generaltms:monitor}
  If
  \begin{assumptions}
    \item\label[ass]{asm:stepstmsmonitor:typing} $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
    \item\label[ass]{asm:stepstmsmonitor:exec} $\execs{\configs}{e}{\configs'}{e'}{\trace}$
    \item\label[ass]{asm:stepstmsmonitor:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{assumptions}
  Then $\exists \abstrace\ \delta_{\text{MS}}'\ \tmsmonitor['],$
  \begin{goals}
    \item\label[goal]{goal:stepstmsmonitor:delta} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
    \item\label[goal]{goal:stepstmsmonitor:traceagree} $\tmstraceagree[^{*}]{\tospecificevs[_{\delta_{\text{MS}}'}]{\trace}}{\abstrace}$
    \item\label[goal]{goal:stepstmsmonitor:monitorstep} $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\abstrace}$
    \item\label[goal]{goal:stepstmsmonitor:storeagree} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
  \end{goals}.
\end{lemma}
\begin{proof}
  Induction on \Cref{asm:stepstmsmonitor:exec}.
  \begin{description}
    \item[$\src{\configs'}=\configs$, $\src{e'}=\src{e}$, and $\src{\trace}=\src{\hole{\cdot}}$:]
          This case is easy, since nothing did change.
          Instantiate $\abstrace=\hole{\cdot}$, $\delta_{\text{MS}}'=\delta_{\text{MS}}$, and $\tmsmonitor[']=\tmsmonitor$.
          Then, \Cref{goal:stepstmsmonitor:delta,goal:stepstmsmonitor:traceagree,goal:stepstmsmonitor:monitorstep} follow immediately by reflexivity and \Cref{goal:stepstmsmonitor:storeagree} by \Cref{asm:stepstmsmonitor:storeagree}.

    \item[Induction step:]
          The inductive hypothesis is as follows.
          If
          \begin{passumptions}{A}
            \item $\typechecks{}{\src{\Omega_{\IH}}\triangleright e_{\IH}}{\src{\type}}$
            \item $\storeagreetms[\delta^{0}_{\text{MS}}]{\tmsmonitor[_{\IH}]}{\src{\Omega_{\IH}}.\src{\Delta}}$
          \end{passumptions}
          then $\exists \abstrace_{\IH}\ \delta_{\text{MS}}^{\IH}\ \tmsmonitor[_{\IH}'],$
          \begin{passumptions}{\IH}
            \item $\delta_{\text{MS}}^{0}\subseteq\delta_{\text{MS}}^{\IH}$
            \item $\tmstraceagree{\tospecificevs[_{\delta^{\IH}_{\text{MS}}}]{\trace}}{\abstrace_{\IH}}$
            \item $\monitorcheck{\tmsmonitor_{\IH}}{\tmsmonitor[_{\IH}']}{\abstrace_{\IH}}$
            \item $\storeagreetms[\delta^{\IH}_{\text{MS}}]{\tmsmonitor[_{\IH}']}{\src{\Omega'}.\src{\Delta}}$
          \end{passumptions}
          Note that above, anything not bound by $\exists$ is universally quantified, besides $\src{\type}$ and $\src{\Omega'}$.
          While our remaining context (excluding the inductive hypothesis) is:
          If
          \begin{passumptions}{H}
            \item\label[ass]{asm:stepstmsmonitor:case0:step} $\execs[]{\configs}{e}{\configs_{0}}{e_{0}}{\event[_0]}$
            \item\label[ass]{asm:stepstmsmonitor:case0:steps} $\execs{\configs_{0}}{e_{0}}{\configs'}{e'}{\trace}$
            \item\label[ass]{asm:stepstmsmonitor:case0:checks} $\typechecks{}{\src{\Omega}\triangleright e}{\src{\type}}$
            \item\label[ass]{asm:stepstmsmonitor:case0:storeagree} $\storeagreetms{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
          \end{passumptions}
          Then $\exists \abstrace\ \delta_{\text{MS}}'\ \tmsmonitor['],$
          \begin{goals}
            \item\label[goal]{goal:stepstmsmonitor:final:delta} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}'$
            \item\label[goal]{goal:stepstmsmonitor:final:traceagree} $\tmstraceagree{\tospecificevs[_{\delta_{\text{MS}}'}]{\event[_{0}]\cdot\trace}}{\abstrace}$
            \item\label[goal]{goal:stepstmsmonitor:final:monitorstep} $\monitorcheck{\tmsmonitor}{\tmsmonitor[']}{\abstrace}$
            \item\label[goal]{goal:stepstmsmonitor:final:storeagree} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor[']}{\src{\Omega'}.\src{\Delta}}$
          \end{goals}
          Use \Thmref{lem:ctxsteptmsmonitor} with \Cref{asm:stepstmsmonitor:case0:step,asm:stepstmsmonitor:case0:checks,asm:stepstmsmonitor:case0:storeagree}, obtaining:
          \begin{passumptions}{F}
            \item\label[ass]{asm:stepstmsmonitor:deltasubset0} $\delta_{\text{MS}}\subseteq\delta_{\text{MS}}^{0}$
            \item\label[ass]{asm:stepstmsmonitor:traceagree0} $\tmstraceagree{\tospecificevs[_{\delta^{0}_{\text{MS}}}]{\event[_{0}]}}{\absevent_{0}}$
            \item\label[ass]{asm:stepstmsmonitor:monitorcheck0} $\monitorcheck[]{\tmsmonitor}{\tmsmonitor[_{0}]}{\absevent_{0}}$
            \item\label[ass]{asm:stepstmsmonitor:case0:storeagree1} $\storeagreetms[\delta^{0}_{\text{MS}}]{\tmsmonitor[_{0}]}{\src{\Omega_{0}}.\src{\Delta}}$
          \end{passumptions}
          Discharge the inductive hypothesis with \Cref{asm:stepstmsmonitor:case0:storeagree1} and the result of applying \Thmref{lem:ctx-preservation} using \Cref{asm:stepstmsmonitor:case0:step,asm:stepstmsmonitor:case0:checks}:
          \begin{passumptions}{G}
            \item\label[ass]{asm:stepstmsmonitor:deltasubset1} $\delta_{\text{MS}}^{0}\subseteq\delta_{\text{MS}}^{\IH}$
            \item\label[ass]{asm:stepstmsmonitor:traceagree1} $\tmstraceagree{\tospecificevs[_{\delta^{\IH}_{\text{MS}}}]{\trace}}{\abstrace_{\IH}}$
            \item\label[ass]{asm:stepstmsmonitor:monitorcheck1} $\monitorcheck{\tmsmonitor_{0}}{\tmsmonitor[^{\IH}]}{\abstrace_{\IH}}$
            \item\label[ass]{asm:stepstmsmonitor:case0:storeagree2} $\storeagreetms[\delta^{\IH}]{\tmsmonitor[_{\IH}]}{\src{\Omega'}.\src{\Delta}}$
          \end{passumptions}

          We solve our goals by instantiating $\abstrace=\absevent\cdot\abstrace_{\IH}$, $\delta_{\text{MS}}'=\delta_{\text{MS}}^{\IH}$, and $\tmsmonitor[']=\tmsmonitor[_{\IH}]$.
          \Cref{goal:stepstmsmonitor:final:delta} follows by transitivity using \Cref{asm:stepstmsmonitor:deltasubset0,asm:stepstmsmonitor:deltasubset1}.

          Similarily for \Cref{goal:stepstmsmonitor:final:traceagree} using \Cref{asm:stepstmsmonitor:traceagree0,asm:stepstmsmonitor:traceagree1} and \Thmref{lem:filter-weaken}.

          \Cref{goal:stepstmsmonitor:final:monitorstep} also by transitivity using \Cref{asm:stepstmsmonitor:monitorcheck0,asm:stepstmsmonitor:monitorcheck1}.

          \Cref{goal:stepstmsmonitor:final:storeagree}, again, by transitivity using \Cref{asm:stepstmsmonitor:case0:storeagree1,asm:stepstmsmonitor:case0:storeagree2}, making use of \Thmref{lem:store-agree-weaken}.
  \end{description}
\end{proof}

\realthm{thm:mmlAs:tmssafe}{1}{$\mmlAs$ is \gls{tms} via Monitor}
\begin{proof}
  Apply \Thmref{lem:tmssafe-tracetms} on the goal, what is left to show is:
  \begin{goals}
    \item $\texttt{TMS}(\theta_{\delta_{ms}}(\src{\trace}))$
  \end{goals}

  Inverting \Cref{asm:mmlatmsviamonitor:run} and omitting the spurious cases, we get
  \begin{passumptions}{H}
    \item\label[ass]{asm:mmlatmsviamonitor:progtyps} $\typechecks{}{prog\ \library_{ctx}\ \library_{comp}}{\commlib,\library}$
    \item\label[ass]{asm:mmlatmsviamonitor:exec} $\execs{\commlib;\library;\comp;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexprnoerr}{\trace}$
  \end{passumptions}
  Invert \Cref{asm:mmlatmsviamonitor:progtyps}:
  \begin{passumptions}{H}
    \setcounter{enumi}{2}
    \item\label[ass]{asm:mmlatmsviamonitor:librarylink} $\src{\library}=\src{\library_{\ctx}\linker\library_{\comp}}$
    \item\label[ass]{asm:mmlatmsviamonitor:libgamma} $\src{\library}\downarrow=\src{\Gamma_{0}}$
    \item\label[ass]{asm:mmlatmsviamonitor:mainindom} $\src{main}\in\src{\Gamma_{0}}$
    \item\label[ass]{asm:mmlatmsviamonitor:libok} $\src{\Gamma_{0}}\vdash\src{\library}\operatorname{ok}$
    \item\label[ass]{asm:mmlatmsviamonitor:mainchecks} $\typechecks{\Gamma_{0}}{call\ main\ 0}{\nat}$
  \end{passumptions}

  Apply \Thmref{lem:static-implies-runtime:toplevel} on \Cref{asm:mmlatmsviamonitor:mainchecks,asm:mmlatmsviamonitor:libgamma}:
  \begin{passumptions}{H}
    \setcounter{enumi}{7}
    \item\label[ass]{asm:mmlatmsviamonitor:rttypes} $\typechecks{}{\commlib;\library;\hole{\cdot};\comp;\hole{\cdot}^{\ctx};\hole{\cdot}^{\comp};\hole{\cdot}\triangleright call\ main\ 0}{\nat}$
  \end{passumptions}

  Note that by definition, we have:
  \begin{passumptions}{H}
    \setcounter{enumi}{8}
    \item\label[ass]{asm:mmlatmsviamonitor:emptystart} $\storeagreetms[\delta_{ms}]{\emptyset}{\src{\hole{\cdot}}}$
  \end{passumptions}
  With \Cref{asm:mmlatmsviamonitor:rttypes,asm:mmlatmsviamonitor:emptystart,asm:mmlatmsviamonitor:run} apply \Thmref{lem:generaltms:monitor}:
  \begin{passumptions}{H}
    \setcounter{enumi}{9}
    \item\label[ass]{asm:mmlatmsviamonitor:m1:deltasubset} $\delta_{\text{ms}}\subseteq\delta_{\text{ms}}'$
    \item\label[ass]{asm:mmlatmsviamonitor:m1:traceagree} $\tmstraceagree[^{*}]{\tospecificevs[_{\delta_{\text{MS}}'}]{\trace}}{\abstrace}$
    \item\label[ass]{asm:mmlatmsviamonitor:m1:monitorstep} $\monitorcheck{\emptyset}{\tmsmonitor}{\abstrace}$
    \item\label[ass]{asm:mmlatmsviamonitor:m1:storeagree} $\storeagreetms[\delta_{\text{MS}}']{\tmsmonitor}{\src{\Omega}.\src{\Delta}}$
  \end{passumptions}

  Immediately, we instantiate our goal with $\delta_{\text{ms}}', \abstrace$, and $\tmsmonitor$.
  Make use of \Thmref{lem:filter-weaken} on the first part, and \Thmref{lem:store-agree-weaken} on the second part, noting that \Cref{asm:mmlatmsviamonitor:m1:deltasubset}.
  Now, \Cref{asm:mmlatmsviamonitor:m1:traceagree,asm:mmlatmsviamonitor:m1:monitorstep} are precisely what is required in \Thmref{def:src:trace:tms}.
\end{proof}

\subsection{Target Language}
\subsubsection{Syntax}

%%%%
%% TARGET

\myfig{
	\vspace{-1em}
  \begin{gather*}
  \begin{aligned}
  \mi{Final\ Result}\ \trg{\finalexprnoerr} \bnfdef&\ \trg{\valueexpr} \mid \trg{x}\hspace{0.5cm}
  \mi{May\ be\ a\ Result}\ \trg{\finalexpr} \bnfdef\ \trg{\finalexprnoerr} \mid \trg{stuck} \\
  \mi{Expressions}~\trg{e} \bnfdef&\ \trg{\finalexpr} \mid \trg{e_{1} \oplus e_{2}} \mid \trg{x[e]} \mid \trg{let\ x = e_{1}\ in\ e_{2}}\mid \trg{x[e_{1}]\leftarrow e_{2}} \\
    & \mid \trg{let\ x=new\ e_{1}\ in\ e_{2}} \mid \trg{delete\ x} \mid \trg{return\ e} \mid \trg{call\ foo\ e} \\
    & \mid \trg{ifz\ e_1\ then\ e_2\ else\ e_3} \mid \trg{abort()} \mid \trg{x\ is\ \poisoned} \\
    & \mid \trg{\langle e_1;e_2\rangle} \mid \trg{\pi_1\ e} \mid \trg{\pi_2\ e}\mid \trg{e\ has\ \type}
  \hspace{0.5cm} \text{where } \trg{\oplus}\in\{\trg{+},\trg{-},\trg{\times},\trg{<}\}\\
  \mi{Functions}~\trg{\asymbol} \bnfdef&\ \trg{let\ foo\ x:=e}\hspace{0.5cm}
  \mi{Types}~\trg{\type} \bnfdef\ \trg{\nat}\mid\trg{\nat\times\nat} \\
  %
  \mi{Values}~\trg{v} \bnfdef&\ \trg{\langle n_{1}, n_{2}\rangle} \mid \trg{n}\in\trg{\nat} \hspace{0.5cm}
  \mi{References}~\trg{\loc}\in\trg{\nat} \\
  \mi{Eval.Ctx.}~\trg{K}\bnfdef &\ \trg{\hole{\cdot}}\mid \trg{K\oplus e}\mid \trg{v\oplus E}\mid \trg{x[K]}\mid \trg{let\ x=K\ in\ e} \\
                 &\mid \trg{x[K]\leftarrow e}\mid \trg{x[v]\leftarrow K}\mid \trg{let\ x=new\ K\ in\ e} \\
                 &\mid \trg{\langle K; e\rangle} \mid \trg{\langle n; K\rangle} \mid \trg{ifz\ K\ then\ e_1\ else\ e_2} \mid \trg{\pi_{1}\ K} \mid \trg{\pi_{2}\ K} \\
                 &\mid \trg{K\ has\ \type}\mid\trg{call\ foo\ K}\mid\trg{return\ K} \\
  %
  \mi{Variables}~\ \trg{x} &\mid \trg{y} \mid \trg{foo} \mid \dots \hspace{0.35cm}
  %
  \mi{Poison}~\ \trg{\poison}~\bnfdef\ \trg{\poisonless} \mid \trg{\poisoned}\\
  \mi{Sandbox\ Tag}~&\ \trg{\sandboxtag}~\bnfdef\ \trg{\ctx} \mid \trg{\comp}\\
  %
  \mi{Store}~\trg{\Delta} \bnfdef&\ \trg{\hole{\cdot}} \mid \trg{x\mapsto(\loc;\sandboxtag;\poison;n)},\Deltat\hspace{0.35cm}
  \mi{Communication}~\trg{\comm} \bnfdef\ \trg{\ctxtocomp} \mid \trg{\comptoctx} \mid \trg{\nocomm}\\
  \mi{Cont.\ Stack}~\trg{\kontstack} \bnfdef&\ \trg{\hole{\cdot}} \mid \trg{(K;foo)},\trg{\kontstack} \hspace{0.5cm}
  \mi{Library}~\trg{\library} \bnfdef\ \trg{\hole{\cdot}} \mid \trg{\asymbol},\trg{\library}\\
  %
  \mi{Relevant}~\trg{\commlib} \bnfdef&\ \trg{\hole{\cdot}} \mid \trg{foo},\trg{\commlib}\hspace{0.35cm}
  \mi{Heaps}~\trg{H} \bnfdef\ \trg{\hole{\cdot}} \mid \trg{H}::\trg{n} \hspace{0.35cm}
  \mi{State}\ \configt \bnfdef\ \trg{\cfstate;\sandboxtag;\memstate} \\
  %
  \mi{Flow\ State}\ \trg{\cfstate} \bnfdef&\ \trg{\commlib;\library;\kontstack}\hspace{0.35cm}
  \mi{Memory\ State}\ \trg{\memstate} \bnfdef \trg{H^{\ctx};H^{\comp};\Delta}\\
  %
  \mi{Programs}\ &\trg{prog\ \library_{ctx}\ \library_{comp}} \\
  \end{aligned}
  \end{gather*}
}{mmlat-syntax}{Syntax of $\mmlAt$}

The target language is very similar to the source language presented in the previous section.
However, it does contain simple, non-nested pairs and dynamic type checks.

\subsubsection{Dynamic Semantics}

\myfig{
  \judgbox{\operatorname{dom}\ \trg{\library}=\trg{foo},\dots,\trg{bar}}{,,Collect function names.''}$\;$\\
  \begin{center}
    \typerule{$\trg{\library}$-dom-$\trg{\hole{\cdot}}$}{
    }{
      \operatorname{dom}\ \trg{\hole{\cdot}} = \trg{\hole{\cdot}}
    }{wt-lib-dom-empty}
    %
    \typerule{$\trg{\library}$-dom-cons}{
      \operatorname{dom}\ \trg{\library} = \trg{D}
    }{
      \operatorname{dom}\ (\trg{let\ foo\ x : \type}_\lambda\trg{:= e})\trg{,\library} = \trg{foo},\trg{D}
    }{wt-lib-dom-cons}
  \end{center}
  \begin{center}
    \judgbox{\trg{\library}\equiv\trg{\library_1}\cup\trg{\library_2}}{,,Merging $\mmlAt$ libraries.''}$\;$\\
    \typerule{lib-merge-empty}{
      \trg{\library}=\trg{\library_1}
    }{
      \trg{\library}\equiv\trg{\library_1}\cup\trg{\hole{\cdot}}
    }{trg-lib-merge-empty}
    %
    \typerule{lib-merge-cons}{
      \trg{\library}\equiv\trg{\library_1}\cup\trg{\library_2}
    }{
      \trg{\asymbol,\library}\equiv\trg{\library_1}\cup\trg{\asymbol,\library_2}
    }{trg-lib-merge-cons}

    \judgbox{\trg{\library_1\linker\library_2}=\trg{\library}}{,,Syntactically linking $\mmlAt$ libraries.''}$\;$\\
    \typerule{syntactic-plugging}{
      \operatorname{dom}\trg{\library_1}\cap\operatorname{dom}\trg{\library_2} = \emptyset &
      \trg{\library}\equiv\trg{\library_1}\cup\trg{\library_2}
    }{
      \trg{\library_1\linker\library_2} = \trg{\library}
    }{trg-plugging}
  \end{center}
}{w-plugging-t}{$\mmlAt$ plugging of libraries and collecting of function names.}


\myfig{
  \begin{gather*}
  \begin{aligned}
  \mi{Base~Events}~\trg{\event_{b}} \bnfdef&\ \trg{Alloc\ \loc\ \valueexpr} \mid \trg{Dealloc\ \loc} \mid \trg{Get\ \loc\ \valueexpr} \mid \trg{Set\ \loc\ \valueexpr\ \valueexpr'} \mid \trg{\lightning}\\
                                                     & \mid \trg{Call\ \comm\ foo\ \valueexpr} \mid \trg{Ret\ \comm\ \valueexpr} \mid \trg{Start} \mid \trg{End\ \valueexpr} \\
  \mi{Events}~\trg{\event} \bnfdef&\ \trg{\emptyevent} \mid \trg{\event_{b};\sandboxtag}
  \end{aligned}
  \end{gather*}
}{tw-events}{Events of $\mmlAt$.}

\myfig{
  \judgbox{\exprevalt{\configt}{e}{\configt'}{e'}{\event}}{,,Expression $\trg{e}$ evaluates under configuration $\configt$ to $\trg{e'}$ and\\new configuration $\trg{\configt'}$, emitting event $\trg{\event}$.''}
  %
  \typerule{$e-\trg{\oplus}$}{
    \trg{n_1}\oplus\trg{n_2}=\trg{n_3}
  }{
    \exprevalt{\configt}{n_1\oplus n_2}{\configt}{n_3}{\emptyevent}
  }{tw-e-oplus}
  %
  \typerule{$e-\trg{get}-\in$}{
    \trg{\memstate}=\trg{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2} &
    \trg{\loc}+\trg{n}\in\text{dom }\trg{H^{\sandboxtag}}
  }{
    \exprevalt{\cfstate;\sandboxtag';\memstate}{x[n]}{\cfstate;\sandboxtag';\memstate}{H^{\sandboxtag}(\loc+n)}{Get\ \loc\ n;\sandboxtag}
  }{tw-e-get-in}
  %
  \typerule{$e-\trg{get}-\notin$}{
    \trg{\memstate}=\trg{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2} &
    \trg{\loc}\notin\text{dom }\trg{H^{\sandboxtag}}
  }{
    \exprevalt{\cfstate;\sandboxtag';\memstate}{x[n]}{\cfstate;\sandboxtag';\memstate}{1729}{Get\ \loc\ n;\sandboxtag}
  }{tw-e-get-notin}
  %
  \typerule{$e-\trg{set}-\ctx$}{
    \trg{\memstate}=\trg{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\ctx;\poison;n),\Delta_2} &
    \trg{H^{\ctx'}} = \trg{H^{\ctx}}(\trg{\loc+n}\mapsto \trg{v}) \\
    \trg{\memstate'}=\trg{H^{\ctx'};H^{\comp};\Delta_1,x\mapsto(\loc;\ctx;\poison;n),\Delta_2}
  }{
    \exprevalt{\cfstate;\ctx;\memstate}{x[n]\leftarrow v}{\cfstate;\ctx;\memstate'}{v}{Set\ \loc\ n\ v;\ctx}
  }{tw-e-set-ctx}
  %
  \typerule{$e-\trg{set}-\comp$}{
    \trg{\memstate}=\trg{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\comp;\poison;n),\Delta_2} &
    \trg{H^{\comp'}} = \trg{H^{\comp}}(\trg{\loc+n}\mapsto \trg{v}) \\
    \trg{\memstate'}=\trg{H^{\ctx};H^{\comp'};\Delta_1,x\mapsto(\loc;\comp;\poison;n),\Delta_2}
  }{
    \exprevalt{\cfstate;\comp;\memstate}{x[n]\leftarrow v}{\cfstate;\comp;\memstate'}{v}{Set\ \loc\ n\ v;\comp}
  }{tw-e-set-comp}
  %
  \typerule{$e-\trg{let}-\trg{\finalexprnoerr}$}{
  }{
    \exprevalt{\Omega}{let\ x=\finalexprnoerr\ in\ e}{\Omega}{e[\finalexprnoerr/x]}{\emptyevent}
  }{tw-e-let-x}
  %
  \typerule{$e-\trg{delete}$}{
    \trg{\memstate}=\trg{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta_2} \\
    \trg{\memstate}=\trg{H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}
  }{
    \exprevalt{\cfstate;\sandboxtag;\memstate}{delete\ x}{\cfstate;\sandboxtag;\memstate'}{0}{Dealloc\ \loc;\sandboxtag}
  }{tw-e-delete}
  %
  \typerule{$e-\trg{new}-ctx$}{
    \fresh{\trg{\Delta}}{\trg{\loc}} &
    \fresh{\trg{\Delta}}{\trg{z}} &
    \trg{H^{\ctx'}} = \trg{H^{\ctx}} \ll \trg{n} \\
    \trg{\memstate} = \trg{H^{\ctx'};H^{\comp};z\mapsto (\loc;\ctx;\poisonless;n),\Delta}
  }{
    \exprevalt{\cfstate;\ctx;H^{\ctx};H^{\comp};\Delta}{let\ x=new\ n\ in\ e}{\cfstate;\ctx;\memstate}{e[z/x]}{Alloc\ \loc\ n;\ctx}
  }{tw-e-let-new-ctx}
  %
  \typerule{$e-\trg{new}-comp$}{
    \fresh{\trg{\Delta}}{\trg{\loc}} &
    \fresh{\trg{\Delta}}{\trg{z}} &
    \trg{H^{\comp'}} = \trg{H^{\comp}} \ll \trg{n} \\
    \trg{\memstate} = \trg{H^{\ctx};H^{\comp'};z\mapsto (\loc;\ctx;\poisonless;n),\Delta}
  }{
    \exprevalt{\cfstate;\comp;H^{\ctx};H^{\comp};\Delta}{let\ x=new\ n\ in\ e}{\cfstate;\comp;\memstate}{e[z/x]}{Alloc\ \loc\ n;\comp}
  }{tw-e-let-new-comp}
  %
  \typerule{$e-\trg{ifz}-$true}{
  }{
    \exprevalt{\configt}{ifz\ 0\ then\ e_1\ else\ e_2}{\configt}{e_1}{\emptyevent}
  }{tw-e-if-true}
  %
  \typerule{$e-\trg{ifz}-$false}{
  }{
    \exprevalt{\configt}{ifz\ S(n)\ then\ e_1\ else\ e_2}{\configt}{e_2}{\emptyevent}
  }{tw-e-if-false}
  %
  \typerule{$e-\trg{abort}$}{
  }{
    \exprevalt{\configt}{abort()}{\configt}{stuck}{\lightning}
  }{tw-e-abort}
  %
}{tw-expr-eval}{Evaluation of $\mmlAt$ expressions.}

\myfig{
  \typerule{$e-\trg{\pi_1}$}{
  }{
    \exprevalt{\configt}{\pi_1\langle n_1;n_2\rangle}{\configt}{n_1}{\emptyevent}
  }{tw-e-proj1}
  %
  \typerule{$e-\trg{\pi_2}$}{
  }{
    \exprevalt{\configt}{\pi_2\langle n_1;n_2\rangle}{\configt}{n_2}{\emptyevent}
  }{tw-e-proj2}
  %
  \typerule{$e-\trg{x\ is\ \poisoned}-$yes}{
    \trg{\memstate}=\trg{H;\Delta} &
    \trg{\Delta}=\trg{\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}
  }{
    \exprevalt{\cfstate;\sandboxtag';\memstate}{x\ is\ \poisoned}{\cfstate;\sandboxtag';\memstate}{0}{\emptyevent}
  }{tw-e-x-is-poisoned-yes}
  %
  \typerule{$e-\trg{x\ is\ \poisoned}-$no}{
    \trg{\memstate}=\trg{H;\Delta} &
    \trg{\Delta}=\trg{\Delta_1,x\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta_2}
  }{
    \exprevalt{\cfstate;\sandboxtag';\memstate}{x\ is\ \poisoned}{\cfstate;\sandboxtag';\memstate}{1}{\emptyevent}
  }{tw-e-x-is-poisoned-yes}
  %
  \typerule{$e-\trg{n\ has\ \nat}$}{
  }{
    \exprevalt{\configt}{n\ has\ \nat}{\configt}{0}{\emptyevent}
  }{tw-e-n-hasnat}
  %
  \typerule{$e-pair-\trg{has\ \nat}$}{
  }{
    \exprevalt{\configt}{\langle n_1,n_2\rangle\ has\ \nat}{\configt}{1}{\emptyevent}
  }{tw-e-pair-hasnat}
  %
  \typerule{$e-\trg{x\ has\ \nat}$}{
  }{
    \exprevalt{\configt}{x\ has\ \nat}{\configt}{1}{\emptyevent}
  }{tw-e-x-hasnat}
  %
  \typerule{$e-\trg{n\ has\ \nat\times\nat}$}{
  }{
    \exprevalt{\configt}{n\ has\ \nat\times\nat}{\configt}{1}{\emptyevent}
  }{tw-e-n-haspair}
  %
  \typerule{$e-pair-\trg{has\ \nat\times\nat}$}{
  }{
    \exprevalt{\configt}{\langle n_1,n_2\rangle\ has\ \nat\times\nat}{\configt}{0}{\emptyevent}
  }{tw-e-pair-haspair}
  %
  \typerule{$e-\trg{x\ has\ \nat\times\nat}$}{
  }{
    \exprevalt{\configt}{x\ has\ \nat\times\nat}{\configt}{1}{\emptyevent}
  }{tw-e-x-haspair}
}{tw-expr-eval-continued}{Evaluation of $\mmlAt$ expressions, continued.}


\myfig{
  \begin{center}
    \judgbox{\exect[]{\configt}{K[e]}{\configt'}{K[e']}{\event}}{,,Given an evaluation context $\trg{K}$ and an expression $\trg{e}$,\\it evaluates under configuration $\configt$ to $\trg{e'}$ and new\\configuration $\trg{\configt'}$ in context $\trg{K}$, emitting event $\trg{\event}$.''}
    %
    \typerule{$e-\text{ctx}$}{
      \exprevalt{\Omega}{e}{\Omega'}{e'}{\event}
    }{
      \exect[]{\Omega}{K[e]}{\Omega'}{K[e']}{\event}
    }{tw-e-ectx}
    %
    \typerule{$e-\text{ctx}-\trg{stuck}$}{
      \exprevalt{\Omega}{e}{\Omega'}{stuck}{\lightning}
    }{
      \exect[]{\Omega}{K[e]}{\Omega'}{stuck}{\lightning}
    }{tw-e-ectx-stuck}
    %
    \typerule{$e-\text{ctx}-\trg{call}-$main}{
      \trg{\Omega}=\trg{\commlib;\library;\hole{\cdot};\comp;\memstate} &
      \trg{\library}=\trg{\library_1,}(\trg{let\ main\ x:\type}_\lambda\trg{:=e})\trg{,\library_2}\\
      \trg{\Omega'}=\trg{\commlib;\library;\ctx;K^{main},\hole{\cdot};\memstate}
    }{
      \exect[]{\Omega}{K[call\ main\ \valueexpr]}{\Omega'}{e[x/\valueexpr]}{Start;\comp}
    }{tw-e-ectx-call-main}
    %
    \typerule{$e-\text{ctx}-\trg{call}-\text{notsame}$}{
      \trg{\Omega}=\trg{\commlib;\library;\kontstack;\sandboxtag;\memstate} &
      \trg{\library}=\trg{\library_1,}(\trg{let\ foo\ x:\type}_\lambda\trg{:=e})\trg{,\library_2} \\
      %\rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{\kontstack},\trg{v}) = \trg{\event},\trg{\comm} &
      \trg{foo}\in_{\trg{\neg\sandboxtag}}\trg{\commlib} &
      \rho\left(\trg{\neg\sandboxtag}\right) = \trg{\comm} &
      \trg{\Omega'}=\trg{\commlib;\library;K^{foo},\kontstack;\neg\sandboxtag;\memstate} \\
    }{
      \exect[]{\Omega}{K[call\ foo\ \valueexpr]}{\Omega'}{e[x/\valueexpr]}{Call\ \comm\ foo\ \valueexpr;\sandboxtag}
    }{tw-e-ectx-call-notsame}
    %
    \typerule{$e-\text{ctx}-\trg{call}-\text{same}$}{
      \trg{\Omega}=\trg{\commlib;\library;\kontstack;\sandboxtag;\memstate} &
      \trg{\library}=\trg{\library_1,}(\trg{let\ foo\ x:\type}_\lambda\trg{:=e})\trg{,\library_2} \\
      %\rho_{\tiny call}(\trg{\commlib},\trg{foo},\trg{\kontstack},\trg{v}) = \trg{\event},\trg{\comm} &
      \trg{foo}\in_{\trg{\sandboxtag}}\trg{\commlib} &
      \trg{\Omega'}=\trg{\commlib;\library;K^{foo},\kontstack;\sandboxtag;\memstate} \\
    }{
      \exect[]{\Omega}{K[call\ foo\ \valueexpr]}{\Omega'}{e[x/\valueexpr]}{Call\ \nocomm\ foo\ \valueexpr;\sandboxtag}
    }{tw-e-ectx-call-same}
    %
    \typerule{$e-\text{ctx}-\trg{return}-$main}{
    }{
      \exec[]{\trg{\commlib;\library;\hole{\cdot}^{main},\hole{\cdot};\ctx;\memstate}}{\trg{K'[return\ \valueexpr]}}{\trg{\commlib;\library;\hole{\cdot};\comp;\memstate}}{\trg{\valueexpr}}{\trg{End\ \valueexpr;\sandboxtag}}
    }{tw-e-ectx-ret-main}
    %
    \typerule{$e-\text{ctx}-\trg{return}-\text{notsame}$}{
      \trg{foo}\in_{\trg{\neg\sandboxtag}}\trg{\commlib} &
      \rho\left(\trg{\neg\sandboxtag}\right) = \trg{\comm;\sandboxtag}
    }{
      \exec[]{\trg{\commlib;\library;K^{foo},\kontstack;\sandboxtag;\memstate}}{\trg{K'[return\ \valueexpr]}}{\trg{\commlib;\library;\kontstack;\neg\sandboxtag;\memstate}}{\trg{K[\valueexpr]}}{\trg{Ret\ \comm\ \valueexpr;\sandboxtag}}
    }{tw-e-ectx-ret-notsame}
    %
    \typerule{$e-\text{ctx}-\trg{return}-\text{same}$}{
      \trg{foo}\in_{\trg{\sandboxtag}}\trg{\commlib}
    }{
      \exec[]{\trg{\commlib;\library;K^{foo},\kontstack;\sandboxtag;\memstate}}{\trg{K'[return\ \valueexpr]}}{\trg{\commlib;\library;\kontstack;\sandboxtag;\memstate}}{\trg{K[\valueexpr]}}{\trg{Ret\ \nocomm\ \valueexpr;\sandboxtag}}
    }{tw-e-ectx-ret-same}
    %
    \judgbox{\rho(\trg{\sandboxtag})=\trg{\comm}}{,,Returns either $\trg{\ctxtocomp}$ or $\trg{\comptoctx}$ depending on $\trg{\sandboxtag}$.''}\\
    %
    \typerule{comm-ctxtocomp}{
    }{
      \rho(\trg{\ctx})=\trg{\ctxtocomp}
    }{tw-comm-ctxtocomp}
    %
    \typerule{comm-comptoctx}{
    }{
      \rho(\trg{\comp})=\trg{\comptoctx}
    }{tw-comm-comptoctx}\\[0.33cm]
    %
    \judgbox{\trg{\neg\sandboxtag}=\trg{\sandboxtag'}}{,,Negation of $\trg{\sandboxtag}$.''}\\
    %
    \typerule{neg-ctx}{
    }{
      \trg{\neg\ctx}=\trg{\comp}
    }{tw-neg-ctx}
    %
    \typerule{neg-comp}{
    }{
      \trg{\neg\comp}=\trg{\ctx}
    }{tw-neg-ctx}
  \end{center}
}{w-t-expr-ctx-eval}{Contextual Evaluation of $\mmlAt$ expressions.}

\myfig{
  \begin{center}
    \judgbox{\exect{\configt}{e}{\configt'}{e'}{\trace}}{,,Expression $\trg{e}$ evaluates under configuration $\configt$ to $\trg{e'}$ and\\new configuration $\trg{\configt'}$, emitting list of events $\trg{\trace}$.''}
    %
    \typerule{$et-\text{refl}$}{
    }{
      \exect{\configt}{\finalexpr}{\configt}{\finalexpr}{\hole{\cdot}}
    }{wt-e-refl}
    \typerule{$et-\text{trans}-$important}{
      \exect[]{\configt}{e}{\configt'}{e'}{\event}&
      \exect{\configt'}{e'}{\configt''}{e''}{\trace}&
      \trg{a}\not=\trg{\emptyevent}
    }{
      \exect{\configt}{e}{\configt''}{e''}{\event \cdot \trace}
    }{wt-e-trans-important}
    \typerule{$et-\text{trans}-$unimportant}{
      \exect[]{\configt}{e}{\configt'}{e'}{\emptyevent}&
      \exect{\configt'}{e'}{\configt''}{e''}{\trace}&
    }{
      \exect{\configt}{e}{\configt''}{e''}{\trace}
    }{wt-e-trans-unimportant}
  \end{center}
}{wt-steps}{Trace prefix generation given a $\mmlAt$ program using the reflexive-transitive closure.}

\myfig{
  \begin{center}
    \judgbox{\wexect{prog\ \library_{ctx}\ \library_{comp}}{\configt}{\finalexprnoerr}{\trace}}{,,Run $\mmlAt$ program $\trg{prog\ \library_{ctx}\ \library_{comp}}$, giving\\dynamic state $\configt$ and emitting trace $\trg{\trace}$.''}
    \typerule{$e-\text{wprog}$}{
      \trg{\library}=\trg{\library_{ctx}\linker\library_{comp}} &
      \trg{main}\notin\trg{\commlib} &
      \trg{\commlib}=\operatorname{dom}\ \trg{\library_{comp}} \\
      \exect{\commlib;\library;\hole{\cdot};\sandboxtag;\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexpr}{\trace}
    }{
      \wexect{prog\ \library_{ctx}\ \library_{comp}}{\configt}{\finalexpr}{\trace}
    }{ws-e-prog}
    %
    \typerule{$e-\text{wprog}-\lightning$}{
      \trg{\library}=\trg{\library_{ctx}\linker\library_{comp}} &
      \trg{main}\notin\trg{\commlib} &
      \trg{\commlib}=\operatorname{dom}\ \trg{\library_{comp}} \\
      \exect{\commlib;\library;\hole{\cdot};\sandboxtag;\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\Omega}{\finalexpr}{\trace\cdot\lightning;\sandboxtag}
    }{
      \wexect{prog\ \library_{ctx}\ \library_{comp}}{\configt}{\finalexpr}{\trace\cdot\lightning;\sandboxtag}
    }{ws-e-prog-crash}
  \end{center}
}{twprog-run}{Running a whole $\mmlAt$ program.}

\subsubsection{Proofs and Auxiliary Lemmas}

\begin{lemma}[Determinism of Step]\label{lem:determ:step}
  If
  \begin{assumptions}
  \item\label[ass]{asm:determ:step:a} $\exprevalt{\Omega}{e}{\Omega'}{v_1}{\event_{1}}$
  \item $\exprevalt{\Omega}{e}{\Omega''}{v_2}{\event_{2}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\trg{v'}=\trg{v''}$
  \item $\trg{\Omega'}=\trg{\Omega''}$
  \item $\trg{\event_{1}}=\trg{\event_{2}}$
  \end{goals}
\end{lemma}
\begin{proof}
  By induction on \Cref{asm:determ:step:a}.
\end{proof}

\begin{lemma}[Determinism of Ctx-Step]\label{lem:determ:ctxstep}
  If
  \begin{assumptions}
  \item\label[ass]{asm:determ:ctxstep:a} $\exect[]{\Omega}{e}{\Omega'}{v_1}{\event}$
  \item $\exect[]{\Omega}{e}{\Omega''}{v_2}{\event}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\trg{v'}=\trg{v''}$
  \item $\trg{\Omega'}=\trg{\Omega''}$
  \end{goals}
\end{lemma}
\begin{proof}
  By induction on \Cref{asm:determ:ctxstep:a} making use of \Thmref{lem:determ:step}.
\end{proof}

\begin{lemma}[Determinism of Steps]\label{lem:determ:steps}
  If
  \begin{assumptions}
  \item\label[ass]{asm:determ:steps:a} $\exect{\Omega}{e}{\Omega'}{v_1}{\trace[_{1}]}$
  \item $\exect{\Omega}{e}{\Omega''}{v_2}{\trace[_{2}]}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\trg{v'}=\trg{v''}$
  \item $\trg{\Omega'}=\trg{\Omega''}$
  \item $\trg{\trace[_{1}]}=\trg{\trace[_{2}]}$
  \end{goals}
\end{lemma}
\begin{proof}
  By induction on \Cref{asm:determ:steps:a} making use of \Thmref{lem:determ:ctxstep}.
\end{proof}

\begin{definition}[Stuck Trace]\label{def:stuck:trgtrace}
  A trace $\trg{\trace}$ is stuck if it ends with $\trg{\lightning}$.
\end{definition}

\begin{lemma}[Non-stuck Trace Generation]\label{lem:nonstuck:traces}
  If
  \begin{assumptions}
  \item $\exect{\Omega}{e}{\Omega'}{\finalexprnoerr}{\trace}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\trg{\trace}$ is not stuck.
  \end{goals}
\end{lemma}
\begin{proof}
  Obvious.
\end{proof}

\subsection{Robust \gls*{tms} Preserving Compiler}

\subsubsection{Compiler}

\myfig{
  \begin{center}
    \begin{gather*}
    \judgbox{\mmlAmmlAtcomp{e}=\trg{e}}{,,Compile $\mmlAs$ expression $\src{e}$ to $\mmlAt$ expression $\trg{e}$.}\\
    \judgbox{\mmlAmmlAtcomp{\left[\valueexpr / x\right]}=\trg{\left[\valueexpr / x\right]}}{,,Compile $\mmlAs$ substitution to $\mmlAt$ substitution.''} \\
    \judgbox{\mmlAmmlAtcomp{\commlib}=\trg{\commlib}}{,,Compile $\mmlAs$ component library to $\mmlAt$ component library.''} \\
    \end{gather*}
    $$
    \begin{array}{rll}
    \mmlAmmlAtcomp{\finalexpr} &\ = & \trg{\finalexpr} \\
    \mmlAmmlAtcomp{call\ foo\ e} &\ = & \trg{call\ }\mmlAmmlAtcomp{foo}\ \mmlAmmlAtcomp{e}\\
    \mmlAmmlAtcomp{return\ e} &\ = & \trg{return\ }\mmlAmmlAtcomp{e}\\
    \mmlAmmlAtcomp{e_1\oplus e_2} &\ = & \mmlAmmlAtcomp{e_1} \trg{\oplus} \mmlAmmlAtcomp{e_2} \\
    \mmlAmmlAtcomp{x[e]} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{e}\trg{]} \\
    \mmlAmmlAtcomp{let\ x= e_1\ in\ e_2} &\ = & \trg{let\ }\mmlAmmlAtcomp{x}\trg{=} \mmlAmmlAtcomp{e_1}\trg{\ in\ }\mmlAmmlAtcomp{e_2} \\
    \mmlAmmlAtcomp{x[e_1]\leftarrow e_2} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{e_1}\trg{]\leftarrow }\mmlAmmlAtcomp{e_2} \\
    \mmlAmmlAtcomp{let\ x=new\ e_1\ in\ e_2} &\ = & \trg{let\ }\mmlAmmlAtcomp{x}\trg{=new\ }\mmlAmmlAtcomp{e_1}\trg{\ in\ }\mmlAmmlAtcomp{e_2} \\
    \mmlAmmlAtcomp{delete\ x} &\ = & \trg{delete\ }\mmlAmmlAtcomp{x} \\
    \mmlAmmlAtcomp{ifz\ e_1\ then\ e_2\ else\ e_3} &\ = & \trg{ifz\ }\mmlAmmlAtcomp{e_1}\\
                                                        &&\trg{then\ }\mmlAmmlAtcomp{e_2} \\
                                                        &&\trg{else\ }\mmlAmmlAtcomp{e_3} \\[0.5cm]
    %
    \mmlAmmlAtcomp{\left[\src{v}/\src{x}\right]}&\ = & \trg{\left[\right.}\mmlAmmlAtcomp{v}\trg{/}\mmlAmmlAtcomp{x}\trg{\left.\right]} \\[0.5cm]
    %
    \mmlAmmlAtcomp{\hole{\cdot}}&\ = & \trg{\hole{\cdot}} \\
    \mmlAmmlAtcomp{foo,\commlib}&\ = & \trg{foo,}\mmlAmmlAtcomp{\commlib} \\
    \end{array}
    $$
  \end{center}
}{tms-pres-compiler}{Compiler from $\mmlAs$ to $\mmlAt$.}
\myfig{
  \begin{center}
    \begin{gather*}
    \judgbox{\mmlAmmlAtcomp{F}=\trg{F}}{,,Compile $\mmlAs$ procedures to $\mmlAt$ procedures.''}
    \end{gather*}
    $$
    \begin{array}{rll}
    %
      \mmlAmmlAtcompN{\src{let\ foo\ x :\nat \to \type_{e} := e}}&\ = & \trg{let\ }\mmlAmmlAtcomp{foo}\ \mmlAmmlAtcomp{x}\trg{ := }\\
                               && \trg{ifz\ }\mmlAmmlAtcomp{x}\trg{\ has\ \nat\ then}\\
                               && \ \ \mmlAmmlAtcomp{e}\\
                               && \trg{else}\\
                               && \ \ \trg{abort()}\\
    \end{array}
    $$
    \begin{gather*}
    \judgbox{\mmlAmmlAtcomp{\library}=\trg{\library}}{,,Compile $\mmlAs$ libraries to $\mmlAt$ libraries.''}
    \end{gather*}
    $$
    \begin{array}{rll}
      \mmlAmmlAtcomp{\hole{\cdot}}&\ = & \trg{\hole{\cdot}} \\
      \mmlAmmlAtcomp{F,\library}&\ = & \mmlAmmlAtcomp{F}\trg{,}\mmlAmmlAtcomp{\library} \\
    \end{array}
    $$
  \end{center}
}{tms-pres-compiler-comp}{Compiler from $\mmlAs$ components to $\mmlAt$ components.}
\myfig{
  \begin{center}
    \begin{gather*}
      \judgbox{\mmlAmmlAtcomp{K}=\trg{K}}{,,Compile $\mmlAs$ evaluation contexts to $\mmlAt$ evaluation contexts.''}
    \end{gather*}
    $$
    \begin{array}{rll}
      \mmlAmmlAtcomp{\hole{\cdot}} &\ = & \trg{\hole{\cdot}} \\
      \mmlAmmlAtcomp{K \oplus e} &\ = & \mmlAmmlAtcomp{K}\trg{\oplus}\mmlAmmlAtcomp{e} \\
      \mmlAmmlAtcomp{\valueexpr \oplus K} &\ = & \mmlAmmlAtcomp{\valueexpr}\trg{\oplus}\mmlAmmlAtcomp{K} \\
      \mmlAmmlAtcomp{x[K]} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{K}\trg{]} \\
      \mmlAmmlAtcomp{let\ x\ = K\ in\ e} &\ = & \trg{let\ }\mmlAmmlAtcomp{x}\trg{\ = }\mmlAmmlAtcomp{K}\trg{\ in\ }\mmlAmmlAtcomp{e} \\
      \mmlAmmlAtcomp{x[K] \leftarrow e} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{K}\trg{]\leftarrow} \mmlAmmlAtcomp{e} \\
      \mmlAmmlAtcomp{x[\valueexpr] \leftarrow K} &\ = & \mmlAmmlAtcomp{x}\trg{[}\mmlAmmlAtcomp{\valueexpr}\trg{]\leftarrow }\mmlAmmlAtcomp{K} \\
      \mmlAmmlAtcomp{let\ x\ = new\ K\ in\ e} &\ = & \trg{let\ }\mmlAmmlAtcomp{x}\trg{\ = new\ }\mmlAmmlAtcomp{K}\trg{\ in\ }\mmlAmmlAtcomp{e} \\
      \mmlAmmlAtcomp{ifz\ K\ then\ e_{1}\ else\ e_{2}} &\ = & \trg{ifz\ }\mmlAmmlAtcomp{K}\trg{\ then\ }\\
                               &&\ \ \mmlAmmlAtcomp{e_{1}}\\
                               &&\trg{else\ }\\
                               &&\ \ \mmlAmmlAtcomp{e_{2}} \\
      \mmlAmmlAtcomp{call\ foo\ K} &\ = & \trg{call\ }\mmlAmmlAtcomp{foo}\ \mmlAmmlAtcomp{K}\\
      \mmlAmmlAtcomp{return\ K} &\ = & \trg{return\ }\mmlAmmlAtcomp{K}\\
    \end{array}
    $$
  \end{center}
}{tms-pres-compiler-ctx}{Compiling $\mmlAs$ evaluation contexts to $\mmlAt$ evaluation contexts.}
Compiling components requires a wrapper to ensure that target contexts invoke the compiled component with the right runtime terms.
For example, by adding the dynamic type check we prevent contexts from binding $\trg{\langle 42,1729 \rangle}$ to $\trg{x}$, which is never valid for $\mmlAs$ components.

\myfig{
  \begin{center}
    \judgbox{\src{\sandboxtag}=\trg{\sandboxtag}}{,,Equality of sandboxtags between $\mmlAs$ and $\mmlAt$.''}\\
    %
    \typerule{sandboxtag-ctx}{
    }{
      \src{\ctx}=\trg{\ctx}
    }{sandboxtag-eq-ctx}
    %
    \typerule{sandboxtag-comp}{
    }{
      \src{\comp}=\trg{\comp}
    }{sandboxtag-eq-comp}
    \\
    %
    \judgbox{\delta(\src{\loc})=\trg{\loc}}{,,Map from $\mmlAs$ locations $\src{\loc}$ to $\mmlAt$ locations $\trg{\loc}$.''} \\
    \judgbox{\xlangtraceeq{\trace}{\trace}}{,,The $\mmlAs$ trace $\src{\trace}$ describes the same actions as $\mmlAt$ trace $\trg{\trace}$. Any action in\\$\src{X}$ is ignored, these are generated by the backtranslation wrapper.''} \\
    \typerule{empty-trace-eq}{
    }{
      \xlangtraceeq{\hole{\cdot}}{\hole{\cdot}}
    }{empty-trace-eq}
    %
    \typerule{cons-trace-eq}{
      \src{\event_{b}}\notin\src{X} &
      \src{\sandboxtag}=\trg{\sandboxtag} &
      \xlangeventeq{\event_{b}}{\event_{b}} &
      \xlangtraceeq{\trace}{\trace}
    }{
      \xlangtraceeq{\event_{b};\sandboxtag\cdot\trace}{\event_{b};\sandboxtag\cdot\trace}
    }{cons-trace-eq}
    %
    \typerule{ignore-cons-trace-eq}{
      \src{\event_{b}}\in\src{X} &
      \xlangtraceeq{\trace}{\trace}
    }{
      \xlangtraceeq{\event_{b};\sandboxtag\cdot\trace}{\trace}
    }{ignore-cons-trace-eq}
    %
    \judgbox{\xlangeventeq{\event_{b}}{\event_{b}}}{,,The $\mmlAs$ event $\src{\event_b}$ describes the same action as $\mmlAt$ event $\trg{\event_b}$.''} \\
    %
    \typerule{start-event-eq}{
    }{
      \xlangeventeq{Start}{Start}
    }{start-event-eq}
    %
    \typerule{end-event-eq}{
      \src{\interfacevalue} = \mmlAmmlAtbackv{\interfacevalue}
    }{
      \xlangeventeq{End\ \interfacevalue}{End\ \interfacevalue}
    }{end-event-eq}
    %
    \typerule{alloc-event-eq}{
      \mmlAmmlAtcomp{n}=\trg{n} &
      \delta(\src{\loc})=\trg{\loc}
    }{
      \xlangeventeq{Alloc\ \loc\ n}{Alloc\ \loc\ n}
    }{alloc-event-eq}
    %
    \typerule{dealloc-event-eq}{
      \delta(\src{\loc})=\trg{\loc}
    }{
      \xlangeventeq{Dealloc\ \loc}{Dealloc\ \loc}
    }{dealloc-event-eq}
    %
    \typerule{get-event-eq}{
      \mmlAmmlAtcomp{n} = \trg{n} &
      \delta(\src{\loc}) = \trg{\loc}
    }{
      \xlangeventeq{Get\ \loc\ n}{Get\ \loc\ n}
    }{get-event-eq}
    %
    \typerule{set-event-eq}{
      \mmlAmmlAtcomp{n} = \trg{n} &
      \delta(\src{\loc}) = \trg{\loc}
    }{
      \xlangeventeq{Set\ \loc\ n}{Set\ \loc\ n}
    }{set-event-eq}
    %
    \typerule{call-event-eq}{
      \mmlAmmlAtcomp{n} = \trg{n} &
      \mmlAmmlAtcomp{foo} = \trg{foo} &
      \src{\comm} = \trg{\comm}
    }{
      \xlangeventeq{Call\ \comm\ foo\ n}{Call\ \comm\ foo\ n}
    }{call-event-eq}
    %
    \typerule{ret-event-eq}{
      \mmlAmmlAtcomp{n} = \trg{n} &
      \src{\comm} = \trg{\comm}
    }{
      \xlangeventeq{Ret\ \comm\ n}{Ret\ \comm\ n}
    }{ret-event-eq}
    %
    \typerule{$\src{\emptyevent}$-event-eq}{
    }{
      \xlangeventeq{\emptyevent}{\emptyevent}
    }{emptyevent-event-eq}
    $\;$\\
    %
    \judgbox{\src{\comm} = \trg{\comm}}{,,Communications are equal.''} \\
    %
    \typerule{$\src{\ctxtocomp}=\trg{\ctxtocomp}$}{
    }{
      \src{\ctxtocomp}=\trg{\ctxtocomp}
    }{sctxtocomp-eq-tctxtocomp}
    %
    \typerule{$\src{\comptoctx}=\trg{\comptoctx}$}{
    }{
      \src{\comptoctx}=\trg{\comptoctx}
    }{scomptoctx-eq-tcomptoctx}
    %
    \typerule{$\src{\nocomm}=\trg{\nocomm}$}{
    }{
      \src{\nocomm}=\trg{\nocomm}
    }{snocomm-eq-tnocomm}
  \end{center}
}{tms-pres-trace-relation}{Trace Relation from $\mmlAs$ to $\mmlAt$.}

\myfig{
  \begin{center}
    \judgbox{\delta(\src{\loc})=\trg{\loc}}{,,The $\mmlAs$ memory location $\src{\loc}$ corresponds to\\the $\mmlAt$ memory location $\trg{\loc}$.''} \\
    \judgbox{\xlangstateeq{\Omega}{\Omega}}{,,The $\mmlAs$ state $\configs$ agrees with $\mmlAt$ state $\configt$. $\src{L}$ contains locations introduced\\by the backtranslation wrapper, which are subsequently ignored.''} \\
    %
    \typerule{state-eq}{
      \src{\Omega}=\src{\cfstate;\sandboxtag;\memstate} &
      \trg{\Omega}=\trg{\cfstate;\sandboxtag;\memstate} &
      \src{\sandboxtag} = \trg{\sandboxtag} \\
      \xlangstateeq[]{\cfstate}{\cfstate} &
      \xlangstateeq{\memstate}{\memstate}
    }{
      \xlangstateeq{\Omega}{\Omega}
    }{state-eq}
    %
    \judgbox{\xlangstateeq{\memstate}{\memstate}}{,,The $\mmlAs$ memory-state $\src{\memstate}$ agrees with $\mmlAt$ one $\trg{\memstate}$. $\src{L}$ contains locations\\introduced by the backtranslation wrapper.''}\\
    %
    \typerule{empty-memstate-eq}{
    }{
      \xlangstateeq{\hole{\cdot};\hole{\cdot};\hole{\cdot}}{\hole{\cdot};\hole{\cdot};\hole{\cdot}}
    }{empty-memstate-eq}
    %
    \typerule{comp-cons-memstate-eq}{
      \src{\loc}\not\in\src{L} &
      \src{n}=\trg{n} &
      \src{\poison}=\trg{\poison} &
      \delta\left(\src{\loc}\right)=\trg{\loc} \\
      \src{\loc},\src{n}\vdash_{\delta}\src{H^{\comp}}\approx\trg{H^{\comp}} &
      \xlangstateeq{H^{\ctx};H^{\comp};\Delta}{H^{\ctx};H^{\comp};\Delta_{1},\Delta_{2}}
    }{
      \xlangstateeq{H^{\ctx};H^{\comp};x\mapsto(\loc;\comp;\poison;n),\Delta}{H^{\ctx};H^{\comp};\Delta_{1},x\mapsto(\loc;\comp;\poison;n),\Delta_{2}}
    }{comp-cons-memstate-eq}
    %
    \typerule{ctx-cons-memstate-eq}{
      \src{\loc}\not\in\src{L} &
      \xlangstateeq{H^{\ctx};H^{\comp};\Delta}{H^{\ctx};H^{\comp};\Delta}
    }{
      \xlangstateeq{H^{\ctx};H^{\comp};x\mapsto(\loc;\ctx;\poison;n),\Delta}{H^{\ctx};H^{\comp};\Delta}
    }{ctx-cons-memstate-eq}
    %
    \typerule{whatever-cons-memstate-eq}{
      \src{\loc}\in\src{L} &
      \xlangstateeq{H^{\ctx};H^{\comp};\Delta}{H^{\ctx};H^{\comp};\Delta}
    }{
      \xlangstateeq{H^{\ctx};H^{\comp};x\mapsto(\loc;\sandboxtag;\poison;n),\Delta}{H^{\ctx};H^{\comp};\Delta}
    }{ctx-cons-memstate-eq}
    %
    %
    \judgbox{\src{\loc},\src{n}\vdash_{\delta}\src{H^{\comp}}\approx\trg{H^{\comp}}}{,,The heaps $\src{H^{\ctx}}$ and $\trg{H^{\ctx}}$ are related at $\src{\loc}$ for\\$\src{n}$ memory cells.''}
    %
    \typerule{heap-related}{
      \mmlAmmlAtcomp{n}=\trg{n} &
      \delta(\src{\loc}) = \trg{\loc} \\
      \forall \src{0}\le\src{m}<\src{n},\ \trg{0}\le\trg{m}<\trg{n},\src{H^{\comp}}\left(\src{\loc} + \src{m}\right)=\trg{H^{\comp}}\left(\trg{\loc} + \trg{m}\right)
    }{
      \src{\loc},\src{n}\vdash_{\delta}\src{H^{\comp}}\approx\trg{H^{\comp}}
    }{heap-related}
    %
    \judgbox{\xlangstateeq[]{\cfstate}{\cfstate}}{,,The $\mmlAs$ control-flow-state $\src{\cfstate}$ agrees with $\mmlAt$ one $\trg{\cfstate}$.''} \\
    %
    \typerule{cfstate-eq}{
      \src{\cfstate}=\src{\commlib;\library;\kontstack} &
      \trg{\cfstate}=\trg{\commlib;\library;\kontstack} \\
      \xlangstateeq[]{\library}{\library} &
      \xlangstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangstateeq[]{\cfstate}{\cfstate}
    }{cfstate-eq}$\;$\\
    %
    %
    \judgbox{\src{\poison}=\trg{\poison}}{,,$\mmlAs$ poison equals $\mmlAt$ one $\trg{\poison}$.''} \\
    %
    \typerule{$\poisoned$-equal}{
    }{
      \src{\poisoned}=\trg{\poisoned}
    }{poisoned-equal}
    %
    \typerule{$\poisonless$-equal}{
    }{
      \src{\poisonless}=\trg{\poisonless}
    }{poisonless-equal}
  \end{center}
}{tms-pres-state-relations}{State Relation from $\mmlAs$ to $\mmlAt$. This is meant to relate the states whenever we are ,,inside'' a component.}

\myfig{
  \begin{center}
    %
    \judgbox{\xlangstateeq[]{\library}{\library}}{,,The procedures of $\mmlAs$ agree with $\mmlAt$ ones.''} \\
    %
    \typerule{empty-commlib-lib-eq}{
    }{
      \xlangstateeq[]{\hole{\cdot}}{\library}
    }{empty-commlib-eq}
    %
    \typerule{cons-commlib-eq}{
      \mmlAmmlAtcomp{let\ foo\ x:\type_{\color{black}\lambda} := e} = \trg{let\ foo\ x := e} &
      \xlangstateeq[]{\library}{\library_1,\library_2}
    }{
      \xlangstateeq[]{(let\ foo\ x:\type_{\color{black}\lambda} := e),\library}{\library_1,(let\ foo\ x := e),\library_2}
    }{cons-commlib-eq}
    %
    %
    \judgbox{\xlangstateeq[]{\kontstack}{\kontstack}}{,,The stack of $\mmlAs$ continuations $\src{\kontstack}$ agrees with $\mmlAt$ one $\trg{\kontstack}$.''} \\
    %
    \typerule{empty-kontstack-eq}{
    }{
      \xlangstateeq[]{\hole{\cdot}}{\hole{\cdot}}
    }{empty-kontstack-eq}
    %
    \typerule{cons-kontstack-eq}{
      \src{\comm}=\trg{\comm} &
      \src{foo}=\trg{foo} &
      \xlangstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangstateeq[]{(K;foo),\kontstack}{(K;foo),\kontstack}
    }{cons-kontstack-eq}
  \end{center}
}{tms-pres-memstate-relations}{Memory-State Relations from $\mmlAs$ to $\mmlAt$.}

\myfig{
  \begin{center}
    \judgbox{\delta(\src{\loc})=\trg{\loc}}{,,The $\mmlAs$ memory location $\src{\loc}$ corresponds to\\the $\mmlAt$ memory location $\trg{\loc}$.''} \\
    \judgbox{\xlangbackstateeq{\Omega}{\Omega}}{,,The $\mmlAs$ state $\configs$ agrees with $\mmlAt$ state $\configt$. $\src{L}$ contains locations introduced\\by the backtranslation wrapper, which are subsequently ignored.''} \\
    %
    \typerule{state-qe}{
      \src{\Omega}=\src{\cfstate;\sandboxtag;\memstate} &
      \trg{\Omega}=\trg{\cfstate;\sandboxtag;\memstate} \\
      \xlangbackstateeq[]{\cfstate}{\cfstate} &
      \xlangbackstateeq{\memstate}{\memstate}
    }{
      \xlangbackstateeq{\Omega}{\Omega}
    }{state-qe}
    %
    \judgbox{\xlangbackstateeq{\memstate}{\memstate}}{,,The $\mmlAs$ memory-state $\src{\memstate}$ agrees with $\mmlAt$ one $\trg{\memstate}$. $\src{L}$ contains locations\\introduced by the backtranslation wrapper.''}\\
    %
    \typerule{memstate-qe}{
      \xlangstateeq{\memstate}{\memstate}
    }{
      \xlangbackstateeq{\memstate}{\memstate}
    }{memstate-qe}$\;$\\
    %
    %
    \judgbox{\xlangbackstateeq[]{\cfstate}{\cfstate}}{,,The $\mmlAs$ control-flow-state $\src{\cfstate}$ agrees with $\mmlAt$ one $\trg{\cfstate}$.''} \\
    %
    \typerule{cfstate-qe}{
      \src{\cfstate}=\src{\commlib;\library;\kontstack} &
      \trg{\cfstate}=\trg{\commlib;\library;\kontstack} \\
      \xlangstateeq[]{\library}{\library} &
      \xlangbackstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangbackstateeq[]{\cfstate}{\cfstate}
    }{cfstate-qe}
    %
    \judgbox{\xlangbackstateeq[]{\kontstack}{\kontstack}}{,,The stack of $\mmlAs$ continuations $\src{\kontstack}$ agrees with $\mmlAt$ one $\trg{\kontstack}$.\\Target state may have internal calls.}\\
    %
    \typerule{empty-kontstack-qe}{
    }{
      \xlangbackstateeq[]{\hole{\cdot}}{\hole{\cdot}}
    }{empty-kontstack-qe}
    %
    \typerule{cons-ctx-kontstack-qe}{
      \xlangbackstateeq[]{\kontstack}{\kontstack}
    }{
      \xlangbackstateeq[]{\kontstack',(K;foo),\kontstack}{(K;foo),\kontstack}
    }{cons-ctx-kontstack-qe}
    %
  \end{center}
}{tms-pres-state-relations}{State Relation from $\mmlAt$ to $\mmlAs$. This is meant to relate the states whenever we are ,,inside'' a context.}

\begin{lemma}[Trace Agreement with Filter]\label{lem:traceagreement:with:filter}
  If
  \begin{assumptions}
    \item $\xlangtraceeq{\trace}{\trace}$
  \end{assumptions}
  Then $\exists \delta_{MS}$
  \begin{goals}
    \item $\tospecificevs[_{\delta_{MS}}]{\trace}=\tospecificevt[_{\delta\circ\delta_{MS}}]{\trace}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
\end{incompleteproof}

\begin{lemma}[Compiler Injective]\label{lem:injective:comp}
  If
  \begin{assumptions}
    \item $\mmlAmmlAtcomp{e}=\trg{e}$
    \item $\mmlAmmlAtcomp{e}=\trg{e'}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\trg{e}=\trg{e'}$
  \end{goals}
\end{lemma}
\begin{proof}
  Simple induction on $\src{e}$.
\end{proof}

\begin{lemma}[Step Forward Simulation]\label{lem:step:forwardsim}
  If
  \begin{assumptions}
    \item\label[ass]{asm:step:forwardsim:srcstep} $\exprevals{\Omega}{e}{\Omega'}{e'}{\event}$
    \item $\xlangstateeq{\Omega}{\Omega}$
    \item\label[ass]{asm:step:forwardsim:srccheck} $\typechecks{}{\Omega\triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
  \begin{goals}
    \item $\delta\subseteq\delta'$
    \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e'}}{\trg{\event}}$
    \item $\xlangeventeq{\event}{\event}$
    \item $\xlangstateeq{\Omega'}{\Omega'}$
  \end{goals}
\end{lemma}
\begin{proof}
  We proceed by induction on \Cref{asm:step:forwardsim:srcstep}.
  \begin{description}
    \item \textbf{Case $\exprevals{\Omega}{n_1+n_2}{\Omega}{n_3}{\varepsilon}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case1:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \item $\typechecks{}{\Omega\triangleright n_1+n_2}{\nat}$
      \item\label[ass]{asm:step:forwardsim:case1:additioneq} $n_3=n_1+n_2$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{n_1+n_2}}{\trg{\Omega'}}{\mmlAmmlAtcomp{n_3}}{\trg{\event}}$
        \item $\xlangeventeq{\varepsilon}{\event}$
        \item $\xlangstateeq{\Omega}{\Omega'}$
      \end{goals}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\Omega}$, and $\trg{\event}=\trg{\varepsilon}$, so that what is left to prove is:
      \begin{goals}
        \item\label[goal]{goal:step:forwardsim:case1:deltasubset} $\delta\subseteq\delta$
        \item\label[goal]{goal:step:forwardsim:case1:eval} $\expreval{\trg{\Omega}}{\trg{n_1+n_2}}{\trg{\Omega}}{\trg{n_3}}{\trg{\varepsilon}}$
        \item\label[goal]{goal:step:forwardsim:case1:eventeq} $\xlangeventeq{\varepsilon}{\varepsilon}$
        \item\label[goal]{goal:step:forwardsim:case1:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \end{goals}

      \Cref{goal:step:forwardsim:case1:deltasubset} follows immediately from reflexivity of the subset relation.

      \Cref{goal:step:forwardsim:case1:eval} follows using \Cref{tr:tw-e-oplus} and \Cref{asm:step:forwardsim:case1:additioneq}.

      \Cref{goal:step:forwardsim:case1:eventeq} follows using \Cref{tr:emptyevent-event-eq}.

      \Cref{goal:step:forwardsim:case1:stateeq} follows using \Cref{asm:step:forwardsim:case1:stateeq}.

    \item \textbf{Case }$\exprevals{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2}{delete\ x}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}{0}{Dealloc\ \loc;\sandboxtag'}$\textbf{:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case2:stateeq} $\xlangstateeq{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2}{\trg{\Omega}}$
      \item $\typechecks{}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2\triangleright delete\ x}{\nat}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{delete\ x}}{\trg{\Omega'}}{\mmlAmmlAtcomp{0}}{\trg{\event}}$
        \item $\xlangeventeq{Dealloc\ \loc}{\event}$
        \item $\xlangstateeq{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}{\Omega'}$
      \end{goals}

      First note that $\trg{\Omega}=\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2}$, because of \Cref{asm:step:forwardsim:case2:stateeq}.

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}$, and $\trg{\event}=\trg{Dealloc\ \loc;\sandboxtag'}$, so that what is left to prove is:
      \begin{goals}
      \item\label[goal]{goal:step:forwardsim:case2:deltasubset} $\delta\subseteq\delta$
      \item\label[goal]{goal:step:forwardsim:case2:eval} $\expreval{\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n),\Delta_2}}{\trg{delete\ x}}{\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}}{\trg{0}}{\trg{Dealloc\ \loc}}$
      \item\label[goal]{goal:step:forwardsim:case2:eventeq} $\xlangeventeq{Dealloc\ \loc;\sandboxtag'}{Dealloc\ \loc;\sandboxtag'}$
      \item\label[goal]{goal:step:forwardsim:case2:stateeq} $\xlangstateeq{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poisoned;n),\Delta_2}$
      \end{goals}

      \Cref{goal:step:forwardsim:case2:deltasubset} follows immediately from reflexivity of the subset relation.

      \Cref{goal:step:forwardsim:case2:eval} follows using \Cref{tr:tw-e-delete}.

      For \Cref{goal:step:forwardsim:case2:eventeq}, apply \Cref{tr:dealloc-event-eq}, what is left to show is $\delta(\src{\loc})=\trg{\loc}$.

      Similarily for \Cref{goal:step:forwardsim:case2:stateeq}, apply \Cref{tr:state-eq} and \Cref{tr:comp-cons-memstate-eq} or \Cref{tr:ctx-cons-memstate-eq} (depending on the shape of $\src{\sandboxtag}$) ,,suitably'' so that what is left to show is
      $\xlangstateeq{\cfstate}{\cfstate}$, $\xlangstateeq{H}{H}$, $\xlangstateeq{\Delta_1}{\Delta_1}$, $\xlangstateeq{\Delta_2}{\Delta_2}$, $\mmlAmmlAtcomp{x}=\trg{x}$, and, like in the previous case, $\delta(\src{\loc})=\trg{\loc}$.

      $\mmlAmmlAtcomp{x}=\trg{x}$ follows by definition of the compiler, anything else follows immediately by inverting \Cref{asm:step:forwardsim:case2:stateeq} ,,suitably''.

    \item \textbf{Case }$\exprevals{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{x[n]}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp}\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{v}{Get\ \loc\ n;\sandboxtag'}$\textbf{:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case3:stateeq} $\xlangstateeq{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{\Omega}$
      \item $\typechecks{}{\cfstate;\sandboxtag;H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2\triangleright x[n]}{\nat}$
      \item\label[ass]{asm:step:forwardsim:case3:dom1} $\src{\loc}\in\operatorname{dom} \src{H^{\sandboxtag'}}\implies\src{v}=\src{H^{\sandboxtag'}}(\src{\loc+n})$
      \item\label[ass]{asm:step:forwardsim:case3:dom2} $\src{\loc}\not\in\operatorname{dom} \src{H^{\sandboxtag'}}\implies\src{v}=\src{1729}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{x[n]}}{\trg{\Omega'}}{\mmlAmmlAtcomp{v}}{\trg{\event}}$
        \item $\xlangeventeq{Get\ \loc\ n;\sandboxtag'}{\event}$
        \item $\xlangstateeq{\cfstate;\sandboxtag;H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{\Omega'}$
      \end{goals}
      First note that $\trg{\Omega}=\trg{\cfstate;\sandboxtag;H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}$, because of \Cref{asm:step:forwardsim:case3:stateeq}.

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\cfstate;\sandboxtag;H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}$, and $\trg{\event}=\trg{Get\ \loc\ n;\sandboxtag'}$, so that what is left to prove is:
      \begin{goals}
      \item\label[goal]{goal:step:forwardsim:case3:deltasubset} $\delta\subseteq\delta$
        \setcounter{enumi}{2}
      \item\label[goal]{goal:step:forwardsim:case3:eventeq} $\xlangeventeq{Get\ \loc\ n;\sandboxtag'}{Get\ \loc\ n;\sandboxtag'}$
      \item\label[goal]{goal:step:forwardsim:case3:stateeq} $\xlangstateeq{\cfstate;\sandboxtag;H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{\cfstate;\sandboxtag;H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}$
        \setcounter{enumi}{1}
      \item\label[goal]{goal:step:forwardsim:case3:eval} $\expreval{\trg{\cfstate;\sandboxtag;H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}}{\trg{x[n]}}{\trg{\cfstate;\sandboxtag;H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}}{\trg{v}}{\trg{Get\ \loc\ n;\sandboxtag'}}$
      \end{goals}

      \Cref{goal:step:forwardsim:case3:deltasubset} follows immediately from reflexivity of the subset relation.

      For \Cref{goal:step:forwardsim:case3:eventeq}, invert \Cref{asm:step:forwardsim:case3:stateeq} ,,suitably'' to obtain the assumption $\delta(\src{\loc})=\trg{\loc}$. The claim then follows by applying \Cref{tr:get-event-eq}.

      \Cref{goal:step:forwardsim:case3:stateeq} follows immediately from \Cref{asm:step:forwardsim:case3:stateeq}.

      \Cref{goal:step:forwardsim:case3:eval} is a bit technical. First apply \Cref{tr:tw-e-get-in,tr:tw-e-get-notin}, what is left to show is:
      \begin{goals}
        \setcounter{enumi}{4}
        \item $\trg{\loc}\in\operatorname{dom} \trg{H^{\sandboxtag'}}\implies\trg{v}=\trg{H^{\sandboxtag'}}(\trg{\loc+n})$
      \item $\trg{\loc}\not\in\operatorname{dom} \trg{H^{\sandboxtag'}}\implies\trg{v}=\trg{1729}$
      \end{goals}

      Now, note that $\src{\loc}\in\operatorname{dom}\src{H^{\sandboxtag'}}\Leftrightarrow\delta(\src{\loc})=\trg{\loc}\in\operatorname{dom}\trg{H^{\sandboxtag'}}$.
      We continue with a case distinction.
      \begin{description}
        \item \textbf{Case }$\src{\loc}\in\operatorname{dom}\src{H^{\sandboxtag'}}$\textbf{:}

          \Cref{asm:step:forwardsim:case3:dom1} gives $\src{v}=\src{H^{\sandboxtag'}}(\src{\loc+n})$.
          Since $\trg{v}=\mmlAmmlAtcomp{v}$, $\trg{v}=\mmlAmmlAtcomp{H^{\sandboxtag'}(\loc+n)}$.
          Using \Cref{asm:step:forwardsim:case3:stateeq}, $\trg{v}=\trg{H^{\sandboxtag'}(\loc+n)}$, done.

        \item \textbf{Case }$\src{\loc}\not\in\operatorname{dom}\src{H^{\sandboxtag'}}$\textbf{:}

          \Cref{asm:step:forwardsim:case3:dom2} gives $\src{v}=\src{1729}$.
          Since $\trg{v}=\mmlAmmlAtcomp{v}$, $\trg{v}=\mmlAmmlAtcomp{1729}=\trg{1729}$, done.
      \end{description}

    \item \textbf{Case }$\exprevals{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison,n'),\Delta_2}{x[n]\leftarrow v}{\cfstate;\sandboxtag';H^{\ctx'};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{v}{Set\ \loc\ n\ m;\sandboxtag'}$\textbf{:}

      This case is completely analogous to the next case.

    \item \textbf{Case }$\exprevals{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison,n'),\Delta_2}{x[n]\leftarrow v}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{v}{Set\ \loc\ n\ m;\sandboxtag'}$\textbf{:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case4:stateeq} $\xlangstateeq{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{\Omega}$
      \item $\typechecks{}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2\triangleright x[n]}{\nat}$
      \item\label[ass]{asm:step:forwardsim:case4:update} $\src{H'}=\src{H}(\src{\loc+n}\mapsto\src{v})$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{x[n]\leftarrow v}}{\trg{\Omega'}}{\mmlAmmlAtcomp{v}}{\trg{\event}}$
        \item $\xlangeventeq{Set\ \loc\ n;\sandboxtag'}{\event}$
        \item $\xlangstateeq{\cfstate;\sandboxtag';H^{ctx};H^{\comp'};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{\Omega'}$
      \end{goals}
      First note that $\trg{\Omega}=\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}$, because of \Cref{asm:step:forwardsim:case4:stateeq}.

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}$, and $\trg{\event}=\trg{Set\ \loc\ n\ m}$, so that what is left to prove is:
      \begin{goals}
      \item\label[goal]{goal:step:forwardsim:case4:deltasubset} $\delta\subseteq\delta$
      \item\label[goal]{goal:step:forwardsim:case4:eval} $\expreval{\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}}{\trg{x[n]\leftarrow v}}{\trg{\cfstate;\sandboxtag;H^{\ctx};H^{\comp'};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}}{\trg{v}}{\trg{Set\ \loc\ n\ m;\sandboxtag'}}$
      \item\label[goal]{goal:step:forwardsim:case4:eventeq} $\xlangeventeq{Set\ \loc\ n\ m;\sandboxtag'}{Set\ \loc\ n\ m;\sandboxtag'}$
      \item\label[goal]{goal:step:forwardsim:case4:stateeq} $\xlangstateeq{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};\Delta_1,x\mapsto(\loc;\sandboxtag;\poison;n'),\Delta_2}$
      \end{goals}

      \Cref{goal:step:forwardsim:case4:deltasubset} follows immediately from reflexivity of the subset relation.

      For \Cref{goal:step:forwardsim:case4:eval}, apply \Cref{tr:tw-e-set-ctx,tr:tw-e-set-comp} depending on the shape of $\trg{\sandboxtag}$.
      What is left to prove is $\trg{H^{\sandboxtag'}} = \trg{H^{\sandboxtag}}(\trg{\loc+n}\mapsto \trg{v})$.
      This follows by \Cref{asm:step:forwardsim:case4:stateeq}.%\MK{technical lemma: compatibility with update}

      Apply \Cref{tr:set-event-eq} on \Cref{goal:step:forwardsim:case4:eventeq}, what is left to show is $\mmlAmmlAtcomp{n}=\trg{n}$, which is trivial, and $\delta(\src{\loc})=\trg{\loc}$.
      The latter can be obtained by a ,,suitable'' inversion of \Cref{asm:step:forwardsim:case4:stateeq}.

      \Cref{goal:step:forwardsim:case4:stateeq} is assumed in \Cref{asm:step:forwardsim:case4:stateeq}.

    \item \textbf{Case }$\exprevals{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta}{let\ x\ =\ new\ n\ in\ e}{\cfstate;\sandboxtag';H^{\ctx'};H^{\comp};z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}{e[z/x]}{Alloc\ \loc\ n;\sandboxtag}$\textbf{:}
          Similar to the following case.
    \item \textbf{Case }$\exprevals{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta}{let\ x\ =\ new\ n\ in\ e}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}{e[z/x]}{Alloc\ \loc\ n;\sandboxtag}$\textbf{:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case5:stateeq} $\xlangstateeq{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta}{\Omega}$
      \item $\typechecks{}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta\triangleright let\ x\ =\ new\ n\ in\ e}{\nat}$
      \item\label[ass]{asm:step:forwardsim:case5:update} $\src{H^{\sandboxtag'}}=\src{H^{\sandboxtag'}}\ll\src{n}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{let\ x\ =\ new\ n\ in\ e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e[z/x]}}{\trg{\event}}$
        \item $\xlangeventeq{Alloc\ \loc\ n;\sandboxtag'}{\event}$
        \item $\xlangstateeq{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}{\Omega'}$
      \end{goals}
      First note that $\trg{\memstate}=\trg{H^{\ctx};H^{\comp};z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}$, because of \Cref{asm:step:forwardsim:case5:stateeq}.

      Instantiate the goal with $\delta'=\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\},\ \trg{\Omega'}=\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}$, and $\trg{\event}=\trg{Alloc\ \loc\ n;\sandboxtag'}$, so that what is left to prove is:

      \begin{goals}
      \item\label[goal]{goal:step:forwardsim:case5:deltasubset} $\delta\subseteq\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\}$
      \item\label[goal]{goal:step:forwardsim:case5:eval} $\expreval{\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp};\Delta}}{\trg{let\ x\ =\ new\ n\ in\ }\mmlAmmlAtcomp{e}}{\trg{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}}{\mmlAmmlAtcomp{e}\trg{[z/x]}}{\trg{Alloc\ \loc\ n;\sandboxtag'}}$
      \item\label[goal]{goal:step:forwardsim:case5:eventeq} $\xlangeventeq[\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\}]{Alloc\ \loc\ n;\sandboxtag'}{Alloc\ \loc\ n;\sandboxtag'}$
      \item\label[goal]{goal:step:forwardsim:case5:stateeq} $\xlangstateeq[\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\}]{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}{\cfstate;\sandboxtag';H^{\ctx};H^{\comp'};z\mapsto(\loc;\sandboxtag;\poisonless;n),\Delta}$
      \end{goals}

      \Cref{goal:step:forwardsim:case5:deltasubset} follows by rewriting it as $\forall x, x\in\delta\implies x\in\delta\vee x\in\left\{\src{\loc}\mapsto\trg{\loc}\right\}$, then just choose the left side of the disjunction.

      Apply \Cref{tr:tw-e-let-new-ctx,tr:tw-e-let-new-comp} depending on the shape of $\sandboxtag$ on \Cref{goal:step:forwardsim:case5:eval}, what is left to show is $\trg{H^{\sandboxtag}} = \trg{H^{\sandboxtag}} \ll \trg{n}$.
      This follows by \Cref{asm:step:forwardsim:case5:stateeq}.%\MK{technical lemma: compatibility with grow}

      Apply \Cref{tr:set-event-eq} on \Cref{goal:step:forwardsim:case5:eventeq}, what is left to show is $\mmlAmmlAtcomp{n}=\trg{n}$, follows immediately by definition of the compiler, and $(\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\})(\src{\loc})=\trg{\loc}$, which follows by definition.

      Apply \Cref{tr:state-eq,tr:ctx-cons-memstate-eq,tr:comp-cons-memstate-eq} depending on the shape of $\sandboxtag$ on \Cref{goal:step:forwardsim:case5:stateeq}, what is left to show is $\mmlAmmlAtcomp{x}=\trg{x}$, follows immediately by definition of the compiler, and $(\delta\cup\left\{\src{\loc}\mapsto\trg{\loc}\right\})(\src{\loc})=\trg{\loc}$, which follows by definition.

    \item \textbf{Case }$\exprevals{\Omega}{abort()}{\lightning}{stuck}{\lightning;\sandboxtag}$\textbf{:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case6:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \item\label[ass]{asm:step:forwardsim:case6:typechecks} $\typechecks{}{\Omega\triangleright abort()}{\nat}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{abort()}}{\trg{\Omega'}}{\mmlAmmlAtcomp{stuck}}{\trg{\event}}$
        \item $\xlangeventeq{\lightning;\sandboxtag}{\event}$
        \item $\xlangstateeq{\lightning}{\Omega'}$
      \end{goals}

      Inverting \Cref{asm:step:forwardsim:case6:typechecks} yields a contradiction.

    \item \textbf{Case $\exprevals{\Omega}{let\ x=y\ in\ e}{\Omega}{e[y/x]}{\varepsilon}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case7:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \item $\typechecks{}{\Omega\triangleright let\ x\ = y\ in\ e}{\nat}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{let\ x\ = y\ in\ e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e[y/x]}}{\trg{\event}}$
        \item $\xlangeventeq{\varepsilon}{\event}$
        \item $\xlangstateeq{\Omega}{\Omega'}$
      \end{goals}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\Omega}$, and $\trg{\event}=\trg{\varepsilon}$, so that what is left to prove is:

      \begin{goals}
        \item\label[goal]{goal:step:forwardsim:case7:deltasubset} $\delta\subseteq\delta$
        \item\label[goal]{goal:step:forwardsim:case7:eval} $\expreval{\trg{\Omega}}{\trg{let\ x\ = y\ in\ }\mmlAmmlAtcomp{e}}{\trg{\Omega}}{\mmlAmmlAtcomp{e}\trg{[y/x]}}{\trg{\varepsilon}}$
        \item\label[goal]{goal:step:forwardsim:case7:eventeq} $\xlangeventeq{\varepsilon}{\varepsilon}$
        \item\label[goal]{goal:step:forwardsim:case7:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \end{goals}

      \Cref{goal:step:forwardsim:case7:deltasubset} follows by reflexivity of the subset relation.

      \Cref{goal:step:forwardsim:case7:eval} follows by definition of \Cref{tr:tw-e-let-x}.

      \Cref{goal:step:forwardsim:case7:eventeq} follows by definition of \Cref{tr:emptyevent-event-eq}.

      \Cref{goal:step:forwardsim:case7:stateeq} follows by \Cref{asm:step:forwardsim:case7:stateeq}.

    \item \textbf{Case $\exprevals{\Omega}{ifz\ 0\ then\ e_1\ else\ e_2}{\Omega}{e_1}{\varepsilon}$:}

      If
      \begin{passumptions}{H}
      \item\label[ass]{asm:step:forwardsim:case9:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \item $\typechecks{}{\Omega\triangleright ifz\ 0\ then\ e_1\ else\ e_2}{\nat}$
      \end{passumptions}
      Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
      \begin{goals}
        \item $\delta\subseteq\delta'$
        \item $\expreval{\trg{\Omega}}{\mmlAmmlAtcomp{ifz\ 0\ then\ e_1\ else\ e_2}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e_1}}{\trg{\event}}$
        \item $\xlangeventeq{\varepsilon}{\event}$
        \item $\xlangstateeq{\Omega}{\Omega'}$
      \end{goals}

      Instantiate the goal with $\delta'=\delta,\ \trg{\Omega'}=\trg{\Omega}$, and $\trg{\event}=\trg{\varepsilon}$, so that what is left to prove is:

      \begin{goals}
        \item\label[goal]{goal:step:forwardsim:case9:deltasubset} $\delta\subseteq\delta$
        \item\label[goal]{goal:step:forwardsim:case9:eval} $\expreval{\trg{\Omega}}{\trg{ifz\ 0\ then\ }\mmlAmmlAtcomp{e_1}\trg{\ else\ }\mmlAmmlAtcomp{e_2}}{\trg{\Omega}}{\mmlAmmlAtcomp{e_1}}{\trg{\varepsilon}}$
        \item\label[goal]{goal:step:forwardsim:case9:eventeq} $\xlangeventeq{\varepsilon}{\varepsilon}$
        \item\label[goal]{goal:step:forwardsim:case9:stateeq} $\xlangstateeq{\Omega}{\Omega}$
      \end{goals}

      \Cref{goal:step:forwardsim:case9:deltasubset} follows by reflexivity of the subset relation.

      \Cref{goal:step:forwardsim:case9:eval} follows by definition of \Cref{tr:tw-e-if-true}.

      \Cref{goal:step:forwardsim:case9:eventeq} follows by definition of \Cref{tr:emptyevent-event-eq}.

      \Cref{goal:step:forwardsim:case9:stateeq} follows by \Cref{asm:step:forwardsim:case9:stateeq}.

    \item \textbf{Case $\exprevals{\Omega}{ifz\ S(n)\ then\ e_1\ else\ e_2}{\Omega}{e_2}{\varepsilon}$:}

      This case is completely analogous to the previous case, the only difference is the use of \Cref{tr:tw-e-if-false} instead of \Cref{tr:tw-e-if-true}.

  \end{description}
\end{proof}


\begin{lemma}[Ctx Step Forward Simulation]\label{lem:ctxstep:forwardsim}
  If
  \begin{assumptions}
    \item\label[ass]{asm:ctxstep:forwardsim:srcstep} $\execs[]{\Omega}{e}{\Omega'}{e'}{\event}$
    \item\label[ass]{asm:ctxstep:forwardsim:staterel} $\xlangstateeq{\Omega}{\Omega}$
    \item\label[ass]{asm:ctxstep:forwardsim:typechecks} $\typechecks{}{\Omega\triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
  \begin{goals}
    \item $\delta\subseteq\delta'$
    \item $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e'}}{\trg{\event}}$
    \item $\xlangeventeq{\event}{\event}$
    \item $\xlangstateeq{\Omega'}{\Omega'}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
% Induction on \Cref{asm:ctxstep:forwardsim:srcstep}:

% If
% \begin{passumptions}{H}
%   \item\label[ass]{asm:ctxstep:forwardsim:nocrash} $\src{\Omega}\not=\src{\lightning}$
%   \item\label[ass]{asm:ctxstep:forwardsim:simplestep} $\exprevals{\Omega}{e_{0}}{\Omega'}{e_{0}'}{\event}$
% \end{passumptions}
% Then $\exists\delta'\ \trg{\Omega'}\ \trg{\event}$,
% \begin{goals}
%   \item $\delta\subseteq\delta'$
%   \item $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{K[e_{0}]}}{\trg{\Omega'}}{\mmlAmmlAtcomp{K[e_{0}']}}{\trg{\event}}$
%   \item $\xlangeventeq{\event}{\event}$
%   \item $\xlangstateeq{\Omega'}{\Omega'}$
% \end{goals}

% We augment \Cref{asm:ctxstep:forwardsim:typechecks} using \Thmref{lem:ctxtyping:plugged}.
% \begin{passumptions}{H}
%   \setcounter{enumi}{2}
%   \item\label[ass]{asm:ctxstep:forwardsim:e0typechecks} $\typechecks{}{\Omega\triangleright e_{0}}{\nat}$
% \end{passumptions}
% Withg \Cref{asm:ctxstep:forwardsim:simplestep,asm:ctxstep:forwardsim:staterel,asm:ctxstep:forwardsim:e0typechecks} use \Thmref{lem:step:forwardsim} to get witnesses $\delta', \trg{\Omega'},$ and $\trg{\event}$ such that:

% \begin{passumptions}{F}
%   \item\label[ass]{asm:ctxstep:forwardsim:f1} $\delta\subseteq\delta'$
%   \item\label[ass]{asm:ctxstep:forwardsim:trgstep} $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e_{0}'}}{\trg{\event}}$
%   \item\label[ass]{asm:ctxstep:forwardsim:f3} $\xlangeventeq{\event}{\event}$
%   \item\label[ass]{asm:ctxstep:forwardsim:f4} $\xlangstateeq{\Omega'}{\Omega'}$
% \end{passumptions}

% Immediately instantiate our goal with those witnesses and use \Cref{asm:ctxstep:forwardsim:f1,asm:ctxstep:forwardsim:f3,asm:ctxstep:forwardsim:f4}.
% What is left to prove is
% \begin{goals}
%   \setcounter{enumi}{1}
%   \item $\exec[]{\trg{\Omega}}{\trg{K[}\mmlAmmlAtcomp{e_{0}}\trg{]}}{\trg{\Omega'}}{\trg{K[}\mmlAmmlAtcomp{e_{0}'}\trg{]}}{\trg{\event}}$
% \end{goals}
% Use \Cref{tr:tw-e-ectx}, what is left to show is
% \begin{goals}
%   \setcounter{enumi}{4}
%   \item\label[ass]{goal:ctxstep:forwardsim:nocrash} $\trg{\Omega}\not=\trg{\lightning}$
%   \item\label[goal]{goal:ctxstep:forwardsim:trgstep} $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega'}}{\mmlAmmlAtcomp{e_{0}'}}{\trg{\event}}$
% \end{goals}
% \Cref{goal:ctxstep:forwardsim:trgstep} follows immediately by \Cref{asm:ctxstep:forwardsim:trgstep}.
% For \Cref{goal:ctxstep:forwardsim:nocrash}, we can use \Thmref{lem:relatednoncrash} relying on \Cref{asm:ctxstep:forwardsim:staterel,asm:ctxstep:forwardsim:nocrash}.
\end{incompleteproof}

\begin{lemma}[Forward Simulation]\label{lem:forwardsim}
  If
  \begin{assumptions}
    \item\label[ass]{asm:forwardsim:starstep} $\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$
    \item\label[ass]{asm:forwardsim:staterel} $\xlangstateeq{\Omega}{\Omega}$
    \item\label[ass]{asm:forwardsim:typechecks} $\typechecks{}{\Omega\triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists\delta'\ \trg{\Omega'}\ \trg{\trace}$,
  \begin{goals}
    \item $\delta\subseteq\delta'$
    \item $\exec{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace}}$
    \item $\xlangtraceeq[\delta']{\trace}{\trace}$
    \item $\xlangstateeq[\delta']{\Omega'}{\Omega'}$
  \end{goals}
\end{lemma}
\begin{proof}
  Induction on \Cref{asm:forwardsim:starstep}.
  \begin{description}
    \item \textbf{Case }$\execs{\Omega}{\finalexpr}{\Omega}{\finalexpr}{\hole{\cdot}}$\textbf{:}
          Trivial. Witnesses are $\delta, \trg{\Omega}$, and $\trg{\hole{\cdot}}$, goals follow immediately by reflexivity of the respective relation.

    \item \textbf{Cases }$\execs{\Omega}{e}{\Omega}{\finalexpr}{\event\cdot\trace}$ (\Cref{tr:ws-e-trans-important})\textbf{ and }\\$\execs{\Omega}{e}{\Omega}{\finalexpr}{\trace}$ (\Cref{tr:ws-e-trans-unimportant})\textbf{:}
          \begin{passumptions}{H}
            \item\label[ass]{asm:forwardsim:evnoteps} $\src{a}\not=\src{\varepsilon}$ (provided only in the case of \Cref{tr:ws-e-trans-important})
            \item\label[ass]{asm:forwardsim:ctxstep} $\execs[]{\Omega}{e}{\Omega_{0}}{e_0}{\event}$
            \item $\execs{\Omega_{0}}{e_0}{\Omega'}{\finalexpr}{\trace}$
          \end{passumptions}
          With the inductive hypothesis: $\forall\delta_{\forall}\ \trg{\Omega_{\forall}},\exists \delta_{\IH}\ \trg{\Omega_{\IH}}\ \trg{\trace[_{\IH}]},$
          \begin{passumptions}{\IH}
            \item $\delta_{\forall}\subseteq\delta_{\IH}$
            \item $\exec{\trg{\Omega_{\forall}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega_{{\IH}}}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace[_{{\IH}}]}}$
            \item\label[ass]{asm:forwardsim:justraceeq} $\xlangtraceeq[\delta_{\IH}]{\trace}{\trace[_{\IH}]}$
            \item $\xlangstateeq[\delta_{\IH}]{\Omega_{0}}{\Omega_{\IH}}$
          \end{passumptions}

          Now apply \Thmref{lem:ctxstep:forwardsim} on \Cref{asm:forwardsim:ctxstep} using \Cref{asm:forwardsim:staterel,asm:forwardsim:typechecks},
          giving us witnesses $\delta_0\ \trg{\Omega_{0}}\ \trg{\event}$,
          \begin{passumptions}{F}
            \item\label[ass]{asm:forwardsim:deltasubset0} $\delta\subseteq\delta_{0}$
            \item\label[ass]{asm:forwardsim:thectxstep} $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega_{0}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\event}}$
            \item\label[ass]{asm:forwardsim:eventeq} $\xlangeventeq[\delta_{0}]{\event}{\event}$
            \item $\xlangstateeq[\delta_{0}]{\Omega_{0}}{\Omega_{0}}$
          \end{passumptions}

          Instantiate the inductive hypothesis with $\delta_{\forall}=\delta_{0}$ and $\trg{\Omega_{\forall}}=\trg{\Omega_{0}}$ and obtain witnesses
          $\delta_{\IH}, \trg{\Omega_{\IH}}$, and $\trg{\trace[_{\IH}]}$ such that:
          \begin{passumptions}{\IH'}
            \item\label[ass]{asm:forwardsim:deltasubset:IH} $\delta_{0}\subseteq\delta_{\IH}$
            \item\label[ass]{asm:forwardsim:steps} $\exec{\trg{\Omega_{0}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega_{{\IH}}}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace[_{{\IH}}]}}$
            \item $\xlangtraceeq[\delta_{\IH}]{\trace}{\trace[_{\IH}]}$
            \item $\xlangstateeq[\delta_{\IH}]{\Omega_{0}}{\Omega_{\IH}}$
          \end{passumptions}

          \begin{description}
            \item \textbf{Case $\src{\event}\not=\src{\varepsilon}$:}
                Our goal looks as follows: $\exists \delta'\ \trg{\Omega'}\ \trg{\trace}$,
                \begin{goals}
                  \item\label[goal]{goal:forwardsim:deltasubset} $\delta\subseteq\delta'$
                  \item\label[goal]{goal:forwardsim:steps} $\exec{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace}}$
                  \item\label[goal]{goal:forwardsim:traceeq} $\xlangtraceeq{\event\cdot\trace}{\trace'}$
                  \item\label[goal]{goal:forwardsim:staterel} $\xlangstateeq{\Omega'}{\Omega'}$
                \end{goals}

                Instantiate the goal with $\delta_{\IH}, \trg{\Omega_{\IH}}, \trg{\event\cdot\trace}$.
                Note that $\delta\subseteq\delta_{\IH}$ (\Cref{goal:forwardsim:deltasubset}) follows by transitivity using \Cref{asm:forwardsim:deltasubset0,asm:forwardsim:deltasubset:IH}.
                Similarily for \Cref{goal:forwardsim:staterel}.

                Apply \Cref{tr:wt-e-trans-important} on \Cref{goal:forwardsim:steps}. So, what is left to show is
                \begin{goals}
                  \setcounter{enumi}{2}
                  \item\label[goal]{goal:forwardsim:tracerel} $\xlangtraceeq{\event\cdot\trace}{\event\cdot\trace}$
                  \setcounter{enumi}{4}
                  \item\label[goal]{goal:forwardsim:noeps:ctxstep} $\exec[]{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega_{0}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\event}}$
                  \item\label[goal]{goal:forwardsim:noeps:steps} $\exec{\trg{\Omega_{0}}}{\mmlAmmlAtcomp{e_{0}}}{\trg{\Omega_{\IH}}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace}}$
                \end{goals}
                \Cref{goal:forwardsim:tracerel} follows from \Cref{asm:forwardsim:justraceeq,asm:forwardsim:eventeq} using \Cref{tr:cons-trace-eq}.
                \Cref{goal:forwardsim:noeps:ctxstep} is proven by \Cref{asm:forwardsim:thectxstep}.
                \Cref{goal:forwardsim:noeps:steps} is proven by \Cref{asm:forwardsim:steps}.
            \item \textbf{Case $\src{\event}=\src{\varepsilon}$:}
                Similar to the other case, but make use of \Cref{asm:forwardsim:evnoteps}.
          \end{description}
  \end{description}
\end{proof}

\begin{lemma}[Different Reduction]\label{lem:differentreduction}
  If
  \begin{assumptions}
    \item\label[ass]{asm:differentreduction:nored} $\neg\left(\execs{\Omega}{e}{\Omega'}{\valueexpr}{\trace}\right)$
    \item\label[ass]{asm:differentreduction:red} $\execs{\Omega}{e}{\Omega'}{\valueexpr'}{\trace}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\src{\valueexpr}\not=\src{\valueexpr'}$
  \end{goals}
\end{lemma}
\begin{proof}
  Assume $\src{v}=\src{v'}$, apply \Cref{asm:differentreduction:nored} to the goal $\bot$, rewrite in the goal using $\src{v}=\src{v'}$ and solve the goal by \Cref{asm:differentreduction:red}.
\end{proof}

\begin{lemma}[Expression Correctness]\label{lem:expression:correctness}
  If
  \begin{assumptions}
  \item\label[ass]{asm:exprcorrect:exec1:trg} $\exec{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega'}}{\mmlAmmlAtcomp{\finalexpr}}{\trg{\trace}}$
  \item\label[ass]{asm:exprcorrect:stateeq} $\xlangstateeq{\Omega}{\Omega}$
  \item\label[ass]{asm:expr:corr:typechecks} $\typechecks{}{\Omega\triangleright e}{\nat}$
  \end{assumptions}
  Then $\exists \delta'\ \src{\Omega'}\ \src{\trace}$,
  \begin{goals}
  \item $\delta\subseteq\delta'$
  \item $\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$
  \item $\xlangstateeq[\delta']{\Omega'}{\Omega'}$
  \item $\xlangtraceeq[\delta']{\trace}{\trace}$
  \end{goals}
\end{lemma}
\begin{proof}
  We prove this by contradiction. So, we get the assumption:
  \begin{passumptions}{I}
    \item\label[ass]{asm:exprcorr:toplevel} $\forall\delta'\ \src{\Omega'}\ \src{\trace},\delta'\subset\delta\vee\neg\left(\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}\right)\vee\xlangstateneq[\delta']{\Omega'}{\Omega'}\vee\xlangtraceneq[\delta']{\trace}{\trace}$
  \end{passumptions}
  and need to prove $\bot$.
  Apply \Thmref{lem:progress} on \Cref{asm:expr:corr:typechecks}, so:
  \begin{passumptions}{I}
    \setcounter{enumi}{1}
    \item\label[ass]{asm:exprcorr:progressor} $\src{e}=\src{\valueexpr}$ or $\exists\src{\Omega'}\ \src{\valueexpr}\ \src{\trace},\execs{\Omega}{e}{\Omega'}{\valueexpr}{\trace}$
  \end{passumptions}
  Proceed by case anaylsis on \Cref{asm:exprcorr:progressor}.
  \begin{description}
    \item \textbf{Case $\src{e}=\src{\valueexpr}$:}
      Specialize \Cref{asm:exprcorr:toplevel} for $\delta'=\delta$, $\src{\Omega'}=\src{\Omega},$ and $\src{\trace}=\src{\hole{\cdot}}$.
      We proceed by case analysis:

      Invert \Cref{asm:exprcorrect:exec1:trg} and proceed by case analysis:
      \begin{description}
        \item \textbf{Case $\delta\subset\delta$:} Trivial.
        \item \textbf{Case }$\neg\left(\execs{\Omega}{\valueexpr}{\Omega}{\valueexpr}{\hole{\cdot}}\right)$\textbf{:}
            Simply apply $\neg\left(\execs{\Omega}{\valueexpr}{\Omega}{\valueexpr}{\hole{\cdot}}\right)$ to the goal $\bot$ and use \Cref{tr:ws-e-refl}.
        \item \textbf{Case }$\xlangstateneq{\Omega}{\Omega}$\textbf{:}
            Apply $\xlangstateneq{\Omega}{\Omega}$ to the goal $\bot$ and use \Cref{asm:exprcorrect:stateeq}.
        \item \textbf{Case }$\xlangtraceneq{\hole{\cdot}}{\hole{\cdot}}$\textbf{:}
            Apply $\xlangtraceneq{\hole{\cdot}}{\hole{\cdot}}$ to the goal $\bot$, use \Cref{tr:empty-trace-eq}.
      \end{description}

    \item \textbf{Case }$\exists\src{\Omega'}\ \src{\valueexpr}\ \src{\trace},\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$\textbf{:}
          First extract the witnesses and obtain:
          \begin{passumptions}{H}
            \item\label[ass]{asm:exprcorr:ereduce} $\execs{\Omega}{e}{\Omega'}{\finalexpr}{\trace}$
          \end{passumptions}


          Apply \Thmref{lem:forwardsim} to \Cref{asm:exprcorr:ereduce} with \Cref{asm:exprcorrect:stateeq,asm:expr:corr:typechecks} to get:
          \begin{passumptions}{F}
            \item\label[ass]{asm:exprcorrect:deltavsubset} $\delta\subseteq\delta_{v}$
            \item\label[ass]{asm:exprcorrect:exec2:trg} $\exec{\trg{\Omega}}{\mmlAmmlAtcomp{e}}{\trg{\Omega_{v}'}}{\mmlAmmlAtcomp{\valueexpr}}{\trg{\trace[_{v}]}}$
            \item\label[ass]{asm:exprcorrect:stateeq2} $\xlangstateeq[\delta_{v}]{\Omega'}{\Omega_{v}'}$
            \item\label[ass]{asm:exprcorrect:traceeq2} $\xlangtraceeq[\delta_{v}]{\trace}{\trace[_{v}]}$
          \end{passumptions}


          Use \Thmref{lem:determ:steps} on \Cref{asm:exprcorrect:exec1:trg,asm:exprcorrect:exec2:trg}, giving us:
          \begin{passumptions}{K}
            \item\label[ass]{asm:exprcorrect:compiledvalueseq} $\mmlAmmlAtcomp{v}=\mmlAmmlAtcomp{f}$
            \item\label[ass]{asm:exprcorrect:stateequal} $\trg{\Omega'}=\trg{\Omega_{v}'}$
            \item\label[ass]{asm:exprcorrect:traceequal} $\trg{\trace}=\trg{\trace[_{v}]}$
          \end{passumptions}
          Rewrite using \Cref{asm:exprcorrect:stateequal} in \Cref{asm:exprcorrect:stateeq2}, similarily \Cref{asm:exprcorrect:traceequal} in \Cref{asm:exprcorrect:traceeq2}:
          \begin{passumptions}{F'}
            \setcounter{enumi}{2}
            \item\label[ass]{asm:exprcorrect:stateeq3} $\xlangstateeq[\delta_{v}]{\Omega'}{\Omega'}$
            \item\label[ass]{asm:exprcorrect:traceeq3} $\xlangtraceeq[\delta_{v}]{\trace}{\trace}$
          \end{passumptions}
      Specialize \Cref{asm:exprcorr:toplevel} for $\delta'=\delta_{v}$, $\src{\Omega'}=\src{\Omega'},$ and $\src{\trace}=\src{\trace}$.
      We proceed by case analysis:
      \begin{description}
        \item \textbf{Case $\neg\left(\delta\subseteq\delta_{v}\right)$:} Apply $\neg\left(\delta\subseteq\delta_{v}\right)$ on our goal $\bot$, then $\delta\subseteq\delta_{v}$ immediately follows from \Cref{asm:exprcorrect:deltavsubset}.

        \item \textbf{Case }$\neg\left(\execs{\Omega}{e}{\Omega'}{\valueexpr}{\trace}\right)$\textbf{:}
          Using \Cref{asm:exprcorr:ereduce} and the assumption $\neg\left(\execs{\Omega}{e}{\Omega'}{\valueexpr}{\trace}\right)$, we conclude $\src{\valueexpr}\not=\src{f}$ using \Thmref{lem:differentreduction}.
          Apply \Thmref{lem:injective:comp} on \Cref{asm:exprcorrect:compiledvalueseq}, so $\src{\valueexpr}=\src{f}$, contradicting the above.

        \item \textbf{Case }$\xlangstateneq[\delta_{v}]{\Omega'}{\Omega'}$\textbf{:} Immediate contradiction with \Cref{asm:exprcorrect:stateeq3}.
        \item \textbf{Case }$\xlangtraceneq[\delta_{v}]{\trace}{\trace}$\textbf{:} Immediate contradiction with \Cref{asm:exprcorrect:traceeq3}.
      \end{description}
  \end{description}
\end{proof}

\subsubsection{Trace-based Backtranslation}

\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtbackv[]{\valueexpr} = \src{\valueexpr}}{,,Map an $\mmlAt$ value to an $\mmlAs$ value.''}$\;$\\
    \typerule{backtrans-value}{
    }{
      \mmlAmmlAtbackv[]{n} = \src{n}
    }{backtrans-value}
  \end{center}
}{backtrans-values}{Backtranslation of $\mmlAt$ values to $\mmlAs$ values.}

\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtbackdetail[]{\trace}=\src{e}}{,,Backtranslate a non-interface trace $\trg{\trace}$ to an $\mmlAs$ expression.''}
    %
    \typerule{backtrans-empty}{
    }{
      \mmlAmmlAtbackdetail[]{\hole{\cdot}}=\src{42}
    }{backtrans-empty}
    \typerule{backtrans-alloc}{
      \mmlAmmlAtbackdetail[]{\trg{\trace}}=\src{e}
    }{
      \mmlAmmlAtbackdetail[]{\trg{Alloc\ \loc\ s;\sandboxtag}\cdot\trg{\trace}}=\src{e}
    }{backtrans-alloc}
    \typerule{backtrans-dealloc}{
      \mmlAmmlAtbackdetail[]{\trg{\trace}}=\src{e}
    }{
      \mmlAmmlAtbackdetail[]{\trg{Dealloc\ \loc;\sandboxtag}\cdot\trg{\trace}}=\src{e}
    }{backtrans-dealloc}
    \typerule{backtrans-set}{
      \mmlAmmlAtbackdetail[]{\trg{\trace}}=\src{e}
    }{
      \mmlAmmlAtbackdetail[]{\trg{Set\ \loc\ n;\sandboxtag}\cdot\trg{\trace}}=\src{e}
    }{backtrans-set}
    \typerule{backtrans-get}{
      \mmlAmmlAtbackdetail[]{\trg{\trace}}=\src{e}
    }{
      \mmlAmmlAtbackdetail[]{\trg{Get\ \loc\ n;\sandboxtag}\cdot\trg{\trace}}=\src{e}
    }{backtrans-get}
    \typerule{backtrans-abort}{
    }{
      \mmlAmmlAtbackdetail[]{\lightning;\sandboxtag}=\src{abort()}
    }{backtrans-abort}
    %
  \end{center}
}{tms-pres-backtrans}{Trace-Based Backtranslation from memory-specific $\mmlAt$ events to $\mmlAs$ terms.}
\myfig{
  \begin{center}
    \judgbox{\Game\left(\src{\loc}\right)=\src{x}}{,,Map an $\mmlAs$ location to an $\mmlAs$ identifier.''}
    \judgbox{\mmlAmmlAtbackcomptoctx[\Game;\delta;\trg{\overline{\loc}}]{\event}=\trg{\overline{\loc'}};\src{e}}{,,Given a \varmapbacktransds $\Game$, $\delta$, and $\trg{\overline{\loc}}$, yield\\another stack of locations $\trg{\overline{\loc'}}$, and an $\mmlAs$\\expression from target $\comptoctx$-interaction-event $\trg{\event}$.''}
    %
    \typerule{backtrans-start}{
    }{
      \mmlAmmlAtbackcomptoctx[\emptyset;\emptyset;\trg{\hole{\cdot}}]{\trg{Start}} = \trg{\hole{\cdot}};\src{42}
    }{backtrans-start}
    %
    \typerule{backtrans-end}{
    }{
      \mmlAmmlAtbackcomptoctx[\Game;\delta;\trg{\hole{\cdot}}]{\trg{End\ \valueexpr}} = \trg{\hole{\cdot}};\mmlAmmlAtbackv[]{\valueexpr}
    }{backtrans-end}
    %
%   \typerule{backtrans-call-comptoctx}{
%   }{
%     \mmlAmmlAtbackcomptoctx[\Game;\delta;\trg{\overline{\loc}}]{\trg{Call\ \comptoctx\ foo\ \interfacevalue}}=\trg{\overline{\loc}};\src{42}
%   }{backtrans-call-comptoctx}
    %
    \typerule{backtrans-ret-comptoctx}{
      \delta(\src{\loc})=\trg{\loc} &
      \src{z}=\Game(\src{\loc}) &
      \src{e}=\src{delete\ z}
    }{
      \mmlAmmlAtbackcomptoctx[\Game;\delta;\trg{\loc,\overline{\loc}}]{\trg{Ret\ \comptoctx\ \valueexpr}}=\trg{\overline{\loc}};\src{e;}\mmlAmmlAtbackv[]{\valueexpr}
    }{backtrans-ret-comptoctx}
    %
    %
    \judgbox{\mmlAmmlAtbackctxtocomp[\Game;\delta;\trg{\overline{\loc}}]{\event}=\Game';\delta';\trg{\overline{\loc'}};\src{e}}{,,Given a \varmapbacktransds $\Game$, $\delta$, and $\trg{\overline{\loc}}$, construct a \varmapbacktransds $\Game'$,\\ a $\delta'$, another stack of locations $\trg{\overline{\loc'}}$, and an $\mmlAs$\\expression from target $\ctxtocomp$-interaction-event $\trg{\event}$.''}
    %
    \typerule{backtrans-call-ctxtocomp}{
      \fresh{\Game,\delta}{\src{\loc}}&
      \fresh{\Game}{\src{z}}&
      \fresh{\delta}{\trg{\loc}}\\
      \Game_z=\Game\cup\{\src{\loc}\mapsto\src{z}\} &
      \delta'=\delta\cup\{\src{\loc}\mapsto\trg{\loc}\}\\
      \src{e}=\src{let\ z = new\ 42\ in\ call\ }\mmlAmmlAtbackdetail[]{foo}\ \mmlAmmlAtbackv[]{\valueexpr}
    }{
      \mmlAmmlAtbackctxtocomp[\Game;\delta;\trg{\overline{\loc}}]{\trg{Call\ \ctxtocomp\ foo\ \valueexpr}}=\Game_z;\delta';\trg{\loc,\overline{\loc}};\src{e}
    }{backtrans-call-ctxtocomp}
    %
%   \typerule{backtrans-ret-ctxtocomp}{
%     \fresh{\Game}{\src{x}}
%   }{
%     \mmlAmmlAtbackctxtocomp[\Game,\trg{\overline{\loc}}]{\trg{Ret\ \ctxtocomp\ \interfacevalue}}=\Game,\trg{\overline{\loc}},\src{let\ x = new\ 1\ in\ delete\ x;return\ }\mmlAmmlAtbackv{\interfacevalue}
%   }{backtrans-ret-ctxtocomp}
    %
    \typerule{backtrans-end-ctxtocomp}{
    }{
      \mmlAmmlAtbackctxtocomp[\Game;\delta;\trg{\hole{\cdot}}]{\trg{End\ \valueexpr}}=\Game;\delta;\trg{\hole{\cdot}};\mmlAmmlAtbackv[]{\valueexpr}
    }{backtrans-end-ctxtocomp}
  \end{center}
}{tms-pres-backtrans-interact}{Backtranslation of interaction-events from memory-specific $\mmlAt$ events to $\mmlAs$ terms.}
\myfig{
  \begin{center}
    \typerule{non-interface-$\trg{\varepsilon}$}{
    }{
      \vdash \trg{\varepsilon} \operatorname{non-int-\trg{\event}}
    }{non-interface-epsilon}
    %
    \typerule{non-interface-$\trg{Alloc}$}{
    }{
      \vdash \trg{Alloc\ \loc\ n} \operatorname{non-int-\trg{\event}}
    }{non-interface-alloc}
    %
    \typerule{non-interface-$\trg{Dealloc}$}{
    }{
      \vdash \trg{Dealloc\ \loc} \operatorname{non-int-\trg{\event}}
    }{non-interface-dealloc}
    %
    \typerule{non-interface-$\trg{Get}$}{
    }{
      \vdash \trg{Get\ \loc\ n} \operatorname{non-int-\trg{\event}}
    }{non-interface-get}
    %
    \typerule{non-interface-$\trg{Set}$}{
    }{
      \vdash \trg{Set\ \loc\ n} \operatorname{non-int-\trg{\event}}
    }{non-interface-set}
    %
    \typerule{non-interface-$\trg{\lightning}$}{
    }{
      \vdash \trg{\lightning} \operatorname{non-int-\trg{\event}}
    }{non-interface-abort}
    %
    \typerule{non-interface-trace-empty}{
    }{
      \vdash \trg{\hole{\cdot}} \operatorname{non-int-\trg{\trace}}
    }{non-interface-trace-empty}
    %
    \typerule{non-interface-trace-cons}{
      \vdash \trg{\event} \operatorname{non-int-\trg{\trace}} &
      \vdash \trg{\trace} \operatorname{non-int-\trg{\trace}}
    }{
      \vdash \trg{\event\cdot\trace} \operatorname{non-int-\trg{\trace}}
    }{non-interface-trace-cons}
  \end{center}
}{tms-non-interfacing-events}{Non-Interfacing events.}
\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtbacksubtop[\Game, \trg{\overline{\loc}}]{\event[_1]\cdot\trace\cdot\event[_2]}=\Game',\trg{\overline{\loc'}},\src{e_1},\src{e_2}}{,,Given a \varmapbacktransds $\Game$ and $\trg{\overline{\loc}}$, construct a\\\varmapbacktransds $\Game'$, another stack of locations $\trg{\overline{\loc'}}$, and\\an $\mmlAs$ backtranslation context from\\target-trace $\trg{\mstrace}$ which starts with a $\ctxtocomp$ event\\and ends in a $\comptoctx$.''}
    %
    \typerule{subtoplevel-backtrans}{
      \vdash \trg{\trace} \operatorname{non-int-\trg{\trace}}\\
      \mmlAmmlAtbackcomptoctx[\Game,\trg{\overline{\loc}}]{\trg{\event[_1]}}=\Game',\trg{\overline{\loc'}},\src{e_1} &
      \mmlAmmlAtbackdetail[\Game',\trg{\overline{\loc'}}]{\trg{\trace}}=\Game'',\trg{\overline{\loc''}}, \src{e_2} &
      \mmlAmmlAtbackctxtocomp[\Game'',\trg{\overline{\loc''}}]{\trg{\event[_2]}}=\Game''',\trg{\overline{\loc'''}},\src{e_3} \\
    }{
      \mmlAmmlAtbacksubtop[\Game,\trg{\overline{\loc}}]{\trg{\event[_1]\cdot\trace\cdot\event[_2]}}=\Game''',\trg{\overline{\loc'''}}, \src{e_1}, \src{e_2},\src{e_3}
    }{subtoplevel-backtrans}
    %
    \typerule{subtoplevel-backtrans-indu}{
      \trg{\trace[_1]}=\trg{\event[^A_1]\cdot\trace[^A]\cdot\event[^A_2]} &
      \vdash\trg{\trace[^A]}\ \operatorname{non-int-\trg{\trace}} \\
      \mmlAmmlAtbackcomptoctx[\Game,\trg{\overline{\loc}}]{\trg{\event[^A_1]}}=\Game',\trg{\overline{\loc'}},\src{e_1^A} &
      \mmlAmmlAtbackdetail[\Game',\trg{\overline{\loc'}}]{\trg{\trace^A}}=\Game'',\trg{\overline{\loc''}}, \src{e_2^A} \\
      \mmlAmmlAtbackctxtocomp[\Game'',\trg{\overline{\loc''}}]{\trg{\event[^A_2]}}=\Game''',\trg{\overline{\loc'''}},\src{let\ x_0=new\ n_0\ in\ e_3^A} \\
      \mmlAmmlAtbacksubtop[\Game''',\trg{\overline{\loc'''}}]{\trace[_2]} = \Game'''',\trg{\overline{\loc''''}},\src{e_1^B},\src{e_2^B},\src{e_3^B} \\
      \src{e^A}=\src{e^A_1;e^A_2;let\ x_0=new\ n_0\ in\ (e_3^A;e_1^B)}
    }{
      \mmlAmmlAtbacksubtop[\Game,\trg{\overline{\loc}}]{\trg{\trace[_1]\cdot\trace[_2]}}=\Game'''',\trg{\overline{\loc''''}},\src{e^A},\src{e^B_2},\src{e^B_3}
    }{subtoplevel-backtrans-indu}
  \end{center}
}{tms-pres-subtop-backtrans}{Interaction-Trace-Based Backtranslation from memory-specific $\mmlAt$ events to $\mmlAs$ terms.}

\myfig{
  \begin{center}
    \judgbox{\mmlAmmlAtback[\Game]{\mstrace} = \Game',\src{\library}}{,,Top-Level backtranslation of $\trg{\trace}$ to $\mmlAs$ library $\src{\library}$.''}
    %
    \typerule{backtrans-top-level}{
      \trg{\trace}=\trg{\trace[_0]\cdot\trace[^{comp}]\cdot\trace[_1]} &
      \vdash \trg{\trace[^{comp}]} \operatorname{non-int-\trg{\trace}} \\
      \trg{\trace[_0]}=\trg{Start\cdot\trace[_0']\cdot Call\ \ctxtocomp\ foo\ \interfacevalue_1}\\
      \trg{\trace[_1]}=\trg{Ret\ \comptoctx\ \interfacevalue_2\cdot\trace[_0']\cdot End\ \interfacevalue_3}\\
      \mmlAmmlAtbacksubtop[\Game,\trg{\hole{\cdot}}]{\trace[_0]} = \Game', \trg{\overline{\loc}}, \src{e_0},\src{e_0'},\src{let\ x_0 = new\ n_0\ in\ e_0''} \\
      \mmlAmmlAtbacksubtop[\Game',\trg{\overline{\loc}}]{\trace[_1]} = \Game'', \trg{\hole{\cdot}}, \src{e_1},\src{e_1'},\src{e_1''} \\
      \src{e} = \src{e_0;e_0';let\ x_0 = new\ n_0\ in\ (e_0'';e_1);e_1';e_1''}
    }{
      \mmlAmmlAtback[\Game]{\trace} = \Game'', \src{let\ main\ x : \nat\to\nat := e, \hole{\cdot}}
    }{backtrans-top-level}
  \end{center}
}{tms-pres-top-level-backtrans}{Top-Level trace-based Backtranslation from $\mmlAt$ trace $\trg{\trace}$ to $\mmlAs$ context $\src{\library}$.}

.\MK{take care of $\trg{\lightning}$}

\subsubsection{Proofs and Auxiliary Lemmas}

\begin{lemma}[$\xlangstateeq{\commlib;\library;\hole{\cdot}}{\commlib;\library;\hole{\cdot}}$ holds]\label{lem:cfeq:refl}
  If
  \begin{assumptions}
    \item $\xlangstateeq{\library}{\library}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\xlangstateeq{\commlib;\library;\hole{\cdot}}{\commlib;\library;\hole{\cdot}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy.
\end{proof}

\begin{lemma}[if $\src{\loc}\in\src{L}$, then $\src{\poison}$ doesn't matter]\label{lem:locinL:poisondoesntmatter}
  If
  \begin{assumptions}
    \item $\src{\memstate}=\src{H;\Delta_{1},x\mapsto\loc_{\poison},\Delta_{2}}$
    \item $\src{\memstate'}=\src{H;\Delta_{1},x\mapsto\loc_{\poison'},\Delta_{2}}$
    \item $\src{\loc}\in\src{L}$
    \item $\xlangbackstateeq{\memstate}{\memstate}$
  \end{assumptions}
  Then
  \begin{goals}
    \item $\xlangbackstateeq{\memstate}{\memstate'}$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy.
\end{proof}

\begin{lemma}[$\src{\loc}\in\operatorname{dom}\delta$ decomposes $\src{\Delta}$]\label{lem:deltadecomposeDelta}
  If
  \begin{assumptions}
    \item $\src{\loc}\in\operatorname{dom}\delta$
    \item $\xlangstateeq{\Delta;H}{\Delta;H}$
  \end{assumptions}
  Then $\exists \src{\Delta_{1}}\ \src{x}\ \src{\poison}\ \src{\Delta_{2}}$
  \begin{goals}
    \item $\src{\Delta}=\src{\Delta_{1},x\mapsto\loc_{\poison},\Delta_{2}}$
  \end{goals}
\end{lemma}
\begin{proof}
  Easy.
\end{proof}

\begin{lemma}[Backtranslation for Non-Interacting Traces is Well-Typed]\label{lem:expr:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item $\trg{\trace}$ not stuck
  \item $\vdash\trg{\trace} \operatorname{non-int-\trg{\trace}}$
  \item $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trace}=\Game,\trg{\overline{\loc'}},\src{e}$
  \end{assumptions}
  Then
  \begin{goals}
  \item $\typechecks{}{e}{\nat}$
  \end{goals}
\end{lemma}
\begin{proof}
  Induction on $\trg{\trace}$. Most cases go through immediately using the induction hypothesis, the only left cases are $\src{e}=\src{42}$ and $\src{e}=\src{abort()}$.
  Since $\trg{\trace}$ is not stuck, it cannot be that the backtranslation yields $\src{abort()}$.
  The term $\src{42}$ easily typechecks against an empty gamma.
\end{proof}

\begin{lemma}[Backtranslation for $\comptoctx$-Interacting Events is Well-Typed]\label{lem:expr:interact:comptoctx:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item $\trg{\event}$ not stuck
  \item\label[ass]{asm:expr:interact:comptoctx:backtranslation:welltyped} $\mmlAmmlAtbackcomptoctx[\Game,\trg{\overline{\loc}}]{\event}=\Game,\trg{\overline{\loc'}},\src{e}$
  \end{assumptions}
  Then $\exists \src{\Gamma}$,
  \begin{goals}
  \item $\typechecks{\Gamma}{e}{\nat}$
  \end{goals}
\end{lemma}
\begin{proof}
  Inverting \Cref{asm:expr:interact:comptoctx:backtranslation:welltyped} yields two cases, so we continue with two cases.
  \begin{description}
    \item \textbf{Case }$\trg{\event} = \trg{Call\ \comptoctx\ foo\ \interfacevalue}$\textbf{:}

    Here, $\src{e} = \src{42}$. Let $\src{\Gamma} = \src{\hole{\cdot}}$, it's easy to see that $\typechecks{}{42}{\nat}$ holds by \Cref{tr:t-nat}.

    \item \textbf{Case }$\trg{\event} = \trg{Ret\ \comptoctx\ \interfacevalue}$\textbf{:}

    $\src{e} = \src{delete\ z}$, where $\src{z} = \Game\left(\trg{\loc}\right)$ and $\trg{\loc}$ is at the top of the stack of locations $\trg{\overline{\loc}}$.
    Choose $\src{\Gamma} = \src{x:\ptr,\hole{\cdot}}$, the typing follows using \Cref{tr:w-t-delete}.
  \end{description}
\end{proof}

\begin{lemma}[Backtranslation for Call-$\ctxtocomp$ is Well-Typed]\label{lem:expr:interact:call:comptoctx:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item\label[ass]{asm:expr:interact:call:ctxtocomp:backtranslation:welltyped} $\mmlAmmlAtbackctxtocomp[\Game,\trg{\overline{\loc}}]{Call\ \ctxtocomp\ foo\ \interfacevalue}=\Game',\trg{\loc,\overline{\loc'}},\src{e'}$
  \item $\src{x} = \Game'\left(\trg{\loc}\right)$
  \item $\src{e}=\src{e';\ delete\ x}$
  \item\label[ass]{asm:expr:interact:call:ctxtocomp:backtranslation:gamma} $\src{\Gamma}=\src{\Gamma_{1}, foo:\nat\to\nat ,\Gamma_{2}}$
  \end{assumptions}
  Then,
  \begin{goals}
  \item $\typechecks{\Gamma}{e}{\nat}$
  \end{goals}
\end{lemma}
\begin{proof}
  Invert \Cref{asm:expr:interact:call:ctxtocomp:backtranslation:welltyped} giving\\$\src{e}=\src{let\ x=new\ 42\ in\ call\ }\mmlAmmlAtbackv[\Game']{foo}\ \mmlAmmlAtbackv[\Game']{\interfacevalue}\src{;\ delete\ x}$, where $\Game' = \Game\left[\trg{\loc}\right]$ and $\fresh{\Game}{\trg{\loc}}$.
  The claim follows using \Cref{tr:w-t-new,tr:w-t-delete} and \Cref{tr:t-let,tr:t-call}, where the latter uses \Cref{asm:expr:interact:call:ctxtocomp:backtranslation:gamma}.
\end{proof}

Note that $\src{\nat\to\nat}$ only holds under the assumption of non-passing pointers.

\begin{lemma}[Backtranslation for Ret-$\ctxtocomp$ is Well-Typed]\label{lem:expr:interact:ret:ctxtocomp:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item\label[ass]{asm:expr:interact:ret:ctxtocomp:backtranslation:welltyped} $\mmlAmmlAtbackctxtocomp[\Game,\trg{\overline{\loc}}]{Ret\ \ctxtocomp\ \interfacevalue}=\Game,\trg{\overline{\loc'}},\src{e}$
  \end{assumptions}
  Then,
  \begin{goals}
  \item $\typechecks{}{e}{\nat\to\bot}$
  \end{goals}
\end{lemma}
\begin{proof}
  Invert \Cref{asm:expr:interact:ret:ctxtocomp:backtranslation:welltyped} giving $\src{e}=\src{let\ x=new\ 1\ in\ delete\ x;\ return\ }\mmlAmmlAtbackv{\interfacevalue}$, where $\fresh{\Game}{\src{x}}$.
  It's assumed that $\mmlAmmlAtbackv{\interfacevalue}=\src{n}$, which works because we disregard the passing of pointers at the moment.
  So, the claim follows using \Cref{tr:w-t-new,tr:w-t-delete,tr:t-return}.
\end{proof}

\begin{lemma}[Backtranslation is Well-Typed]\label{lem:backtranslation:welltyped}
  If
  \begin{assumptions}
  \item $\trg{\trace}$ not stuck
  \item\label[ass]{asm:backtranslation:welltyped:backtrans} $\mmlAmmlAtback[\emptyset]{\trace}=\Game,\src{\library_{ctx}}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
  \item $\Gammas\vdash\src{\library_{comp}}\operatorname{ok}$
  \end{assumptions}
  Then,
  \begin{goals}
  \item $\Gammas\vdash\src{\library}\operatorname{ok}$
  \end{goals}
\end{lemma}
\begin{proof}
  First up, note that $\Gammas\vdash\src{\library_{comp}}\operatorname{ok}$, so it suffices to check $\Gammas\vdash\src{\library_{ctx}}\operatorname{ok}$ by \Thmref{lem:typed:linking:recomposition}.
  By inverting \Cref{asm:backtranslation:welltyped:backtrans} we get $\trg{\trace}=\trg{\trace[_{0}]\cdot\trace[^{comp}]\cdot\trace[_{1}]}$ and\\$\src{e}=\src{e_{0};e_{0}';let\ x_{0}=new\ n_{0}\ in\ \left(e_{0}'';e_{1}\right);e_{1}';e_{1}''}$, where:
  \begin{passumptions}{H}
    \item $\vdash\trg{\trace[^{comp}]}\operatorname{non-int-\trg{\trace}}$
    \item\label[ass]{asm:backtranslation:welltyped:subtop1} $\mmlAmmlAtbackdetail[\Game,\trg{\hole{\cdot}}]{\trace[_{0}]}=\Game',\trg{\overline{\loc}},\src{e_{0}},\src{e_{0}'},\src{let\ x_{0} = new\ n_{0}\ in\ e_{0}''}$
    \item\label[ass]{asm:backtranslation:welltyped:subtop2} $\mmlAmmlAtbackdetail[\Game',\trg{\overline{\loc}}]{\trace[_{1}]}=\Game'',\trg{\hole{\cdot}},\src{e_{1}},\src{e_{1}'},\src{e_{1}''}$.
  \end{passumptions}
  Inverting \Cref{asm:backtranslation:welltyped:subtop1,asm:backtranslation:welltyped:subtop2}, first take note that\\$\trg{\trace[_0]}=\trg{Call\ \comptoctx\ main\ \interfacevalue_1\cdot\trace[_0']\cdot Call\ \ctxtocomp\ foo\ \interfacevalue_2}$ and $\trg{\trace[_1]}=\trg{Ret\ \ctxtocomp\ \interfacevalue_3\cdot\trace[_1']\cdot Ret\ \comptoctx\ \interfacevalue_4}$.
  Furthermore, $\src{e_{0}}=\src{42}$, $\mmlAmmlAtbackdetail[\Game,\trg{\hole{\cdot}}]{\trace[_{0}']}=\Game',\trg{\loc,\overline{\loc}},\src{e_{0}'}$, and $\src{e_0''}=\src{let\ z=new\ 42\ in\ call\ foo\ n}$, where $\src{z}=\Game'\left(\trg{\loc}\right)$, $\src{n}=\mmlAmmlAtbackv{\interfacevalue_{2}}$, and $\mmlAmmlAtcomp{foo}=\trg{foo}$ with $\src{foo}\in\operatorname{dom}\src{\library_{comp}}$.
  Also, $\src{e_{1}}=\src{delete\ z}$, $\mmlAmmlAtbackdetail[\Game',\trg{\loc,\overline{\loc}}]{\trace[_{1}']}=\Game'',\trg{\hole{\cdot}},\src{e_{1}'}$, and $\src{e_{1}''}=\src{let\ x = new\ 1\ in\ delete\ x;return\ m}$, where $\src{m}=\mmlAmmlAtbackv[\Game'']{\interfacevalue_{4}}$ and $\fresh{\Game''}{\src{x}}$.
  Therefore: $$\src{e}=\src{42;e_{0}';let\ z=new\ 42\ in\ \left(call\ foo\ n; delete\ z\right);e_{1}';let\ x=\ new\ 1\ in\ delete\ x;return\ m}$$

  This typechecks easily, making use of \Cref{tr:w-t-new,tr:w-t-delete} and \Cref{tr:t-let,tr:t-return,tr:t-call}, as well as \Thmref{lem:expr:backtranslation:welltyped}.
\end{proof}

\begin{lemma}[Backtranslation Correctness of $\trg{Start}$]\label{lem:exprbacktranslation:vbeg:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item\label[ass]{asm:exprbacktranslation:vbeg:wrapper:correct:exect} $\exect[]{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_{main}}{Start}$
  \item $\mmlAmmlAtbackdetail[\Game,\trg{\hole{\cdot}}]{Start}=\Game,\trg{\hole{\cdot}},\src{42}$
  \item $\xlangstateeq[\emptyset;\src{\hole{\cdot}}]{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}$
  \item $\src{\library}=\left\{\src{main}\mapsto\src{42;e_{main}}\right\}\src{\linker\library_{comp}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{goal:exprbacktranslation:vbeg:wrapper:correct:execs} $\exec{\src{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}}{\src{call\ main\ 0}}{\src{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}}{\src{e_{main}}}{\src{Start}}$
  \item\label[goal]{goal:exprbacktranslation:vbeg:wrapper:correct:backstateeq} $\xlangbackstateeq[\emptyset;\src{\hole{\cdot}}]{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{\src{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}}$
  \item\label[goal]{goal:exprbacktranslation:vbeg:wrapper:correct:eventeq} $\src{Start}\thexlangtraceeq[\emptyset;\src{\hole{\cdot}}]\trg{Start}$
  \end{goals}
\end{lemma}
\begin{proof}
  Note using \Cref{tr:w-e-ectx-call-value} we can easily conclude:
  \begin{passumptions}{H}
    \item\label[ass]{asm:exprbacktranslation:vbeg:wrapper:correct:execs0} $\execs[]{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\commlib;\library;\hole{\cdot}^{main}_{\comptoctx},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{let\ \_=42\ in\ e_{main}}{Start}$
  \end{passumptions}
  On \Cref{asm:exprbacktranslation:vbeg:wrapper:correct:execs0} apply \Cref{tr:w-e-ectx,tr:w-e-let-x}
  \begin{passumptions}{H}
    \setcounter{enumi}{1}
    \item\label[ass]{asm:exprbacktranslation:vbeg:wrapper:correct:execs1} $\execs[]{\commlib;\library;\hole{\cdot}^{main}_{\comptoctx},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{let\ \_{=42\ in\ e_{main}}}{\commlib;\library;\hole{\cdot}^{main}_{\comptoctx},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_{main}}{\emptyevent}$
  \end{passumptions}
  Use \Cref{asm:exprbacktranslation:vbeg:wrapper:correct:execs0,asm:exprbacktranslation:vbeg:wrapper:correct:execs1} on \Cref{tr:ws-e-trans-important}:\MK{we need reflexivity for subsumption to * in\Cref{asm:exprbacktranslation:vbeg:wrapper:correct:execs1}}
  \begin{passumptions}{H}
    \setcounter{enumi}{2}
    \item\label[ass]{asm:exprbacktranslation:vbeg:wrapper:correct:execs} $\execs[]{\commlib;\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}{call\ main\ 0}{\commlib;\library;\hole{\cdot}^{main}_{\comptoctx},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_{main}}{Start}$
  \end{passumptions}
  This concludes \Cref{goal:exprbacktranslation:vbeg:wrapper:correct:execs}.

  \Cref{goal:exprbacktranslation:vbeg:wrapper:correct:backstateeq} by \Cref{tr:state-qe}, \Cref{tr:memstate-qe,tr:cfstate-qe} and \Cref{tr:empty-kontstack-qe,tr:empty-commlib-eq,tr:empty-memstate-eq}.
  \Cref{goal:exprbacktranslation:vbeg:wrapper:correct:eventeq} follow \Cref{tr:start-event-eq}.
\end{proof}

\begin{lemma}[Backtranslation Correctness of $\trg{Ret}$]\label{lem:exprbacktranslation:beg:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:exect} $\exect[]{\Omega}{K_{component}[return\ \interfacevalue]}{\Omega'}{K[\interfacevalue]}{Ret\ \comptoctx\ \interfacevalue}$
  \item $\trg{K_{component}}=\mmlAmmlAtcomp{K_{component}}$
  \item $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{Ret\ \comptoctx\ \interfacevalue}=\Game',\trg{\overline{\loc'}},\src{delete\ z}$
  \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:staterel} $\xlangstateeq{\Omega}{\Omega}$
  \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:omegas} $\src{\Omega}=\src{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}$
  \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:K} $\src{K}=\src{\hole{\cdot};delete\ z;e_{any}}$
  \item $\src{\library}=\left\{\src{main}\mapsto\src{e_{main}}\right\}\src{\linker\library_{comp}}$
  \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:delta} $\delta\left(\src{\loc}\right)=\trg{\loc}$
  \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:linL} $\src{\loc}\in\src{L}$
  \end{assumptions}
  then $\exists \src{X'}\ \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:Xsubset} $\src{X}\subseteq\src{X'}$
  \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:execs} $\exec{\src{\Omega}}{\src{K_{component}[return\ }\mmlAmmlAtbackv[\Game']{\trg{\interfacevalue}}\src{]}}{\src{\commlib;\library;\kontstack;\memstate'}}{\src{e_{any}}}{\src{\trace}}$
  \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:stateeq} $\xlangbackstateeq[\delta;\src{L}]{\Omega'}{\src{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}}$
  \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:traceeq} $\src{\trace}\thexlangtraceeq[\delta;\src{X'}]\trg{Ret\ \comptoctx\ \interfacevalue}$
  \end{goals}
\end{lemma}
\begin{proof}
  From \Cref{asm:exprbacktranslation:beg:wrapper:correct:delta} it is clear that:
  \begin{passumptions}{H}
    \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:locindom} $\src{\loc}\in\operatorname{dom}\delta$
  \end{passumptions}
  Invert \Cref{asm:exprbacktranslation:beg:wrapper:correct:staterel}:
  \begin{passumptions}{H}
    \setcounter{enumi}{1}
    \item $\src{\Omega}=\src{\cfstate;\memstate}$
    \item $\trg{\Omega}=\trg{\cfstate;\memstate}$
    \item $\xlangstateeq[]{\cfstate}{\cfstate}$
    \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:memstaterel} $\xlangstateeq{\memstate}{\memstate}$
  \end{passumptions}
  Decompose $\src{\memstate}$ into $\src{\Delta;H}$.
  Make use of \Cref{asm:exprbacktranslation:beg:wrapper:correct:memstaterel,asm:exprbacktranslation:beg:wrapper:correct:locindom} with \Thmref{lem:deltadecomposeDelta}:
  \begin{passumptions}{H}
    \setcounter{enumi}{5}
    \item $\src{\Delta}=\src{\Delta_{1},x\mapsto\loc_{\poison},\Delta_{2}}$
  \end{passumptions}
  Note that $\src{x}=\src{z}$ by shape of $\delta$.\MK{we need relation between $\Game$ and $\delta$/$\src{\Delta}$}
  For the goals, instantiate the existentials with:
  \begin{passumptions}{E}
    \item $\src{X'}=\src{X}\cup\left\{\src{Dealloc\ \loc}\right\}$
    \item $\src{\trace}=\src{Dealloc\ \loc\cdot Ret\ \comptoctx\ }\mmlAmmlAtbackv{\interfacevalue}$
    \item $\src{\memstate'}=\src{H;\Delta_{1},x\mapsto\loc_{\poisoned},\Delta_{2}}$
  \end{passumptions}
  \Cref{goal:exprbacktranslation:beg:wrapper:correct:Xsubset} is easy.
  Suppose $\trg{\interfacevalue}=\trg{n}$.
  For \Cref{goal:exprbacktranslation:beg:wrapper:correct:execs}, first note \Cref{asm:exprbacktranslation:beg:wrapper:correct:omegas}, use \Cref{tr:w-e-ectx-ret-value} and rewrite $\src{K}$ using \Cref{asm:exprbacktranslation:beg:wrapper:correct:K}:
  \begin{passumptions}{H^a}
    \setcounter{enumi}{6}
    \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:execs0a} $\execs[]{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}{K_{component}\hole{return\ n}}{\commlib;\library;\kontstack;\memstate}{n;delete\ z;e_{any}}{Ret\ \comptoctx\ n}$
  \end{passumptions}
  Similarily, if $\trg{\interfacevalue}=\trg{\loc}$ where $\mmlAmmlAtbackv{\loc}=\src{z}$\MK{need a lemma + relation between $\Game$ and $\delta$/$\src{\Delta}$}, just use \Cref{tr:w-e-ectx-ret-loc}:
  \begin{passumptions}{H^b}
    \setcounter{enumi}{6}
    \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:execs0b} $\execs[]{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}{K_{component}\hole{return\ n}}{\commlib;\library;\kontstack;\memstate}{z;delete\ z;e_{any}}{Ret\ \comptoctx\ \loc}$
  \end{passumptions}
  In the following, we will write $\src{\interfacevalue}$ to represent either $\src{x}$ or $\src{n}$.
  In both cases, \Cref{asm:exprbacktranslation:beg:wrapper:correct:execs0a,asm:exprbacktranslation:beg:wrapper:correct:execs0b}, continue with \Cref{tr:w-e-ectx,tr:w-e-let-x}:
  \begin{passumptions}{H}
    \setcounter{enumi}{7}
    \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:execs1} $\execs[]{\commlib;\library;\kontstack;\memstate}{n;delete\ z;e_{any}}{\commlib;\library;\kontstack;\memstate}{delete\ z;e_{any}}{\varepsilon}$
  \end{passumptions}
  Finally, use \Cref{tr:w-e-ectx,tr:w-e-delete} on \Cref{asm:exprbacktranslation:beg:wrapper:correct:execs1}:
  \begin{passumptions}{H}
    \setcounter{enumi}{8}
    \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:execs2} $\execs[]{\commlib;\library;\kontstack;\memstate}{delete\ z;e_{any}}{\commlib;\library;\kontstack;\memstate'}{e_{any}}{Dealloc\ \loc}$
  \end{passumptions}
  Use \Cref{asm:exprbacktranslation:beg:wrapper:correct:execs0a,asm:exprbacktranslation:beg:wrapper:correct:execs1,asm:exprbacktranslation:beg:wrapper:correct:execs2} on \Cref{tr:ws-e-trans-important,tr:ws-e-trans-unimportant} to get exactly what \Cref{goal:exprbacktranslation:beg:wrapper:correct:execs} wants us to prove.
  Similarily, use \Cref{asm:exprbacktranslation:beg:wrapper:correct:execs0b,asm:exprbacktranslation:beg:wrapper:correct:execs1,asm:exprbacktranslation:beg:wrapper:correct:execs2} on \Cref{tr:ws-e-trans-important,tr:ws-e-trans-unimportant} to get exactly what \Cref{goal:exprbacktranslation:beg:wrapper:correct:execs} wants us to prove.

  With \Cref{asm:exprbacktranslation:beg:wrapper:correct:omegas}, invert \Cref{asm:exprbacktranslation:beg:wrapper:correct:staterel}:
  \begin{passumptions}{H}
    \setcounter{enumi}{9}
    \item $\trg{\Omega}=\trg{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}$
    \item $\trg{\cfstate}=\trg{\commlib;\library;K^{foo}_{\comptoctx},\kontstack}$
    \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:cfstateeq} $\xlangstateeq[]{\cfstate}{\cfstate}$
    \item\label[ass]{asm:exprbacktranslation:beg:wrapper:correct:memstaterell} $\xlangstateeq{\memstate}{\memstate}$
  \end{passumptions}
  Invert \Cref{asm:exprbacktranslation:beg:wrapper:correct:exect} to extract:
  \begin{passumptions}{H}
    \setcounter{enumi}{13}
    \item $\trg{\Omega'}=\trg{\commlib;\library;\kontstack;\memstate}$
  \end{passumptions}

  Use \Cref{tr:state-qe} on \Cref{goal:exprbacktranslation:beg:wrapper:correct:stateeq} giving goals:
  \begin{goals}
    \setcounter{enumi}{4}
    \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:cfstateeq} $\xlangstateeq[]{\cfstate}{\cfstate}$
    \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:memstateeq} $\xlangstateeq[\delta;\src{L'}]{\memstate'}{\memstate}$
  \end{goals}
  \Cref{goal:exprbacktranslation:beg:wrapper:correct:cfstateeq} follows by \Cref{asm:exprbacktranslation:beg:wrapper:correct:cfstateeq}.

  Note that $\src{\memstate'}=\src{H;\Delta_{1},x\mapsto\loc_{\poisoned},\Delta_{2}}$ and remember that $\src{\memstate}=\src{H;\Delta_{1},x\mapsto\loc_{\poison},\Delta_{2}}$, of which we know \Cref{asm:exprbacktranslation:beg:wrapper:correct:memstaterell}.
  So, \Cref{goal:exprbacktranslation:beg:wrapper:correct:memstateeq} follows from \Thmref{lem:locinL:poisondoesntmatter}, which needs \Cref{asm:exprbacktranslation:beg:wrapper:correct:linL}.
  Now \Cref{goal:exprbacktranslation:beg:wrapper:correct:traceeq}.
  First apply \Cref{tr:ignore-cons-trace-eq}, given that $\src{Dealloc\ \loc}\in\src{X'}$.
  What is left to show is:
  \begin{goals}
    \setcounter{enumi}{6}
    \item\label[goal]{goal:exprbacktranslation:beg:wrapper:correct:eventeq} $\xlangtraceeq[\delta;\src{X'}]{Ret\ \comptoctx\ \interfacevalue}{Ret\ \comptoctx\ \interfacevalue}$
  \end{goals}
  \Cref{goal:exprbacktranslation:beg:wrapper:correct:eventeq} follows by \Cref{tr:cons-trace-eq,tr:ret-event-eq,tr:empty-trace-eq}.
\end{proof}

\begin{lemma}[Middle of Backtranslation Correctness]\label{lem:exprbacktranslation:mid:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item $\exect{\Omega}{e}{\Omega'}{e'}{\trace}$
  \item\label[ass]{asm:exprbacktranslation:mid:correct:backtrans} $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trace}=\Game',\trg{\overline{\loc'}},\src{e}$
  \item\label[ass]{asm:exprbacktranslation:mid:correct:nonint} $\vdash\trg{\trace}\operatorname{ non-int-}\trg{\trace}$
  \item\label[ass]{asm:exprbacktranslation:mid:correct:staterel} $\xlangbackstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
%  \item $\src{\library}=\left\{\src{main}\mapsto\src{e_{main}}\right\}\src{\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item\label[goal]{goal:exprbacktranslation:mid:correct:execs} $\exec{\src{\Omega}}{\src{K[e]}}{\src{\commlib;\library;\kontstack;\memstate'}}{\src{K[42]}}{\src{\trace}}$
  \item\label[goal]{goal:exprbacktranslation:mid:correct:staterel} $\xlangbackstateeq[\delta;\src{L}]{\Omega'}{\src{\commlib;\library;\kontstack;\memstate'}}$
  \item\label[goal]{goal:exprbacktranslation:mid:correct:tracerel} $\src{\trace}\thexlangtraceeq[\delta;\src{X}]\trg{\trace}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
  Induction on $\trg{\trace}$.

  \begin{description}
  \item \textbf{Case $\trg{\trace}=\trg{\hole{\cdot}}$}

  Invert \Cref{asm:exprbacktranslation:mid:correct:backtrans} to obtain:
  \begin{passumptions}{H}
    \item $\src{e}=\src{42}$
    \item $\Game'=\Game$
    \item $\trg{\overline{\loc'}}=\trg{\overline{\loc}}$
  \end{passumptions}

  Instantiate our goals with:
  \begin{passumptions}{H}
    \setcounter{enumi}{3}
    \item $\src{\trace}=\src{\hole{\cdot}}$
    \item $\src{\memstate'}=\src{\memstate}$
  \end{passumptions}

  \Cref{goal:exprbacktranslation:mid:correct:execs} follows by reflexivity.

  \noindent Use \Cref{asm:exprbacktranslation:mid:correct:staterel} to solve \Cref{goal:exprbacktranslation:mid:correct:staterel}.

  \noindent For \Cref{goal:exprbacktranslation:mid:correct:tracerel}, use \Cref{tr:empty-trace-eq}.

  \item \textbf{Case $\trg{\trace}=\trg{\event\cdot\trace}$:}
  All cases are similar, regardless of the shape of $\trg{\event}$, so we won't do a separate case analysis on all of these.

  In fact, inverting \Cref{asm:exprbacktranslation:mid:correct:backtrans} gives:
  \begin{passumptions}{H}
    \item\label[ass]{asm:exprbacktranslation:mid:correct:indu0:backtrans} $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{\trace}=\Game',\trg{\overline{\loc'}},\src{e}$
  \end{passumptions}
  Inverting \Cref{asm:exprbacktranslation:mid:correct:nonint}:
  \begin{passumptions}{H}
    \setcounter{enumi}{3}
    \item\label[ass]{asm:exprbacktranslation:mid:correcd:indu0:noninte} $\vdash\trg{\event}\operatorname{non-int-\trg{\event}}$
    \item\label[ass]{asm:exprbacktranslation:mid:correcd:indu0:nonintt} $\vdash\trg{\trace}\operatorname{non-int-\trg{\trace}}$
  \end{passumptions}

  The induction hypothesis is:

          \noindent
  If $\forall \trg{\Omega_{\IH}}\ \trg{\commlib_{\IH}}\ \trg{\library_{\IH}}\ \trg{\library_{ctx}^{\IH}}\ \trg{\kontstack_{\IH}}\ \trg{\memstate^{\IH}}\ \trg{\Omega'_{\IH}}\ \trg{e_{\IH}}\ \trg{\finalexprnoerr_{\IH}}\ \trg{\overline{\loc_{\IH}}}\ \trg{\overline{\loc_{\IH}'}}\ \src{\Omega_{\IH}}\ \src{\commlib_{\IH}}\ \src{\library_{\IH}}\ \src{\library_{ctx}^{\IH}}\ \src{\library_{comp}^{\IH}}\ \src{\kontstack_{\IH}}\ \src{\memstate_{\IH}}\ \src{e_{\IH}}\ \src{L}\ \delta_{\IH}\ \Game_{\IH}\ \Game_{\IH}',$
  \begin{assumptions}
  \item $\trg{\Omega_{\IH}}=\trg{\commlib_{\IH};\library_{\IH};\kontstack_{\IH};\memstate_{\IH}}$
  \item $\trg{\library_{\IH}}=\trg{\library_{ctx}^{\IH}\linker}\mmlAmmlAtcomp{\library_{comp}^{\IH}}$
  \item $\trg{\commlib_{\IH}}=\mmlAmmlAtcomp{\commlib_{\IH}}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}^{\IH}}$
  \item $\exect{\Omega_{\IH}}{e_{\IH}}{\Omega'_{\IH}}{\finalexprnoerr_{\IH}}{\trace}$
  \item $\mmlAmmlAtback[\Game_{\IH},\trg{\overline{\loc_{\IH}}}]{\trace}=\Game_{\IH}',\trg{\overline{\loc_{\IH}'}},\src{e_{\IH}}$
  \item $\vdash\trg{\trace}\operatorname{non-int-\trg{\trace}}$
  \item $\xlangbackstateeq[\delta_{\IH};\src{L_{\IH}}]{\Omega_{\IH}}{\Omega_{\IH}}$
  \item $\src{\Omega_{\IH}}=\src{\commlib_{\IH};\library_{\IH};\kontstack_{\IH};\memstate_{\IH}}$
  \item $\src{\library_{\IH}}=\src{\library_{ctx}^{\IH}\linker\library_{comp}^{\IH}}$
  \end{assumptions}
  then $\exists \src{\trace}\ \src{\memstate'}$,
  \begin{goals}
  \item $\exec{\src{\Omega_{\IH}}}{\src{e_{\IH}}}{\src{\configs'}}{\src{\finalexprnoerr}}{\src{\trace}}$
  \item $\xlangbackstateeq[\delta]{\Omega'_{\IH}}{\commlib;\library;\kontstack;\memstate'}$
  \item $\src{\trace}\thexlangtraceeq[\delta']\trg{\trace}$
  \end{goals}
  \Cref{asm:exprbacktranslation:mid:correct:indu0:backtrans,asm:exprbacktranslation:mid:correct:indu0:nonintt} may now be used to discharge the inductive hypothesis.

  \end{description}
\end{incompleteproof}

\clearpage
\begin{lemma}[Backtranslation Correctness of $\trg{Call\ \ctxtocomp}$]\label{lem:exprbacktranslation:end:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
  \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:kontstack} $\trg{\kontstack}=\trg{K'^{bar}_{\ctxtocomp},\kontstack'}$
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item $\exect{\Omega}{K\hole{call\ foo\ \interfacevalue}}{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}{\color{black}\mmlAmmlAtcomp{e_{foo}}}{Call\ \ctxtocomp\ foo\ \interfacevalue}$
  \item $\mmlAmmlAtbackdetail[\Game,\trg{\overline{\loc}}]{Call\ \ctxtocomp\ foo\ \interfacevalue}=\Game',\trg{\overline{\loc'}},\src{let\ z = new\ 42\ in\ call\ foo\ }\mmlAmmlAtbackv{\interfacevalue}$
  \item\label[ass]{lem:exprbacktranslation:end:wrapper:correct:backstateeq} $\xlangbackstateeq{\Omega}{\Omega}$
  \item $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item $\src{let\ foo\ y:\type_{\color{black}\lambda}:=e_{foo}}\in\src{\library_{comp}}$
  \setcounter{enumi}{9}
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
%  \item $\src{\library}=\left\{\src{main}\mapsto\src{e_{main}}\right\}\src{\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \src{L'}\ \src{X'}\ \src{\trace}\ \src{\memstate'}\ \src{\gamma}$,
  \begin{goals}
%  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:deltasubset} $\delta\subseteq\delta'$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:Lsubset} $\src{L}\subseteq\src{L'}$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:Xsubset} $\src{X}\subseteq\src{X'}$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:execs} $\exec{\src{\Omega}}{\src{K[let\ x = new\ 42\ in\ call\ foo\ }\mmlAmmlAtbackv{\interfacevalue}\src{]}}{\src{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate'}}{\src{e_{foo}\gamma}}{\src{\trace}}$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:stateeq} $\xlangstateeq[\delta;\src{L'}]{\src{\commlib;\library;\kontstack;\memstate'}}{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate}$
  \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:traceeq} $\src{\trace}\thexlangtraceeq[\delta;\src{X'}]\trg{Call\ \ctxtocomp\ foo\ \interfacevalue}$
  \end{goals}
\end{lemma}
\begin{proof}
  First, we unfold the source memory state:
  \begin{passumptions}{H}
    \item $\src{\memstate} = \src{H;\Delta}$
  \end{passumptions}
  Now, let $\src{\loc}$, $\src{z}$, and $\src{\interfacevalue}$ such that:
  \begin{passumptions}{H}
    \setcounter{enumi}{1}
    \item $\fresh{\src{\Delta}}{\src{\loc}}$
    \item $\src{z}=\trg{z}$
    \item $\fresh{\src{\Delta}}{\src{z}}$
    \item $\src{\interfacevalue} = \mmlAmmlAtbackv{\interfacevalue}$
  \end{passumptions}
  Next, we instantiate the existentials in the goals as follows:
  \begin{passumptions}{H}
    \setcounter{enumi}{5}
%    \item $\delta' = \delta \cup \left\{\src{\loc}\mapsto\trg{z}\right\}$
    \item $\src{L'} = \src{L} \cup \left\{\src{\loc}\right\}$
    \item $\src{X'} = \src{X} \cup \left\{\src{Alloc\ \loc\ 42}\right\}$
    \item $\src{\trace} = \src{Alloc\ \loc\ 42\cdot Call\ \ctxtocomp\ foo\ \interfacevalue}$
    \item $\src{\memstate'} = \underbrace{\src{0,\cdots,0}}_{42-times}\src{,H;z\mapsto\loc,\Delta}$
    \item $\src{\gamma} = \src{[}\mmlAmmlAtbackv{\interfacevalue}\src{/y]}$
  \end{passumptions}
  %\Cref{goal:exprbacktranslation:end:wrapper:correct:deltasubset,}
  \Cref{goal:exprbacktranslation:end:wrapper:correct:Lsubset,goal:exprbacktranslation:end:wrapper:correct:Xsubset} follow easily.
  For \Cref{goal:exprbacktranslation:end:wrapper:correct:execs}, first use \Cref{tr:w-e-ectx,tr:w-e-let-new}:
  \begin{passumptions}{H}
    \setcounter{enumi}{9}
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:execs0} $\exec{\src{\Omega}}{\src{K[let\ x = new\ 42\ in\ call\ foo\ }\mmlAmmlAtbackv{\interfacevalue}\src{]}}{\src{\commlib;\library;\kontstack;\memstate'}}{\src{K[call\ foo\ }\mmlAmmlAtbackv{\interfacevalue}\src{]}}{\src{Alloc\ \loc\ 42}}$
  \end{passumptions}
  Next, case analysis on the structure of $\trg{\interfacevalue}$.
  Say $\trg{\interfacevalue}=\trg{\loc^{y}}$, then use \Cref{tr:w-e-ectx-call-loc}, given that we have a $\src{\loc^{y}}$ where $\delta\left(\src{\loc^{y}}\right)=\trg{\loc^{y}}$ and $\src{\Delta}=\src{\Delta_{1},z\mapsto\loc^{y},\Delta_{2}}$\MK{extract this info from relation between $\Game$ and $\delta/\src{\Delta}$}:
  \begin{passumptions}{H^a}
    \setcounter{enumi}{10}
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:execs1a} $\exec{\src{\commlib;\library;\kontstack;\memstate'}}{\src{K[call\ foo\ z]}}{\src{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate'}}{\src{e_{foo}[z/y]}}{\src{Call\ \ctxtocomp\ foo\ z}}$
  \end{passumptions}
  In the other case $\trg{\interfacevalue}=\trg{\valueexpr}$, use \Cref{tr:w-e-ectx-call-value}:
  \begin{passumptions}{H^b}
    \setcounter{enumi}{10}
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:execs1b} $\exec{\src{\commlib;\library;\kontstack;\memstate'}}{\src{K[call\ foo\ \valueexpr]}}{\src{\commlib;\library;K^{foo}_{\comptoctx},\kontstack;\memstate'}}{\src{e_{foo}[\valueexpr/y]}}{\src{Call\ \ctxtocomp\ foo\ z}}$
  \end{passumptions}
  Use \Cref{asm:exprbacktranslation:end:wrapper:correct:execs0,asm:exprbacktranslation:end:wrapper:correct:execs1a} on \Cref{tr:ws-e-trans-important} to get exactly what \Cref{goal:exprbacktranslation:beg:wrapper:correct:execs} wants us to prove.
  Likewise in the other case, use \Cref{asm:exprbacktranslation:end:wrapper:correct:execs0,asm:exprbacktranslation:end:wrapper:correct:execs1b} on \Cref{tr:ws-e-trans-important} to get exactly what \Cref{goal:exprbacktranslation:beg:wrapper:correct:execs} wants us to prove.

  Invert \Cref{lem:exprbacktranslation:end:wrapper:correct:backstateeq}:
  \begin{passumptions}{H}
    \setcounter{enumi}{11}
    \item $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
    \item $\trg{\Omega}=\trg{\commlib;\library;\kontstack;\memstate}$
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:cfstateeq} $\xlangbackstateeq[]{\cfstate}{\cfstate}$
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:memstateeq} $\xlangbackstateeq{\memstate}{\memstate}$
  \end{passumptions}
  Invert \Cref{asm:exprbacktranslation:end:wrapper:correct:cfstateeq}:
  \begin{passumptions}{H}
    \setcounter{enumi}{15}
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:lib} $\xlangstateeq[]{\library}{\library}$
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:kontsqe} $\xlangbackstateeq[]{\kontstack}{\kontstack}$
  \end{passumptions}
  Invert \Cref{asm:exprbacktranslation:end:wrapper:correct:memstateeq}
  \begin{passumptions}{H}
    \setcounter{enumi}{17}
    \item $\trg{\memstate}=\trg{H;\Delta}$
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:hdeltaeq} $\xlangstateeq[]{H;\Delta}{H;\Delta}$
  \end{passumptions}

  Apply \Cref{tr:state-eq} on \Cref{goal:exprbacktranslation:end:wrapper:correct:stateeq}:
  \begin{goals}
    \setcounter{enumi}{4}
    \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:hdeltaeq} $\xlangstateeq[\delta;\src{L'}]{{\color{black}\underbrace{\src{0,\dots,0}}_{42-times}},H;z\mapsto\loc,\Delta}{H;\Delta}$
    \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:cfstateeq} $\xlangstateeq[]{\commlib;\library;K^{foo}_{\ctxtocomp},\kontstack}{\commlib;\library;K^{foo}_{\ctxtocomp},\kontstack}$
  \end{goals}
  Use \Cref{tr:cons-ignore-memstate-eq} on \Cref{goal:exprbacktranslation:end:wrapper:correct:hdeltaeq}, since $\src{\loc}\in\src{z\mapsto\loc,\Delta}$:
  \begin{goals}
    \setcounter{enumi}{6}
    \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:42skip} $\underbrace{\src{0,\dots,0}}_{\text{42-times}}\src{,H}\vdash^{42}_{\operatorname{skip}}\src{H}$
    \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:hdeltaeq2} $\xlangstateeq[\delta;\src{L'}]{H;\Delta}{H;\Delta}$
  \end{goals}
  \Cref{goal:exprbacktranslation:end:wrapper:correct:42skip} follows by computation.

  \noindent\Cref{goal:exprbacktranslation:end:wrapper:correct:hdeltaeq2} can be resolved by \Cref{asm:exprbacktranslation:end:wrapper:correct:hdeltaeq}.

  \noindent Apply \Cref{tr:cfstate-eq} on \Cref{goal:exprbacktranslation:end:wrapper:correct:cfstateeq}:
  \begin{goals}
    \setcounter{enumi}{8}
    \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:lib} $\xlangstateeq[]{\library}{\library}$
    \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:konts} $\xlangstateeq[]{K^{foo}_{\ctxtocomp},\kontstack}{K^{foo}_{\ctxtocomp},\kontstack}$
  \end{goals}
  \Cref{goal:exprbacktranslation:end:wrapper:correct:lib} is resolved by \Cref{asm:exprbacktranslation:end:wrapper:correct:lib}.

  \noindent Apply \Cref{tr:cons-kontstack-eq} to \Cref{goal:exprbacktranslation:end:wrapper:correct:konts}, leaving us with:
  \begin{goals}
    \setcounter{enumi}{10}
    \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:konts2} $\xlangstateeq[]{\kontstack}{\kontstack}$
  \end{goals}
  Invert \Cref{asm:exprbacktranslation:end:wrapper:correct:kontsqe}:
  \begin{passumptions}{H}
    \setcounter{enumi}{19}
    \item\label[ass]{asm:exprbacktranslation:end:wrapper:correct:kontstackk} $\xlangstateeq[]{\kontstack}{\kontstack}$
  \end{passumptions}
  Note that the other cases don't apply, since they contradict \Cref{asm:exprbacktranslation:end:wrapper:correct:kontstack}.
  Anyhow, \Cref{asm:exprbacktranslation:end:wrapper:correct:kontstackk} can now be used to solve \Cref{goal:exprbacktranslation:end:wrapper:correct:konts2}.

  \noindent Lastly, apply \Cref{tr:ignore-cons-trace-eq} on \Cref{goal:exprbacktranslation:end:wrapper:correct:traceeq}, given that $\src{Alloc\ \loc\ 42}\in\src{X'}$.
  What is left to show is:
  \begin{goals}
    \setcounter{enumi}{6}
    \item\label[goal]{goal:exprbacktranslation:end:wrapper:correct:eventeq} $\xlangtraceeq[\delta;\src{X'}]{Call\ \ctxtocomp\ foo\  \interfacevalue}{Call\ \ctxtocomp\ foo\ \interfacevalue}$
  \end{goals}
  \Cref{goal:exprbacktranslation:end:wrapper:correct:eventeq} follows by \Cref{tr:cons-trace-eq,tr:call-event-eq,tr:empty-trace-eq}.
\end{proof}

\begin{lemma}[Backtranslation Correctness of $\trg{End}$]\label{lem:exprbacktranslation:vend:wrapper:correct}
  If
  \begin{assumptions}
  \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
  \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
  \item $\exect[]{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{K\hole{return\ n}}{\commlib;\library;\hole{\cdot};\memstate}{n}{End\ n}$
  \item\label[ass]{lem:exprbacktranslation:vend:wrapper:correct:backtrans} $\mmlAmmlAtbackdetail[\Game,\trg{\hole{\cdot}}]{End\ n}=\Game,\trg{\hole{\cdot}},\src{n}$
  \item\label[ass]{lem:exprbacktranslation:vend:wrapper:correct:neq} $\src{n}=\mmlAmmlAtbackv{n}$
  \item\label[ass]{lem:exprbacktranslation:vend:wrapper:correct:backstateeq} $\xlangbackstateeq{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}$
  \item $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
  \end{assumptions}
  Then
  \begin{goals}
  \item\label[goal]{lem:exprbacktranslation:vend:wrapper:correct:execs0} $\exec{\src{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}}{\src{K[return\ n]}}{\src{\commlib;\library;\hole{\cdot};\memstate}}{\mmlAmmlAtbackv{n}}{\src{End\ n}}$
  \item\label[goal]{lem:exprbacktranslation:vend:wrapper:correct:stateeq} $\xlangstateeq{\src{\commlib;\library;\hole{\cdot};\memstate}}{\commlib;\library;\hole{\cdot};\memstate}$
  \item\label[goal]{lem:exprbacktranslation:vend:wrapper:correct:traceeq} $\src{End\ n}\thexlangeventeq\trg{End\ n}$
  \end{goals}
\end{lemma}
\begin{proof}
  \Cref{lem:exprbacktranslation:vend:wrapper:correct:execs0} follows immediately from \Cref{tr:w-e-ectx-ret-value}.
  For \Cref{lem:exprbacktranslation:vend:wrapper:correct:stateeq}, invert \Cref{lem:exprbacktranslation:vend:wrapper:correct:backstateeq}:
  \begin{passumptions}{F}
    \item\label[ass]{lem:exprbacktranslation:vend:wrapper:correct:lollimem} $\xlangbackstateeq{\memstate}{\memstate}$
    \item\label[ass]{lem:exprbacktranslation:vend:wrapper:correct:lollicf} $\xlangbackstateeq{\commlib;\library;\hole{\cdot}}{\commlib;\library;\hole{\cdot}}$
  \end{passumptions}
  Invert \Cref{lem:exprbacktranslation:vend:wrapper:correct:lollimem}:
  \begin{passumptions}{F}
    \setcounter{enumi}{2}
    \item\label[ass]{asm:exprbacktranslation:vend:wrapper:correct:memstateeq} $\xlangstateeq{\memstate}{\memstate}$
  \end{passumptions}
  Apply \Cref{tr:state-eq} to \Cref{lem:exprbacktranslation:vend:wrapper:correct:stateeq}, giving:
  \begin{passumptions}{(ii)}
    \item\label[goal]{goal:exprbacktranslation:vend:wrapper:correct:memstateeq} $\xlangstateeq{\memstate}{\memstate}$
    \item\label[goal]{goal:exprbacktranslation:vend:wrapper:correct:cfstateeq} $\xlangstateeq{\commlib;\library;\hole{\cdot}}{\commlib;\library;\hole{\cdot}}$
  \end{passumptions}
  \Cref{goal:exprbacktranslation:vend:wrapper:correct:memstateeq} is fulfilled by \Cref{asm:exprbacktranslation:vend:wrapper:correct:memstateeq}.
  Invert \Cref{lem:exprbacktranslation:vend:wrapper:correct:lollimem}:
  \begin{passumptions}{F}
    \setcounter{enumi}{3}
    \item\label[ass]{asm:exprbacktranslation:vend:wrapper:correct:libeq} $\xlangstateeq[]{\library}{\library}$
    \item $\xlangbackstateeq[]{\hole{\cdot}}{\hole{\cdot}}$
  \end{passumptions}
  \noindent
  \Cref{goal:exprbacktranslation:vend:wrapper:correct:cfstateeq} follows from \Thmref{lem:cfeq:refl}, which uses \Cref{asm:exprbacktranslation:vend:wrapper:correct:libeq}.
  With \Cref{lem:exprbacktranslation:vend:wrapper:correct:neq} we can finish with \Cref{tr:end-event-eq} on \Cref{lem:exprbacktranslation:vend:wrapper:correct:traceeq}.
\end{proof}

% \begin{lemma}[Subtoplevel Backtranslation Correctness]\label{lem:subtop:backtranslation:correct}
%   If
%   \begin{assumptions}
%   \item $\exect{\Omega}{e}{\Omega'}{\finalexprnoerr}{\trace}$
%   \item $\mmlAmmlAtback[\Game,\trg{\overline{\loc}}]{\event[\comptoctx]\cdot\trace\cdot\event[\ctxtocomp]}=\Game',\trg{\overline{\loc'}},\src{e_{1}},\src{e_{2}},\src{e_{3}}$
%   \item $\xlangstateeq{\Omega}{\Omega}$
%   \end{assumptions}
%   then $\exists \delta'\ \src{\Omega'}\ \src{\trace}\ \src{X'}\ \src{L'}$,
%   \begin{goals}
%   \item $\delta\subseteq\delta'$
%   \item $\exec{\configs}{\src{e_{1}}}{\src{\configs_{1}}}{\src{\finalexprnoerr_{1}}}{\src{\trace[_{1}]}}$
%   \item $\exec{\src{\configs_{1}}}{\src{e_{2}}}{\src{\configs_{2}}}{\src{\finalexprnoerr_{2}}}{\src{\trace[_{2}]}}$
%   \item $\exec{\src{\configs_{2}}}{\src{e_{3}}}{\src{\configs_{3}}}{\src{\finalexprnoerr_{3}}}{\src{\trace[_{3}]}}$
%   \item $\xlangstateeq[\delta';\src{L'}]{\Omega'}{\Omega'}$
%   \item $\src{\trace}\thexlangtraceeq[\delta';\src{X'}]\trg{\trace}$
%   \end{goals}
% \end{lemma}
% \begin{incompleteproof}
% \end{incompleteproof}

\begin{lemma}[Backtranslation Correctness]\label{lem:backtranslation:correct}
  If
  \begin{assumptions}
  \item\label[ass]{asm:backtrans:correct:exect0} $\exect{\Omega}{call\ main\ 0}{\Omega'}{\finalexprnoerr}{\trace}$
  \item\label[ass]{asm:backtrans:correct:backtrans} $\mmlAmmlAtback[\Game]{\trace}=\Game',\src{\library_{ctx}}$
  \item\label[ass]{asm:backtrans:correct:initstaterel} $\xlangstateeq[\emptyset;\src{\emptyset}]{\Omega}{\Omega}$
  \item $\trg{\Omega}=\trg{foo,\hole{\cdot};\library;\hole{\cdot};\hole{\cdot};\hole{\cdot}}$
  \item\label[ass]{asm:backtrans:correct:omegais} $\src{\Omega}=\src{\commlib;\library;\kontstack;\memstate}$
  \item\label[ass]{asm:backtrans:correct:srclinks} $\src{\library}=\src{\library_{ctx}\linker\library_{comp}}$
  \end{assumptions}
  then $\exists \delta'\ \src{L'}\ \src{X'}\ \src{\Omega'}\ \src{\trace}$,
  \begin{goals}
  \item $\delta\subseteq\delta'$
  \item $\exec{\configs}{\src{call\ main\ 0}}{\src{\configs'}}{\mmlAmmlAtbackv[\Game']{\finalexprnoerr}}{\src{\trace}}$
  \item $\xlangstateeq[\delta';\src{L'}]{\Omega'}{\Omega'}$
  \item $\src{\trace}\thexlangtraceeq[\delta';\src{X'}]\trg{\trace}$
  \end{goals}
\end{lemma}
\begin{incompleteproof}
  Inverting \Cref{asm:backtrans:correct:backtrans} gives:
  \begin{passumptions}{H}
    \item\label[ass]{asm:backtrans:correct:traceeq0} $\trg{\trace} = \trg{Start\cdot\trace[_{0}]\cdot Call\ \ctxtocomp\ foo\ \interfacevalue_{0}\cdot\trace[_{comp}]\cdot Ret\ \comptoctx\ \interfacevalue_{1}\cdot\trace[_{1}]\cdot End\ \interfacevalue_{2}}$
    \item $\vdash\trg{\trace[^{comp}]}\operatorname{non-int-\trg{\trace}}$
    \item\label[ass]{asm:backtrans:correct:subtop1} $\mmlAmmlAtbackctxtocomp[\Game,\trg{\hole{\cdot}}]{Start\cdot\trace[_{0}]\cdot Call\ \ctxtocomp\ foo\ \interfacevalue_{0}} = \Game',\trg{\overline{\loc}},\src{e_{0}},\src{e_{0}'},\src{let\ x_{0} = new\ n_{0}\ in\ e_{0}''}$
    \item\label[ass]{asm:backtrans:correct:subtop2} $\mmlAmmlAtbackcomptoctx[\Game',\trg{\overline{\loc}}]{Ret\ \comptoctx\ \interfacevalue_{1}\cdot\trace[_{1}]\cdot End\ \interfacevalue_{2}} = \Game'',\trg{\hole{\cdot}},\src{e_{1}},\src{e_{1}'},\src{let\ x_{1} = new\ n_{1}\ in\ e_{1}''}$
    \item $\src{e}=\src{e_{0};e_{0}';let\ x_{0}=new\ n_{0}\ in\ \left(e_{0}'';e_{1}\right);e_{1}';let\ x_{1} =new\ n_{1}\ in\ e_{1}''}$
    \item $\src{\library_{ctx}}=\src{let\ main\ x:\nat\to\nat:=e,\hole{\cdot}}$
  \end{passumptions}
  Inverting \Cref{asm:backtrans:correct:subtop1}:
  \begin{passumptions}{H}
    \setcounter{enumi}{6}
    \item $\vdash\trg{\trace[_{0}]}\operatorname{non-int-\trg{\trace}}$
    \item $\mmlAmmlAtbackcomptoctx[\Game,\trg{\hole{\cdot}}]{Start} = \Game_{0},\trg{\overline{\loc_{0}}}, \src{e_{0}}$
    \item $\mmlAmmlAtback[\Game_{0},\trg{\overline{\loc_{0}}}]{\trace[_{0}]} = \Game_{0}',\trg{\overline{\loc_{0}'}}, \src{e_{0}'}$
    \item $\mmlAmmlAtbackctxtocomp[\Game_{0}',\trg{\overline{\loc_{0}'}}]{Call\ \ctxtocomp\ foo\ \interfacevalue_{0}} = \Game',\trg{\overline{\loc}}, \src{let\ x_{0}=new\ n_{0}\ in\ e_{0}''}$
  \end{passumptions}
  Inverting \Cref{asm:backtrans:correct:subtop2}:
  \begin{passumptions}{H}
    \setcounter{enumi}{10}
    \item $\vdash\trg{\trace[_{1}]}\operatorname{non-int-\trg{\trace}}$
    \item $\mmlAmmlAtbackcomptoctx[\Game',\trg{\overline{\loc}}]{Ret\ \comptoctx\ \interfacevalue_{1}} = \Game_{1},\trg{\overline{\loc_{1}}}, \src{e_{1}}$
    \item $\mmlAmmlAtback[\Game_{1},\trg{\overline{\loc_{1}}}]{\trace[_{1}]} = \Game_{1}',\trg{\overline{\loc_{1}'}}, \src{e_{1}'}$
    \item $\mmlAmmlAtbackctxtocomp[\Game_{1}',\trg{\overline{\loc_{1}'}}]{End\ \interfacevalue_{2}} = \Game'',\trg{\hole{\cdot}}, \src{let\ x_{1}=new\ n_{1}\ in\ e_{1}''}$
  \end{passumptions}
  By transitivity on \Cref{asm:backtrans:correct:exect0} and noting \Cref{asm:backtrans:correct:traceeq0}:
  \begin{passumptions}{H}
    \setcounter{enumi}{14}
    \item $\trg{\trace}=\trg{Start\cdot\trace[_{a}]}$
    \item $\exect[]{\Omega}{call\ main\ 0}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_{0}}{Start}$
    \item $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_{0}}{\Omega'}{\finalexprnoerr}{\trace[_{a}]}$
  \end{passumptions}

  Invert \Cref{asm:backtrans:correct:initstaterel}:
  \begin{passumptions}{H}
    \setcounter{enumi}{17}
    \item $\src{\Omega}=\src{\cfstate;\memstate}$
    \item $\trg{\Omega}=\trg{\cfstate;\memstate}$
    \item\label[ass]{asm:backtrans:correct:cfstaterel} $\xlangstateeq[]{\cfstate}{\cfstate}$
    \item\label[ass]{asm:backtrans:correct:memstaterel} $\xlangstateeq[\emptyset;\src{\emptyset}]{\memstate}{\memstate}$
  \end{passumptions}
  Subsequently inverting \Cref{asm:backtrans:correct:cfstaterel}:
  \begin{passumptions}{H}
    \setcounter{enumi}{21}
    \item $\src{\cfstate}=\src{\commlib;\library;\kontstack}$
    \item $\trg{\cfstate}=\trg{foo,\hole{\cdot};\library;\hole{\cdot}}$
    \item\label[ass]{asm:backtrans:correct:libeq} $\xlangstateeq[]{\library}{\library}$
    \item\label[ass]{asm:backtrans:correct:kontstack} $\xlangstateeq[]{\kontstack}{\hole{\cdot}}$
  \end{passumptions}
  Inverting \Cref{asm:backtrans:correct:kontstack}:
  \begin{passumptions}{H}
    \setcounter{enumi}{25}
    \item $\src{\kontstack}=\src{\hole{\cdot}}$
  \end{passumptions}
  Similarily, inverting \Cref{asm:backtrans:correct:memstaterel} and noting that $\trg{\memstate}=\trg{\hole{\cdot};\hole{\cdot}}$:
  \begin{passumptions}{H}
    \setcounter{enumi}{26}
    \item $\src{\memstate}=\src{\hole{\cdot};\hole{\cdot}}$
  \end{passumptions}
  Use \Cref{asm:backtrans:correct:libeq} to conclude:
  \begin{passumptions}{H}
    \setcounter{enumi}{27}
    \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
    \item $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\mmlAmmlAtcomp{\library_{comp}}$
  \end{passumptions}

  {\Large\color{green}TODO}


  \noindent Now use \Thmref{lem:exprbacktranslation:vbeg:wrapper:correct} to get
  \begin{passumptions}{H}
    \item $\execs{\Omega}{call\ main\ 0}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{main}}{\trace}$
    \item\label[ass]{asm:backtrans:correct:backstaterel0} $\xlangbackstateeq[\emptyset;\src{L}]{\Omega}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}$
    \item $\src{\trace}\thexlangtraceeq[\emptyset;\src{X}]\trg{Call\ \comptoctx\ main}$
  \end{passumptions}

  By inverting the first backtranslation sufficiently, we see that $\src{e_{0}}=\src{42}$, so we can get rid of it in the sequence, because executing the underlying $\src{let}$ produces unobservable events.
  Using \Cref{asm:backtrans:correct:initstaterel,asm:backtrans:correct:omegais,asm:backtrans:correct:srclinks}, we can conclude $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$ and $\trg{\commlib}=\mmlAmmlAtcomp{\commlib}=\operatorname{dom}\mmlAmmlAtcomp{\library_{comp}}$.\MK{technical lemma}

  By transitivity and inversion\MK{technical lemma making use of $\vdash\trg{\trace[_{0}]}\operatorname{non-int-\trg{\trace}}$},\\ $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\hole{\cdot};\hole{\cdot}}{e_{0}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_1}{\trace[_{0}]}$ and\\ $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_1}{\Omega'}{\finalexprnoerr}{\trace[_b]}$, where $\trg{\trace[_{a}]}=\trg{\trace[_{0}]\cdot\trace[_{b}]}$.

  With \Cref{asm:backtrans:correct:backstaterel0}, we can use \Thmref{lem:exprbacktranslation:mid:wrapper:correct} to obtain:
  \begin{passumptions}{H}
    \setcounter{enumi}{3}
    \item $\emptyset\subseteq\delta_{0}$
    \item $\execs{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{K\hole{e_{0}'}}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K\hole{42}}{\trace[_{0}]}$
    \item $\xlangbackstateeq[\delta_{0};\src{L}]{\Omega_{0}}{\commlib;\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}$
    \item $\src{\trace[_{0}]}\thexlangtraceeq[\delta_{0};\src{L}]\trg{\trace[_{0}]}$
  \end{passumptions}

  Note that $\trg{\trace[_{b}]}=\trg{Call\ \ctxtocomp\ foo\ \interfacevalue_{0}\cdot\trace[_{c}]}$, so by inversion on the execution we know $\trg{e_{1}}=\trg{K'\hole{call\ foo\ \interfacevalue_{0}}}$.
  Thus, by transitivity and inversion, $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{1}}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{foo}}{Call\ \ctxtocomp\ foo\ \interfacevalue_{0}}$ and\\ $\exect{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{foo}}{\Omega'}{\finalexprnoerr}{\trace[_c]}$.
  By the fact that $\trg{foo}\in\trg{\commlib}$, we have $\trg{foo}\in\operatorname{dom}\mmlAmmlAtcomp{\library_{comp}}$ and thus $\trg{e_{foo}}=\mmlAmmlAtcomp{e_{foo}}$, where $\src{let\ foo\ x:\type_{\color{black}\lambda}:=e_{foo}}\in\src{\library_{comp}}$.
  We are ready to apply \Thmref{lem:exprbacktranslation:end:wrapper:correct}:
  \begin{passumptions}{H}
    \setcounter{enumi}{7}
    \item $\delta_{0}\subseteq\delta_{1}$
    \item $\src{L}\subseteq\src{L'}$
    \item $\src{X}\subseteq\src{X'}$
    \item $\execs{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{K'[let\ x=new\ 42\ in\ call\ foo\ {\color{black}\mmlAmmlAtback{\interfacevalue_{0}}}]}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{e_{foo}}{\trace[_{1}]}$
    \item $\xlangstateeq[\delta_{1};\src{L'}]{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}$
    \item $\src{\trace[_{1}]}\thexlangtraceeq[\delta_{1};\src{X'}]\trg{Call\ \ctxtocomp\ foo\ \interfacevalue_{0}}$
  \end{passumptions}
  By transitivity and inversion\MK{technical lemma},\\$\exect{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate}{e_{foo}}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K_{component}\hole{return\ \interfacevalue_{1}}}{\trace[_{comp}]}$ and\\ $\exect{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K_{component}\hole{return\ \interfacevalue_{1}}}{\Omega'}{\finalexprnoerr}{\trace[_c]}$, where $\trg{\trace[_{b}]}=\trg{\trace[_{comp}]\cdot\trace[_{c}]}$.

  With this, we can use\MK{well-typedness of $\src{\library_{comp}}$ is missing} \Thmref{lem:component:correctness} to get:
  \begin{passumptions}{H}
    \setcounter{enumi}{13}
    \item $\delta_{1}\subseteq\delta_{2}$
    \item $\execs{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{e_{foo}}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K_{component}\hole{return\ \interfacevalue_{1}}}{\trace[_{comp}]}$
    \item $\xlangstateeq[\delta_{2};\src{L'}]{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}$
    \item $\src{\trace[_{comp}]}\thexlangtraceeq[\delta_{2};\src{X'}]\trg{\trace[_{comp}]}$
  \end{passumptions}

  By transitivity and inversion,\\$\exect{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K_{component}\hole{return\ \interfacevalue_1}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K'\hole{\interfacevalue_{1}}}{Ret\ \comptoctx\ \interfacevalue_1}$ and\\ $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K'\hole{\interfacevalue_{1}}}{\Omega'}{\finalexprnoerr}{\trace[_d]}$, where $\trg{\trace[_{c}]}=\trg{Ret\ \comptoctx\ \interfacevalue_1\cdot\trace[_{d}]}$.

  Note that $\src{K'}=\src{\hole{\cdot};delete\ z;e_1';e_1''}$
  Now, use \Thmref{lem:exprbacktranslation:beg:wrapper:correct}\MK{check constraint about $\src{K^{foo}}$}:
  \begin{passumptions}{H}
    \setcounter{enumi}{17}
    \item $\delta_2\subseteq\delta_3$
    \item $\src{L'}\subseteq\src{L''}$
    \item $\src{X'}\subseteq\src{X''}$
    \item $\execs{foo,\hole{\cdot};\library;K'^{foo}_{\comptoctx},\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K_{component}\hole{return\ \interfacevalue_1}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{delete\ z;e_1';e_1''}{\trace[_{2}]}$
    \item $\xlangbackstateeq[\delta_3;\src{L''}]{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}$
    \item $\src{\trace[_2]}\thexlangtraceeq[\delta_3;\src{X''}]\trg{Ret\ \ctxtocomp\ \interfacevalue_1}$ \MK{the wrapper should be eaten away in the lemmas}
  \end{passumptions}

  And again, by transitivity and inversion,\\$\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'}{K'\hole{\interfacevalue_1}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K''\hole{return\ \interfacevalue_{2}}}{\trace[_1]}$ and\\ $\exect{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K''\hole{return\ \interfacevalue_{2}}}{\Omega'}{\finalexprnoerr}{Ret\ \ctxtocomp\ \interfacevalue_2}$, where $\trg{\trace[_{d}]}=\trg{\trace[_1]\cdot Ret\ \ctxtocomp\ \interfacevalue_2}$.

  This allows us to use \Thmref{lem:exprbacktranslation:mid:wrapper:correct}:
  \begin{passumptions}{H}
    \setcounter{enumi}{23}
    \item $\delta_3\subseteq\delta_4$
    \item $\execs{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{K''\hole{e_1'}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'''}{K''\hole{42}}{\trace[_{3}]}$
    \item $\xlangbackstateeq[\delta_4;\src{L''}]{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'''}$
    \item $\src{\trace[_3]}\thexlangtraceeq[\delta_4;\src{X''}]\trg{\trace[_1]}$
  \end{passumptions}

  Finally, we use \Thmref{lem:exprbacktranslation:vend:wrapper:correct}:\MK{argue that $\src{K''\hole{42}}=\src{K'''\hole{return\ \interfacevalue_{2}}}$}
  \begin{passumptions}{H}
    \setcounter{enumi}{27}
    \item $\delta_{4}\subseteq\delta_{5}$
    \item $\src{L''}\subseteq\src{L'''}$
    \item $\src{X''}\subseteq\src{X'''}$
    \item $\execs{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate'''}{K'''\hole{return\ \interfacevalue_{2}}}{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''''}{\interfacevalue_{2}}{\trace[_{4}]}$
    \item $\xlangstateeq[\delta_{5};\src{L'''}]{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''''}{\Omega'}$
    \item $\src{\trace[_4]}\thexlangtraceeq[\delta_{4};\src{X'''}]\trg{Ret\ \ctxtocomp\ \interfacevalue_{2}}$
  \end{passumptions}

  Stitching everything together, we can conclude by instantiating the goal with $\delta_{5},\src{L'''},\src{X'''}, \src{\trace[_{0}]\cdot\trace[_{1}]\cdot\trace[_{2}]\cdot\trace[_{3}]\cdot\trace[_{4}]}$ and for $\src{\Omega'}$ choose $\src{foo,\hole{\cdot};\library;\hole{\cdot}^{main}_{\ctxtocomp},\hole{\cdot};\memstate''''}$.
  The goals follow by composition and monotonicity.\MK{flesh this out in detail}
\end{incompleteproof}

\begin{scontents}[store-env=buffer]
  If
  \begin{assumptions}
  \item\label[ass]{asm:rtmsp:srctms} $\forall \src{\library_{ctx}}\ \src{\library_{comp}}\ \src{\trace}\ \src{\Omega}\ \src{v}, \wexecs{prog\ \library_{ctx}\ \library_{comp}}{\configs}{\finalexpr}{\trace}\rightarrow\texttt{TMS}(\tospecificevs[_{\emptyset}]{\trace})$
  \item\label[ass]{asm:rtmsp:trgexec} $\wexec{\trg{prog\ \library_{ctx}\ }\mmlAmmlAtcomp{\library_{comp}}}{\trg{\configt}}{\trg{\finalexpr}}{\trg{\trace}}$
  \end{assumptions}
  then
  \begin{goals}
  \item\label[goal]{rtmsp:tms} $\texttt{TMS}(\tospecificevt[_{\emptyset}]{\trace})$
  \end{goals}
\end{scontents}

\realthm{thm:rtmsp}{4}{Robust \gls{tms} Preservation}
\begin{proof}
  Suppose $\trg{\finalexpr}=\trg{\valueexpr}$.\MK{rework}
  Invert \Cref{asm:rtmsp:trgexec}:
  \begin{passumptions}{H}
    \item $\trg{\library}=\trg{\library_{ctx}\linker}\mmlAmmlAtcomp{\library_{comp}}$
    \item $\trg{\commlib}=\operatorname{dom}\ \mmlAmmlAtcomp{\library_{comp}}$
    \item\label[ass]{rtmsp:runt} $\exec{\mmlAmmlAtcomp{\commlib}\trg{;\library;\emptyset;\emptyset;\emptyset}}{\trg{call\ main\ 0}}{\trg{\Omega}}{\trg{\valueexpr}}{\trg{Call\ \comptoctx\ main\ 0\cdot\trace'\cdot Ret\ \ctxtocomp\ \interfacevalue}}$
    \item $\trg{\trace}=\trg{Start\cdot\trace'\cdot End\ \interfacevalue}$
  \end{passumptions}

  We backtranslate $\mmlAmmlAtbackdetail[\emptyset]{\trace}=\Game,\src{let\ main\ z\ := e}$.
  By assumption with respect to the number of calls done, we can decompose $\trg{\trace}$ into\\$\trg{Call\ \comptoctx\ main\ 0\cdot\trace[^{ctx}_{0}]\cdot Call\ \ctxtocomp\ foo\ n\cdot\trace[^{comp}]\cdot Ret\ \comptoctx\ m\cdot\trace[^{ctx}_{1}]\cdot Ret\ \ctxtocomp\ n'}$ such that $\vdash\trg{\trace[^{comp}]}\ \operatorname{non-int-\trg{trace}}$, $\vdash\trg{\trace[^{ctx}_{0}]}\ \operatorname{non-int-\trg{trace}}$, and $\vdash\trg{\trace[^{ctx}_{1}]}\ \operatorname{non-int-\trg{trace}}$.

  Thus, $\trg{foo}\in\mmlAmmlAtcomp{\library_{comp}}$, $\src{foo}\in\src{\library_{comp}}$, and $\trg{main}\in\trg{\library_{ctx}}$.\MK{technical inversion lemma on traces}
  Let $\src{\library_{ctx}}=(\src{let\ main\ z\ := e})\src{,\hole{\cdot}}$.
  Let $\src{\library} = \src{\library_{ctx}\linker\library_{comp}}$ which follows by inverting $\trg{\library_{ctx}\linker\library_{comp}}$.
  Let $\src{\Gamma_0}=\src{\library}\downarrow$ and note that $\src{main}\in\operatorname{dom}\src{\Gamma_0}$.
  We need to verify that $\src{\Gamma_0}\vdash\src{\library}\operatorname{ok}$ to conclude $\vdash\src{prog\ \library_{ctx}\ \library_{comp}}\dashv\src{\library},\operatorname{dom}\src{\library_{comp}}$.
  This follows from \Thmref{lem:backtranslation:welltyped}.
  By \Cref{tr:state-eq,tr:empty-memstate-eq,tr:cfstate-eq,tr:empty-commlib-eq,tr:cons-commlib-eq,tr:empty-kontstack-eq}, we have $\xlangstateeq{\commlib;\library;\emptyset;\emptyset;\emptyset}{{\color{black}\mmlAmmlAtcomp{\commlib}};\library;\emptyset;\emptyset;\emptyset}$.
  Using these facts, we apply \Thmref{lem:backtranslation:correct} on \Cref{rtmsp:runt}, crucially giving us a $\mmlAs$ execution that yields $\src{\trace}$ such that $\xlangtraceeq{\trace}{\trace}$.
  Finally, use \Cref{lem:traceagreement:with:filter} on \Cref{rtmsp:tms} and follow with \Cref{asm:rtmsp:srctms}, whose assumptions are satisfied by the results we got from applying backtranslation correctness.
\end{proof}

\myfig{
  \begin{center}
    \begin{tikzpicture}[state/.style={minimum height=0.6cm}]
      % relative horizontal/vertical distance between states
      \pgfmathsetmacro{\hdist}{0.85}
      \pgfmathsetmacro{\vdist}{1.25}
      \pgfmathsetmacro{\halfvdist}{0.625}

      % row of src states
      \node[state] (srcempty) {$\src{\emptyset}$};
      \foreach \s [remember=\s as \cur (initially empty)] in {1,w_1,p,w_2,2} {
        \node[state,right=\hdist of src\cur] (src\s) {$\src{\Omega_{\s}}$};
      }
      % row of trg states
      \node[state,below=\vdist of srcempty] (trgempty) {$\trg{\emptyset}$};
      \foreach \s in {1,w_1,p,w_2,2} {
        \node[state,below=\vdist of src\s] (trg\s) {$\trg{\Omega_{\s}}$};
      }
      %% illustrations
        % backtrans wrapper 1
        \draw[thick,loosely dotted,Peach!50,rounded corners] (src1.north east) -- (srcw\string_1.north east)
          -- (trgw\string_1.south east) -- (trg1.south west) -- (src1.north west) -- cycle;
        % backtrans wrapper 2
        \draw[thick,loosely dotted,Peach!50,rounded corners] (srcp.north east) -- (srcw\string_2.north east)
          -- (trgw\string_2.south east) -- (trgp.south west) -- (srcp.north west) -- cycle;
        % compiler correctness
        \draw[thick,loosely dashed,Emerald!50,rounded corners] ($(srcw\string_1.north east)+(0,0.05)$) -- ($(srcp.north east)+(0,0.05)$)
          -- ($(trgw\string_2.north east)+(0.05,0)$) -- ($(trgw\string_2.south east)+(0.05,-0.05)$)
          -- ($(trg1.south west)+(-0.05,-0.05)$) -- ($(trg1.north west)+(-0.05,0)$) -- ($(srcw\string_1.north west)+(0,0.05)$) -- cycle;
      % state relations
      \path (srcempty) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_\emptyset$} (trgempty)
        (src1) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_1}$} (trg1)
        (srcp) edge[draw=gray!25] node[pos=0.5,sloped,fill=white] {\scriptsize$\approx_{\delta_p}$} (trgp)
        (src2) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_2}$} (trg2)
        (srcw\string_1) edge[draw=gray!25] node[pos=0.5,sloped,fill=white] {\scriptsize$\approx_{\delta_{w_1}}$} (trgw\string_1)
        (srcw\string_2) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_{w_2}}$} (trgw\string_2)
        % diagonals
        (srcw\string_1) edge[draw=gray!25] node[pos=0.16,sloped,rotate=180,fill=white] {\scriptsize$\approx_{\delta_{w_1}}$} (trg1)
        (src1) edge[draw=gray!25] node[pos=0.16,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_1}$} (trgw\string_1)
        (srcp) edge[draw=gray!25] node[pos=0.2,sloped,fill=white] {\scriptsize$\approx_{\delta_p}$} (trgw\string_2)
        (trgp) edge[draw=gray!25] node[pos=0.2,sloped,fill=white] {\scriptsize$\multimap_{\delta_{w_2}}$} (srcw\string_2)
        ;
      %\drawpolygon src1,srcw\string_1,trgw\string_1,trg1;
      %\drawpolygon srcp,srcw\string_2,trgw\string_2,trgp;
      %\node[font=\tiny,align=center,above=0.2 of srcw1srcp] (wrapper) {Backtranslation\\Wrapper};
      %\path[->,draw] (wrapper) -- (srcw\string_1);
      %\path[->,draw] (wrapper) -- (srcp);
      % steps
      \path[color=\stlccol] (srcempty) edge[draw=none] node {\ $\xrightarrow{\trace[_1]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (src1)
        (src1) edge[draw=none] node {\ $\xrightarrow{\trace[_c]}{}{\kern-3.5pt}_{\text{ctx}}$} (srcw\string_1)
        (srcw\string_1) edge[draw=none] node {\ $\xrightarrow{\trace[_p]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (srcp)
        (srcp) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\trace[_r]}{}{\kern-3.5pt}_{\text{ctx}}$} (srcw\string_2)
        (srcw\string_2) edge[draw=none] node {\ $\xrightarrow{\trace[_2]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (src2)
        ;
      \path[color=\ulccol] (trgempty) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\phantom{\trace[_1]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trg1)
        (trg1) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgw\string_1)
        (trgw\string_1) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgp)
        (trgp) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgw\string_2)
        (trgw\string_2) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_2]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trg2)
        ;
      % legend
      \node[align=left,below right=0.3 and 0.3 of trgempty,font=\tiny] (legend) {%
        $\xlangtraceeqn{\src{\trace[_c]}}{\mmlAmmlAtback[]{Call\ ?\finalexprnoerr_i}}$\\%
        $\xlangtraceeqn{\src{\trace[_r]}}{\mmlAmmlAtback[]{Ret\ !\finalexprnoerr_o}}$
        };
      \draw[thick,loosely dotted,Peach!50,rounded corners] ($(legend.north east)+(0.5,-0.4)$) -- ($(legend.north east)+(1,-0.4)$);
      \node at ($(legend.north east)+(1.5,-0.4)$) (legendwrapper) {};
      \node[right of=legendwrapper] {\tiny Backtranslation Wrapper};
      \draw[thick,loosely dashed,Emerald!50,rounded corners] ($(legend.south east)+(0.5,0.4)$) -- ($(legend.south east)+(1,0.4)$);
      \node at ($(legend.south east)+(1.5,0.4)$) (legendcorrectness) {};
      \node[right of=legendcorrectness] {\tiny Compiler Correctness};
    \end{tikzpicture}
  \end{center}
}{rtmsp-sketch}{Sketch of the proof of \Thmref{thm:rtmsp}. %
  Arrows in the horizontal direction are the usual step relations, but the term is omitted for aesthetic purposes. %
  Likewise for the emitted target-level traces. %
  Trace $\src{\trace[_1]}$ starts with $\src{Ret\ !0}$ and $\src{\trace[_2]}$ ends with $\src{Call\ ?\valueexpr}$, where $\src{\valueexpr}$ is the final result of the program. %
  Target states $\trg{\Omega_1}$ and $\trg{\Omega_{w_1}}$ are exactly equal, so are $\trg{\Omega_p}$ and $\trg{\Omega_{w_2}}$. They are drawn for aesthetic purposes.}

\cleardoublepage

\bibliographystyle{plain}
\bibliography{library}

\end{document}
