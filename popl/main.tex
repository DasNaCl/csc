%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.


% Fixing: Too many math alphabets used in version normal.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\documentclass[utf8,acmsmall,review,screen,dvipsnames]{acmart}

\usepackage[colorinlistoftodos]{todonotes}
\usepackage[inference]{semantic}
\usepackage{fontawesome5}
\usepackage{listofitems}
\usepackage{glossaries}
\usepackage{cleveref}
\usepackage{stmaryrd}
\usepackage{marvosym}
\usepackage{listings}
\usepackage{xspace}
\usepackage{xfrac}
\usepackage{tikz}
\usepackage{soul}
\usepackage{bm}

\setul{0.5ex}{0.3ex}

% https://tex.stackexchange.com/questions/648845/sans-serif-uppercase-greek-no-longer-showing-in-acmart
\DeclareMathAlphabet{\mathsf}{OT1}{LibertinusSans-LF}{m}{n}
\SetMathAlphabet{\mathsf}{bold}{OT1}{LibertinusSans-LF}{bx}{n}

\DeclareMathAlphabet{\mathtt}{OT1}{lmtt}{m}{n}
\SetMathAlphabet{\mathtt}{bold}{OT1}{lmtt}{bx}{n}

\input{cmds.tex}

\loadglsentries{acronyms}
\makeglossaries

%% NOTE that a single column version may be required for 
%% submission and peer review. This can be done by changing
%% the \doucmentclass[...]{acmart} in this template to 
%% \documentclass[manuscript,screen]{acmart}
%% 
%% To ensure 100% compatibility, please check the white list of
%% approved LaTeX packages to be used with the Master Article Template at
%% https://www.acm.org/publications/taps/whitelist-of-latex-packages 
%% before creating your document. The white list page provides 
%% information on how to submit additional LaTeX packages for 
%% review and adoption.
%% Fonts used in the template cannot be substituted; margin 
%% adjustments are not allowed.
%%
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2024}
\acmYear{2024}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[POPL '24]{Make sure to enter the correct
  conference title from your rights confirmation emai}{June 03--05,
  2018}{Woodstock, NY}
%
%  Uncomment \acmBooktitle if th title of the proceedings is different
%  from ``Proceedings of ...''!
%
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%  June 03--05, 2018, Woodstock, NY} 
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Secure Composition of Robust and Optimising Compilers}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Matthis Kruse}
% \authornote{Both authors contributed equally to this research.}
\email{matthis.kruse@cispa.de}
\orcid{0000-0003-4062-9666}
\affiliation{%
  \institution{CISPA Helmholtz Center for Information Security and Saarland University}
  \streetaddress{Stuhlsatzenhaus 5}
  \city{Saarbr{\"u}cken}
  \state{Saarland}
  \country{Germany}
  \postcode{66123}
}

\author{Michael Backes}
\email{director@cispa.de}
%\orcid{0000-0002-7130-9211}
\affiliation{%
  \institution{CISPA Helmholtz Center for Information Security}
  \streetaddress{Stuhlsatzenhaus 5}
  \city{Saarbr{\"u}cken}
  \state{Saarland}
  \country{Germany}
  \postcode{66123}
}

\author{Marco Patrignani}
\orcid{0000-0003-3411-9678}
\email{marco.patrignani@unitn.it}
\affiliation{%
  \institution{University of Trento}
  \streetaddress{Via Sommarive, 9}
  \city{Povo}
  \country{Italy}
  \postcode{38123}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Kruse, Backes, and Patrignani}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  \hltt{abstract}

\begin{center}\small\it
	{This paper uses syntax highlighting accessible to both colourblind and black \& white readers~\citep{patrignani2020use}.
	Specifically, it makes use of a $\src{blue}$, $\src{sans\text{-}serif}$ font for a $\src{source}$,
	a $\trg{red}$, $\trg{bold}$ font for an $\trg{intermediate}$,
	and a $\obj{green}$, $\obj{teletype}$ font for a $\obj{target}$ language.
	}
\end{center}
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
  <concept>
  <concept_id>10002978.10002986.10002989</concept_id>
  <concept_desc>Security and privacy~Formal security models</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
</ccs2012>
\end{CCSXML}
\ccsdesc[500]{Security and privacy~Formal security models}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Memory-safety, Secure Compilation, Privacy}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction\pages{4}}

\hltt{Context}
\hltt{Problem}

\begin{lstlisting}[language=c,basicstyle=\small\ttfamily, caption=C]
int strncpy(int n, int *x, int *y) {
  for(int i = 0; x[i] != '\0' && i < n; ++i) {
    y[i] = x[i];
  }
}
\end{lstlisting}

\BrText{Solution}{
% keyword: pass
This paper introduces a framework for reasoning about the composition of secure and optimising compiler passes and it showcases the power of this framework by instantiating it on a multi-pass compilation chain.
To this end, this paper first discusses how to compose security properties, such as temporal and spatial memory safety into general memory safety, and cryptographic constant time.
Then, this paper defines several secure compiler passes, where each is either preserving a different security property (e.g., temporal or spatial memory safety) or performing a security-preserving optimisation, (e.g., applying constant-folding or dead-code elimination).
% keyword- end to end, composition
Finally, this paper shows how to compose these secure compiler passes into a multi-pass compilation chain which is proven to provide end-to-end preservation of general memory safety and cryptographic constant time.
Crucially, this end-to-end security preservation is obtained by having each compilation pass (i) preserve a sub-part of the overall security property individually and then (ii) compose each preserved security property as dictated by the framework of this paper.
The results showcase how the framework allows the kind of formal security reasoning that compiler writers already want (and do), obtaining precise, compositional security reasoning while providing minimal (and modular) proof effort.
\MPin{
	last line: not the best.
}
}

% \BrText{Validation}{
In summary, this paper makes the following contributions:

\begin{itemize}
  \item %
        %\Cref{sec:compprop} presents a formal framework to reason about compositions of security properties and demonstrate its usage with concrete examples:
        First, this paper studies the formalisation and the composition of security properties (\Cref{sec:compprop}) by focussing on those safety properties that are of interest for real-world compiler writers (as identified by the plethora of work enforcing such properties individually~\MP{cits}).
        % 
        Starting from ways to formalise and enforce those properties individually, this paper shows how to compose both their formalisation and their composition.
        % 
        This paper then showcases the benefits of this composition by composing \gls{tms} and \gls{sms} into \gls{ms}, and ultimately adding \gls{cct} to the composition, yielding the the conjunction of \gls{ms} and \gls{cct}.
        % 
        The resulting security property is the golden standard of safety properties that secure cryptographic code should have~\MP{cits}.
        \MPin{
        	conclude that did this prop in a single pass, we show how to do it compositionally
        }
        %For each of these properties, we also give a monitor which runs on another trace model that excludes unneccessary information and show that their composition is behaviorally similar to the composition of the trace-based security properties.
        %This two-level approach enhances modularity: When working with the security properties, one only needs to reason about the corresponding monitor.
        %%% let's omit above sentences completely. why ramble about monitors in the introduction? this ain't about model checking

  \item %
        %\Cref{sec:compcomp} studies different forms of secure compiler compositions.
        This paper takes the secure compilation framework of~\citep{abate2019jour} and extends it to reason about the security of all different known forms of compiler composition (\Cref{sec:compcomp}).
        %Concretely, it investigates upper and lower compositions, as well as the sequential composition.
        For this, this paper studies \MP{}.
        % 
        This paper proves that starting from two compilers that preserve two properties, their composition preserves the intersection of those properties.
        \MPin{
       		find way to connect to previous contrib
        }
        % 
        Finally, this paper provides a simple but crucial corollary that demonstrates that the order of composition of sequential compiler passes is irrelevant for the resulting security.
        % 
        This corollary is crucial for reordering compiler optimisation passes as well as secure compilation passes and thus generating secure and efficient code.

  \item %
        % \Cref{sec:casestud} sets up a case-study to demonstrate the power of our formal framework.
        This paper presents a case-study showcasing the conjunction of the previous contributions (\Cref{sec:casestud}).
        %We define several different languages and compilers between them and prove that the compilers are robustly preserving different properties.
        To this end, it presents a compilation chain consisting of several passes.
        %The sequential composition of these compilers yields a compilation chain that is optimizing and robustly preserving a combination of \gls{ms} and \gls{cct}.
        The chain ultimately preserves a combination of \gls{ms} and \gls{cct} by means of composing the individual, secure passes concerning \gls{tms}, \gls{sms}, and \gls{scct}, respectively.
        %As for optimizations, the chain has two passes, one performing \gls{cf} and the other \gls{dce}.
        Furthermore, the chain includes two passes for \gls{ms}\MKin{maybe patch \gls{ms} when optimizing passes are done} that are optimizing: One performs a simple \gls{dce} and the other \gls{cf}.
        %This compilation chain demonstrates the ability to perform modular proof engineering by leaveraging this paper's compositionality theorems.
        This demonstrates that the usage of the presented framework is both simpler and more expressive compared to one monolithic security proof of the whole compilation chain.
        \MP{ matthis please write your idea here }

  \item The key contributions are formalized in the Coq proof assistant.
        The practically relevant parts of the formalization are \emph{extractable}.
        That is, one can translate the Coq code to Ocaml and run the compilation chain from the previous contribution.
        Finally, this paper indicates with \CoqSymbol whenever definitions or proofs are done in Coq.
\end{itemize}
% }

%In \Cref{sec:background}, the paper establishes the notions of traces, (hyper-)properties, and robust preservation, while \Cref{sec:relwork} compares this work with others.
This paper starts by introducing relevant notions of security properties and secure compilation (\Cref{sec:background}),
%We conclude in \Cref{sec:concl} and give an outlook for future work.
and discusses related work (\Cref{sec:relwork}) before concluding (\Cref{sec:concl}).

\contribution{Open Source \& Technical Report} A technical report and the Coq formalisation are available as supplementary material.\MKin{cite/link}


\section{Background: Security Properties and Secure Compilers\pages{1}}\label{sec:background}

To introduce the security argument of this paper, this section first presents the concepts of (security) properties, of their satisfaction, and of their robust satisfaction (i.e., satisfaction in the presence of an active attacker; \Cref{subsec:bg:tprop}).
Then, borrowing from existing work~\cite{abate2019jour,abate2021extacc,patrignani2021rsc}, the section introduces secure compilers as compilers that preserve robust property satisfaction (\Cref{subsec:bg:rtp}).

\subsection{Properties and (Robust) Satisfaction}\label{subsec:bg:tprop}

This paper employs the security model where programs are written in a language whose semantics emits events $\event$.
Events include security--relevant actions (e.g., reading from and writing to memory) and the unobservable event $\emptyevent$.
As programs execute, their emitted events are concatenated in traces $\trace$, which serve as the description of the behaviour of a program.%
\footnote{
Throughout the paper, we denote empty sequences with $\hole{\cdot}$ and concatenate sequences $\trace[_{1}],\trace[_{2}]$ as $\trace[_{1}]\cdot\trace[_{2}]$.
Prepending elements to sequences uses the same notation: $\event\cdot\trace$.
}

Properties $\pi$ are sets of traces of admissible program behaviours, ascribing what said property considers valid.\MP{ cit }
%
% make this intuition formally precise, however, they rely on a trace model.
% {\em Traces} ($\trace$) are (possibly infinite) sequences of {\em events} ($\event$).
% Events are an abstract representation of observable actions, in this paper
% The empty event ($\emptyevent$) is an unobservable (or unimportant) action.
% A property $\pi$ is a set of admissable traces and 
%Properties and partitioned in the subsets of safety and liveness\MP{cit}, and given their central role for security, this paper focusses on safety properties.
The set of all properties can be partitioned into different {\em classes} ($\class$), i.e., safety, liveness, and neither safety or liveness.\MP{cit}
Given the central role for security, this paper focusses on safety properties.
Note that there are other classes $\class$ that contain more domain-specific properties, such as the class of memory safety properties.
For the class of safety properties, it is decidable wether a trace admits such a property with just a finite trace prefix.
As an example, consider a trace that starts with an interaction with memory where a deallocation precedes a read: $\ev{Dealloc\ \loc}\cdot\ev{Read\ \loc\ 1729}\cdot\dots$
This program behaviour is insecure, because it reads from a memory location that was freed already.
The finite trace prefix $\ev{Dealloc\ \loc}\cdot\ev{Read\ \loc\ 1729}$ is enough to decide that the trace does not satisfy the property ,,no use after dealloc'' and there is no way to append events to this prefix which would result in the trace being admissible.
%Given a safety property, a finite prefix of a longer trace $\trace$ is enough to decide whether a trace is admitted or not by the property.
%For example, given the trace $\ev{Send\ 1}\cdot\ev{Recv\ 1}\cdot\ev{Send\ 2}\cdot\dots$ and the property $\pi=\left\{\trace \mid \trace=\hole{\cdot} \text{ or } \trace=\ev{Send\ n}\cdot\ev{Recv\ 2n}\cdot\trace[']\wedge \trace[']\in\pi\right\}$, the prefix $\ev{Send\ 1}\cdot\ev{Recv\ 1}$ immediately violates $\pi$.
%\MP{mention send and recv before already. replace with read/write to contextualise to memory?}
%
% The set of security properties is one of many classes of properties ($\class$).
% Note that existing literature refers to classes of properties as hyperproperties~\cite{clarkson2008hyper}.
% The framework developed in this paper relies on {\em liftings} ($\lift{\pi}$), which are simply the powerset of a property $\pi$ and thus also considered as a class.
% This framework is concerned about the secure compilation of programs that admit properties.
%\MPin{
%	this par does not flow.
%	what is the point?
%}
%
% A program ($\runtimetermvar$) is a tuple consisting of some dynamic state ($\statevar$) and a syntactic description ($\progvar$).
% Programs without free variables are considered {\em whole}.
% Contrary, they are {\em partial} if they contain variables without an accompanying definition.
% Whole programs can be run with the multi-step relation $\stepto{\runtimetermvar}{\runtimetermvar[']}{\trace}$ and yield a trace $\trace$.
% Moreover, the paper assumes for such executions that $\runtimetermvar[']$ is {\em final}, decided by the judgement $\isval{\runtimetermvar}$.
% Partial programs cannot be executed, since execution would get stuck when reaching an undefined variable.
% The paper also uses other step-relations, such as a single-step ($\stepto[]{\runtimetermvar[_{1}]}{\runtimetermvar[_{2}]}{\event}$) and an $n$-step relation ($\stepton{\runtimetermvar[_{1}]}{\runtimetermvar[_{2}]}{\trace}$) that performs $n$ single-steps.
% Note that the multi-step relation presented earlier is defined as-standard using the single-step, where the reflexive case makes use of $\isval{\runtimetermvar}$.
% All multi-step relations filter $\emptyevent$ events.
%\MPin{
%	all unnecessary.
%	unused notation, not needed for sec2, for sec3 and for sec 4.
%	also i don't agree with what a program is.
%}

%Given a whole program $\progvar$, i.e., a program without free variables, the {\em behaviour} ($\behav{\progvar}$) is the set containing all traces the program can emit during execution according to its language semantics.
%This paper only considers deterministic languages, where the behavior $\behav{\runtimetermvar}$ is a singleton set for any whole $\runtimetermvar$.
%This set is used to define property satisfaction (\Cref{def:propsat}):
\bul{Programs $\progvar$ satisfy a property $\pi$} iff \iul{$\progvar$ yields a trace $\trace$} such that \oul{$\trace$ is admissible with respect to $\pi$}.

\begin{definition}[Property Satisfaction]\label{def:propsat}
  $\progvar$ satisfies $\pi$, \bul{$\sat{\progvar}{\pi}$}, iff \iul{running $\progvar$ gives $\trace$} where \oul{$\trace\in\pi$}.
\end{definition}

Given a partial program $\progvar$, i.e., a program with free variables, the execution of $\progvar$ would get stuck due to the lack of definitions.
%As described earlier, partial programs cannot be executed \MP{not true anymore, need to define the notion of partial programs} , because they lack definitions and, thus, get stuck.
To remedy this, {\em linking} takes two partial programs $\progvar[_{1}],\progvar[_{2}]$ and produces a new whole program $\link{\progvar[_{1}]}{\progvar[_{2}]}$.
%Note that linking is not defined on programs, but merely on their syntactic descriptions, since programs contain dynamic state.\MP{ not terminology i really want to use, nor is defined}
As typically done in secure compilation~\cite{abate2019jour}, \MP{others do this too, parametricity results e.g.} this paper assumes that programs are the result of linking a {\em context} ($\ctx$) and a {\em component} ($\comp$).
% \MP{just introduce the notion of contexts}
%       MK: why only contexts?
%The component part of a whole program is the main object of interest and thus a known syntactic description.
The context is usually arbitrary\footnote{Up to, e.g., provoking link failure by giving multiple definitiions for the same name.} and thus has the role of an {\em attacker} that can interact with the component by means of whatever features the programming language has.
The semantics of the programming language is expected to differentiate between the component and the context.
%\MP{and say the semantics is expected (passive, hah) to differentiate between prg and ctx}
%%                                         -> why passive?
So, the context interacts in some way with the component and this interaction models an attacker.
With this, \Thmref{def:propsat} can be extended as follows.
For \bul{programs $\progvar$ to robustly satisfy a property $\pi$}, take an \iul{attacker $\contextvar$ and link it with $\progvar$}, \oul{the result of which must satisfy $\pi$}.
%The following definition extends on \Thmref{def:propsat} to cover property satisfaction under the presence of an (active, with respect to the semantics of the programming language) attacker: %, which is known as {\em robust satisfaction}:
%\MPin{missing: the context is an attacker! now, unlike before, we security property satisfaction with a clear active attacker}

\begin{definition}[Robust Satisfaction]\label{def:proprsat}
  $\progvar$ robustly satisfies $\pi$, \bul{$\rsat{\progvar}{\pi}$}, iff for \iul{any partial program $\contextvar$} it holds that \oul{$\sat{\link{\contextvar}{\runtimetermvar}}{\pi}$}.
\end{definition}

\subsection{Secure Compilers}\label{subsec:bg:rtp}

A {\em compiler} ($\cc{\src{L}}{\trg{L}}$) translates syntactic descriptions of programs from a {\em source} ($\src{L}$) into a {\em target} ($\trg{L}$) programming language.
%For the syntactic description of programs written in $\src{L}$, this paper writes $\src{\progvar}$, while for ones written in $\trg{L}$, this paper writes $\trg{\progvar}$.%\MP{not a fan of this sentence}
%This paper writes $\src{\progvar}$ and $\trg{\progvar}$ for programs written in $\src{L}$ and $\trg{L}$, respectively.
%      MK: I don't think we need to mention this at all
This translation is considered {\em correct} if it is semantics--preserving.
%That is, the compiler encodes any possible $\src{L}$--level feature in $\trg{L}$, such that the semantics are the same.
Unfortunately, correct compilers may be insecure compilers\MK{citation needed}.
Programs translated by insecure compilers can violate security properties that the programmer assumes to hold. %, given the presence of a context--level program.
For a compiler to be secure, this paper makes use of the robust compilation framework~\cite{abate2019jour}, which we summarize in the following definition.
For \bul{compilers $\cc{\src{L}}{\trg{L}}$ to robustly preserve a class of properties $\class$}, consider \rul{properties $\pi$ of that class $\class$ and programs $\src{p}$ written in $\src{L}$} such that \iul{the program $\src{\progvar}$ robustly satisfies $\pi$}.
Then, \oul{$\cc{\src{L}}{\trg{L}}\left(\src{p}\right)$, the compiled version of $\src{\progvar}$, must robustly satisfy $\pi$}.

\begin{definition}[Robust Preservation]\label{def:rtp}
  Compiler $\cc{\src{L}}{\trg{L}}$ robustly preserves $\class$, \bul{$\rtp{\cc{\src{L}}{\trg{L}}}{\class}$}, iff \rul{for any $\pi\in\class$ and $\src{p}$} such that \iul{$\rsat{\src{\progvar}}{\pi}$}, it holds that \oul{$\rsat{\cc{\src{L}}{\trg{L}}\left(\src{p}\right)}{\pi}$}.
\end{definition}

\section{Example Properties\pages{1.5}}\label{sec:compprop}

This section introduces a trace model (\Cref{subsec:propdefs}) and defines some example properties (\gls{tms}, \gls{sms}, \gls{ms}, and \gls{scct}).
These properties are of practical importance and also of interest in the case study (\Cref{sec:casestud:defs,sec:casestud:rtp}) this paper presents.
\subsection{Specification Trace Model}\label{subsec:propdefs}

\begin{gather*}
  \begin{aligned}
  \mi{(Security\ Tag)}~\sigma\bnfdef&\ \lock \mid \unlock\hspace{0.5cm}
  \mi{(Control\ Tag)}~\sandboxtag\bnfdef \ctx\mid\comp\hspace{0.5cm}
  \mi{(Event)}~\event\bnfdef\ \emptyevent \mid \lightning \mid \event[_{b}];\sandboxtag;\sigma \\
  \mi{(Pre\text{--}event)}&~\event[_{b}]\bnfdef\ \ev{Alloc\ \loc\ n} \mid \ev{Dealloc\ \loc} \mid \ev{Use\ \loc\ n} \mid \ev{Branch\ n} \mid \ev{Binop\ n} \\
  \end{aligned}
\end{gather*}

The specification trace model defines events as either the empty event ($\emptyevent$), a crash ($\lightning$), or as tuples consisting of a pre--event, a control--tag, and a security--tag.
The purpose of the model is to define properties, such as a stricter variant of cryptographic constant time.
To this end, security--tags indicate wether an event contains sensitive information ($\lock$) or not ($\unlock$), while control--tags state wether the context ($\ctx$) or the component ($\comp$) are responsible for emitting the event.
The latter is necessary to be able to ignore actions done by a spurious context that, e.g., immediately deallocates a memory location twice, thus violating \gls{tms}.
%Even though this could be used for blame~\cite{patrignani2023blame}, this is not what this paper is concerned about.
Lastly, pre--events describe the actual kind of event that happened.
One such kind is the allocation event ($\ev{Alloc\ \loc\ n}$) that fires whenever a program claims $n$ cells of memory and stores them at address $\loc$.
Likewise, deallocation ($\ev{Dealloc\ \loc}$) announces that the object at location $\loc$ is freed.
These two events alone allow already a partial description of \gls{tms} by requiring that, e.g., there is only one deallocation event that carries a location $\loc$.
To be able to express \gls{sms}, there is also an event to describe reads from and writes to memory ($\ev{Use\ \loc\ n}$).
Finally, for cryptographic code, there is a general guideline that secrets must not be visible on a trace.
Moreover, an instruction whose timing is data--dependent must not have a secret as an operand.
Typical operations with data--dependent timing are branches and certain binary operations, such as division\footnote{This is highly architecture dependent, but division is an operation that serves as a classic example for a data--dependent timing instruction.}.
Both operations are also modelled in the specification trace model ($\ev{Branch\ n}$ and $\ev{Binop\ n}$).

\subsection{Temporal Memory Safety}

\gls{tms} is a safety property that describes that an unallocated object must not be used in any way.
Moreover, the property requires that all allocated objects must be deallocated at some point.

\begin{definition}[\glsfirst{tms}]\label{def:trace:tmsdef}
  $$
  \tmssafe:=\left\{\trace \left| \begin{array}{rcl}
                              \ev{Alloc\ \loc\ n;\sandboxtag;\securitytag}&\le_{\trace}&\ev{Dealloc\ \loc;\sandboxtag;\securitytag'} \\
                              \ev{Use\ \loc\ n;\sandboxtag;\securitytag}&\le_{\trace}&\ev{Dealloc\ \loc;\sandboxtag;\securitytag'} \\
                              \text{if }\ev{Alloc\ \loc\ n;\sandboxtag;\securitytag}\text{ in }\trace&\text{then}&\ev{Dealloc\ \loc;\sandboxtag;\securitytag'}\text{ in }\trace \\
                              \text{at most one }\ev{Dealloc\ \loc;\sandboxtag;\securitytag}&\text{in}&\trace \\
                              \text{at most one }\ev{Alloc\ \loc\ n;\sandboxtag;\securitytag}&\text{in}&\trace \\
                            \end{array}\right.\right\}
  $$
\end{definition}
Hereby, the notation $\event[_{1}]\le_{\trace}\event[_{2}]$ means that if $\event[_{1}]$ is in $\trace$ and if $\event[_{2}]$ is in $\trace$, then $\event[_{1}]$ appears before $\event[_{2}]$.

\subsection{Spatial Memory Safety}

\gls{sms} disregards out of bounds accesses:

\begin{definition}[\glsfirst{sms}]\label{def:trace:smsdef}
  $
  \smssafe:=\left\{\trace \left|\begin{array}{rcl}
                                  \text{If }\ev{Alloc\ \loc\ n;\sandboxtag;\securitytag}\le_{\trace}\ev{Use\ \loc\ m;\sandboxtag;\securitytag'}, \text{ then }m<n
                                \end{array}\right.\right\}
  $
  A trace $\trace$ is spatial memory safe ($\trace\in\smssafe$) iff given $\ev{Alloc\ \loc\ m;\sandboxtag;\securitytag}\le_{\trace}\ev{Use\ \loc\ n;\sandboxtag';\securitytag'}$, then $n<m$.
\end{definition}

\subsection{Memory Safety}

Full \gls{ms} is then described as the conjunction of \Cref{def:trace:tmsdef,def:trace:smsdef}.
Note, however, that this definition does not entail memory--safety issues introduced by side--channels, such as speculation.

\begin{definition}[\glsfirst{ms}]\label{def:trace:msdef}
  $
  \mssafe:=\left\{\trace \left|\begin{array}{rcl}
                                 \trace\in\tmssafe & \text{ and } & \trace\in\smssafe
                               \end{array}\right.\right\}
  $
  A trace $\trace$ is memory safe ($\trace\in\mssafe$) iff $\trace\in\tmssafe$ and $\trace\in\smssafe$.
\end{definition}


\subsection{Strict Cryptographic Constant Time}

\gls{cct} is a hyperproperty and, thus, not as easy to check with just monitors. %Beutner et al
Hence, the following defines \gls{scct}, a stricter variant that enforces the policy that no secret should appear on a trace.

\begin{definition}[\glsfirst{scct}]\label{def:trace:scctdef}
  $
  \scctsafe:=\left\{\trace \left|\begin{array}{rcl}
                                   \trace=\hole{\cdot} & \text{ or } & \trace=\event[_{b}];\sandboxtag;\unlock\cdot\trace['] \wedge \trace[']\in\scctsafe
                                 \end{array}\right.\right\}
  $
\end{definition}

\subsection{Memory Safe, Strict Cryptographic Constant Time}

The combination of \gls{ms} and \gls{scct} is the intersection of these properties, \gls{msscct}.
It entails all program behaviours that are both memory safe and strictly cryptographic constant time.

\begin{definition}[\glsfirst{ms} and \gls{scct}]\label{def:trace:msscctdef}
  $
  \msscctsafe:=\left\{\trace \left| \begin{array}{rcl}
                                      \trace\in\mssafe & \text{ and } & \trace\in\scctsafe
                                    \end{array}\right.\right\}
  $
\end{definition}

%\section{Monitors and Trace Agreements\pages{1.5}}\label{sec:monitors}
\section{Monitors\pages{1.5}}\label{sec:monitors}
This section introduces monitors for each of the properties presented earlier (\Cref{subsec:propdefs}).
The use of monitors is because they have some structure useful for inductive proofs, whereas traces lack this structure, thus making proofs difficult.
To lessen the burden when proving, each monitor makes use of a custom trace model that contains only the relevant information related to the property the monitor checks.
To project specification traces $\trace$ onto these monitor--level traces $\abstrace$, each property has an associated event agreement relation $\traceagree[]{\pi}{\trace}{\abstrace}$.
This relation performs the actual work of projecting the events, while the stutter--equivalence $\traceagree{\pi}{\trace}{\abstrace}$ remains the same for all properties $\pi$, yet is indexed by $\pi$ to emphasize the kind of event agreement.
With agreements, this section starts to define monitor satisfaction for traces and states that monitor satisfaction implies property satisfaction.
To this end, monitor satisfaction is defined as follows.
\bul{A specification trace $\trace$ monitor--satisfies property $\pi$} iff there exists a (final) monitor state $\monitor$ and an abstract trace $\abstrace$ such that the \iul{specification trace $\trace$ agrees with abstract trace $\abstrace$} and \oul{the initial monitor\footnote{In this paper, for all monitors, the initial monitor state is denoted as $\emptyset$.} can step to the (final) monitor state $\monitor$ with abstract trace $\abstrace$}.

\begin{definition}[Monitor Satisfaction]\label{def:monsat}
  \bul{$\monsafe{\trace}{\pi}$} iff $\exists \abstrace\ \monitor$ such that \iul{$\traceagree{\pi}{\trace}{\abstrace}$} and \oul{$\monitorcheck{\emptyset}{\monitor}{\abstrace}$}.
\end{definition}

\subsection{Monitor for \glsfirst{tms}}
\begin{gather*}
  \begin{aligned}
    \mi{(Abstract\ Store)}~\tmsmonitor\bnfdef&\ \left\{\text{allocated}:L\times\sandboxtag,\text{freed}:L\times\sandboxtag\right\} \hspace{0.33cm}%
    \emptyset:=\ \left\{\text{allocated}:\emptyset,\text{freed}:\emptyset\right\}\\
    \mi{(Abstract\ Events)}~\absevent\bnfdef&\ \absev{\emptyevent} \mid \absev{Alloc\ }\loc\ \sandboxtag \mid \absev{Dealloc\ }\loc\ \sandboxtag \mid \absev{Use\ }\loc\ \sandboxtag \mid \absterm\\
  \end{aligned}
\end{gather*}
\begin{center}
  \judgbox{\monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent}}{,,Monitor $\tmsmonitor$ does one step to $\tmsmonitor[']$ given event $\absevent$.''}$\;$\\
  %
  \typerule{tms-uninteresting}{
  }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\absev{\emptyevent}}
  }{tms-uninteresting}
  %
  \typerule{tms-abort}{
  }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\absterm}
  }{tms-abort}
  %
  \typerule{tms-use}{
    (\loc;\sandboxtag)\in\tmsmonitor.\text{allocated} &
    (\loc;\sandboxtag)\notin\tmsmonitor.\text{freed}
  }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor}{\absev{Use\ }\loc\ \sandboxtag}
  }{tms-use}
  %
  \typerule{tms-alloc}{
    (\loc;\sandboxtag)\notin\tmsmonitor.\text{allocated} &
    (\loc;\sandboxtag)\notin\tmsmonitor.\text{freed} \\
    \tmsmonitor[']=\left\{\text{allocated}: \tmsmonitor.\text{allocated}\cup\left\{(\loc;\sandboxtag)\right\},\text{freed}: \tmsmonitor.\text{freed}\right\}
  }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absev{Alloc\ }\loc\ \sandboxtag}
  }{tms-alloc}
  %
  \typerule{tms-dealloc}{
    (\loc;\sandboxtag)\in\tmsmonitor.\text{allocated} &
    (\loc;\sandboxtag)\notin\tmsmonitor.\text{freed} \\
    \tmsmonitor[']=\left\{\text{allocated}: \tmsmonitor.\text{allocated}\setminus\left\{(\loc;\sandboxtag)\right\},\text{freed}: \tmsmonitor.\text{freed}\cup\left\{(\loc;\sandboxtag)\right\}\right\}
  }{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absev{Dealloc\ }\loc\ \sandboxtag}
  }{tms-dealloc}
\end{center}

The state of the monitor is a record with two sets keeping track of allocated and deallocated locations.
%The monitor runs on a modified trace semantics with more abstract $\absev{Alloc\ }\loc$,$\absev{Dealloc\ }\loc$,$\absev{Use\ }\loc$, and $\absterm$ events, which represent {\em allocation}, {\em deallocation}, and {\em use} of a location $\loc$ as well as abnormal program termination.
\Cref{tr:tms-use} simply requires that a location is (i) allocated and (ii) not freed.
\Cref{tr:tms-alloc,tr:tms-dealloc} both require a location to not be freed already and extend the monitor state accordingly.
This restriction effectively disallows reallocation to reassign the same location to an object.
However, the definition can easily be adapted by, e.g., attaching a natural number serving as a counter.
In the reflexive case of $\monitorcheck{\tmsmonitor}{\tmsmonitor}{\absevent}$, the monitor $\tmsmonitor$ must not contain allocated locations, i.e., $\tmsmonitor.allocated=\emptyset$.
This ensures that programs do not forget to free memory.

\begin{center}
  \judgbox{\tmstraceagree[]{\event}{\absevent}}{,,Abstract event $\absevent$ is equivalent to $\event$ with respect to \gls{tms}.''}$\;$\\
  %
  \typerule{tms-alloc-authentic}{
  }{
    \tmstraceagree[]{\ev{Alloc}\ \loc\ n;\sandboxtag;\securitytag}{\absev{Alloc\ }\loc\ \sandboxtag}
  }{tms-alloc-authentic}
  %
% \typerule{tms-dealloc-authentic}{
% }{
%   \tmstraceagree[]{\ev{Dealloc}\ \loc;\sandboxtag;\securitytag}{\absev{Dealloc\ }\loc}
% }{tms-dealloc-authentic}
  %
% \typerule{tms-use-authentic}{
% }{
%   \tmstraceagree[]{\ev{Use}\ \loc\ n;\sandboxtag;\securitytag}{\absev{Use\ }\loc}
% }{tms-use-authentic}
  %
  \typerule{tms-branch-authentic}{
  }{
    \tmstraceagree[]{\ev{Branch\ }n}{\absev{\emptyevent}}
  }{tms-branch-authentic}
  %
% \typerule{tms-binop-authentic}{
% }{
%   \tmstraceagree[]{\ev{Binop\ }n}{\absev{\emptyevent}}
% }{tms-binop-authentic}
% %
% \typerule{tms-empty-authentic}{
% }{
%   \tmstraceagree[]{\emptyevent}{\absev{\emptyevent}}
% }{tms-empty-authentic}
% %
  \typerule{tms-abort-authentic}{
  }{
    \tmstraceagree[]{\lightning}{\absterm}
  }{tms-abort-authentic}
\end{center}

The trace agreement is entirely straightforward, so only allocation, branch, and crash are shown.

\begin{lemma}[Traces with Monitor Satisfaction are $\tmssafe$]\label{lem:mon:tmsafe}
  If $\montmssafe{\trace}$, then $\trace\in\tmssafe$. %\Coqed
\end{lemma}

\subsection{Monitor for \glsfirst{sms}}
\begin{gather*}
  \begin{aligned}
    \mi{(Abstract\ Store)}~\smsmonitor:=\ L\times\sandboxtag\times\mb{N}\hspace{0.33cm}&
    \mi{(Abstract\ Events)}~\absevent\bnfdef\ \absev{\varepsilon} \mid \absev{Alloc\ }\loc\ \sandboxtag\ n \mid \absev{Use\ }\loc\ \sandboxtag\ n \\
  \end{aligned}
\end{gather*}
\begin{center}
  \judgbox{\monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\absevent}}{,,Monitor $\smsmonitor$ does one step to $\smsmonitor[']$ given event $\absevent$.''}$\;$\\
  %
% \typerule{sms-uninteresting}{
% }{
%   \monitorcheck[]{\smsmonitor}{\smsmonitor}{\absev{\emptyevent}}
% }{sms-uninteresting}
% %
% \typerule{sms-abort}{
% }{
%   \monitorcheck[]{\smsmonitor}{\emptyset}{\absterm}
% }{sms-abort}
  %
  \typerule{sms-use}{
    (\loc;\sandboxtag;m)\in\smsmonitor &
    n<m
  }{
    \monitorcheck[]{\smsmonitor}{\smsmonitor}{\absev{Use\ }\loc\ \sandboxtag\ n}
  }{sms-use}
  %
  \typerule{sms-alloc}{
    (\loc;\sandboxtag;m)\notin\smsmonitor
  }{
    \monitorcheck[]{\smsmonitor}{\smsmonitor\cup\left\{(\loc;\sandboxtag;n)\right\}}{\absev{Alloc\ }\loc\ \sandboxtag\ n}
  }{sms-alloc}
\end{center}
The state of the monitor for \gls{sms} is a set containing tuples of locations, control--tags, and the allocation size.
In comparison to the trace model of the \gls{tms} monitor, the trace model here is extended by sizing and positional information.
\Cref{tr:sms-use} performs a bounds check and \Cref{tr:sms-alloc} adds bounds information to the state of the monitor.
The trace agreement is entirely straightforward and similar to the one fo \gls{tms}.
% \begin{center}
%   \judgbox{\smstraceagree[]{\event}{\absevent}}{,,Abstract event $\absevent$ is equivalent to $\event$ with respect to \gls{sms}.''}$\;$\\
%   %
%   \typerule{sms-alloc-authentic}{
%   }{
%     \smstraceagree[]{\ev{Alloc}\ \loc\ n;\sandboxtag;\securitytag}{\absev{Alloc\ }\loc\ n}
%   }{sms-alloc-authentic}
%   %
%   \typerule{sms-dealloc-authentic}{
%   }{
%     \smstraceagree[]{\ev{Dealloc}\ \loc;\sandboxtag;\securitytag}{\absev{Dealloc\ }\loc}
%   }{sms-dealloc-authentic}
%   %
%   \typerule{sms-use-authentic}{
%   }{
%     \smstraceagree[]{\ev{Use}\ \loc\ n;\sandboxtag;\securitytag}{\absev{Use\ }\loc\ n}
%   }{sms-use-authentic}
%   %
%   \typerule{sms-branch-authentic}{
%   }{
%     \smstraceagree[]{\ev{Branch\ }n}{\absev{\emptyevent}}
%   }{sms-branch-authentic}
%   %
%   \typerule{sms-binop-authentic}{
%   }{
%     \smstraceagree[]{\ev{Binop\ }n}{\absev{\emptyevent}}
%   }{sms-binop-authentic}
%   %
%   \typerule{sms-empty-authentic}{
%   }{
%     \smstraceagree[]{\emptyevent}{\absev{\emptyevent}}
%   }{sms-empty-authentic}
%   %
%   \typerule{sms-abort-authentic}{
%   }{
%     \smstraceagree[]{\lightning}{\absterm}
%   }{sms-abort-authentic}
% \end{center}


\begin{lemma}[Traces with Monitor Satisfaction are $\smssafe$]\label{lem:mon:smsafe}
  If $\monsmssafe{\trace}$, then $\trace\in\smssafe$.\Coqed
\end{lemma}

\subsection{Combining \glsfirst{tms} and \glsfirst{sms} Monitors to obtain \glsfirst{ms}}\label{subsubsec:ms}

\begin{center}
  \judgbox{\monitorcheck[]{\msmonitor}{\msmonitor[']}{\absevent}}{,,Monitor $\msmonitor$ does one step to $\msmonitor[']$ given event $\absevent$.''}$\;$\\
  \typerule{ms-step}{
    \monitorcheck[]{\tmsmonitor}{\tmsmonitor[']}{\absevent_{\tmssafe}} &
    \monitorcheck[]{\smsmonitor}{\smsmonitor[']}{\absevent_{\smssafe}} &
  }{
    \monitorcheck[]{(\tmsmonitor,\smsmonitor)}{(\tmsmonitor['],\smsmonitor['])}{(\absevent_{\tmssafe},\absevent_{\smssafe})}
  }{ms-step}
\end{center}
The combined monitor runs the one for \gls{tms} and the one for \gls{sms} in a lockstep. The trace agreement similarily just relates a specification event with an abstract \gls{tms}-event $\abstrace[_{\tmssafe}]$ and with an abstract \gls{sms}-event $\abstrace[_{\smssafe}]$.
% \begin{center}
%   \judgbox{\mstraceagree{\event}{\absevent}}{,,Abstract event $\absevent$ is equivalent to $\event$ with respect to \gls{ms}.''}$\;$\\
%   %
%   \typerule{ms-authentic}{
%     \tmstraceagree[]{\event}{\absevent_{\tmssafe}} &
%     \smstraceagree[]{\event}{\absevent_{\smssafe}}
%   }{
%     \mstraceagree[]{\event}{(\absevent_{\tmssafe},\absevent_{\smssafe})}
%   }{ms-authentic}
% \end{center}

\begin{lemma}[Traces with Monitor Satisfaction are $\mssafe$]\label{lem:mon:msafe}
  If $\monmssafe{\trace}$, then $\trace\in\mssafe$.\Coqed
\end{lemma}

\subsection{Monitor for \glsfirst{scct}}
\begin{gather*}
  \begin{aligned}
    \mi{(Abstract\ Store)}~\scctmonitor&:=\ \emptyset \hspace{0.5cm}
    \mi{(Abstract\ Events)}~\absevent:=\ \absev{\varepsilon} \mid \absterm \mid \absev{Any} \\
  \end{aligned}
\end{gather*}
\begin{center}
  \judgbox{\monitorcheck[]{\scctmonitor}{\scctmonitor[']}{\absevent}}{,,Monitor $\scctmonitor$ does one step to $\scctmonitor[']$ given event $\absevent$.''}$\;$\\
  %
  \typerule{scct-none}{
  }{
    \monitorcheck[]{\scctmonitor}{\scctmonitor}{\absev{\emptyevent}}
  }{scct-none}
  %
  \typerule{scct-abort}{
  }{
    \monitorcheck[]{\scctmonitor}{\scctmonitor}{\absterm}
  }{scct-abort}
\end{center}
The monitor state for the \gls{scct} monitor is completely empty, since it does not need to keep track of information.
As soon as any event is hit, the execution gets stuck, since any event is considered confidental from the perspective of this monitor.
\begin{center}
  \judgbox{\sccttraceagree[]{\event}{\absevent}}{,,Abstract event $\absevent$ is equivalent to $\event$ with respect to \gls{cct}.''}$\;$\\
  %
  \typerule{scct-low-authentic}{
  }{
    \sccttraceagree[]{\event[_b];\sandboxtag;\unlock}{\absev{\emptyevent}}
  }{scct-low-authentic}
  %
  \typerule{scct-high-authentic}{
  }{
    \sccttraceagree[]{\event[_b];\sandboxtag;\lock}{\absev{Any}}
  }{scct-high-authentic}
  %
  \typerule{scct-empty-authentic}{
  }{
    \sccttraceagree[]{\emptyevent}{\absev{\emptyevent}}
  }{scct-empty-authentic}
  %
  \typerule{scct-abort-authentic}{
  }{
    \sccttraceagree[]{\lightning}{\absterm}
  }{scct-abort-authentic}
\end{center}
Accordingly, the event agreement simply disregards all events that involved public data ($\unlock$) while mapping any other event that does involve private data ($\lock$) to the abstract $\absev{Any}$ event.

\begin{lemma}[Monitor Traces are $\scctsafe$]\label{lem:mon:scctsafe}
  If $\monscctsafe{\trace}$, then $\trace\in\scctsafe$. %\Coqed
\end{lemma}

\subsection{Combining \gls{ms} and \gls{scct} Monitors to obtain \gls{msscct}}

The combination of monitors for \gls{ms} and \gls{scct} yields one for \gls{msscct}.
The construction is entirely similar to the one for \gls{ms} (\Cref{subsubsec:ms}).

\begin{lemma}[Traces with Monitor Satisfaction are $\msscctsafe$]\label{lem:mon:msscctsafe}
  If $\monmsscctsafe{\trace}$, then $\trace\in\msscctsafe$. %\Coqed
\end{lemma}

\section{Composing Secure Compilers\pages{1}}\label{sec:compcomp}

This section presents the key meta-theoretic results of this paper and extends on prior work~\cite{kruse2022csc}.
A main result is that secure compilers in the robust preservation framework~\cite{abate2019jour} compose.
This is not intuitive in the sense that there are countless examples in the security domain where composition does not work.\MK{cite}
For starters, the sequential composition of compilers $\cc{\src{L}}{\trg{L}}$ and $\cc{\trg{L}}{\obj{L}}$ is as expected, i.e., given an $\src{L}$ program $\src{p}$, obtain its compiled $\obj{L}$ program by plugging $\src{p}$ into $\cc{\src{L}}{\trg{L}}\circ\cc{\trg{L}}{\obj{L}}$.
Now, given \bul{$\cc{\src{L}}{\trg{L}}$ robustly preserves $\class[_{1}]$} and \rul{$\cc{\trg{L}}{\obj{L}}$ robustly preserves $\class[_{2}]$}, it follows that \oul{their sequential composition $\cc{\src{L}}{\trg{L}}\circ\cc{\trg{L}}{\obj{L}}$ robustly preserves the intersection of classes $\class[_{1}]$ and $\class[_{2}]$}.

\begin{theorem}[Sequential Composition of Secure Compilers]\label{thm:rtp}
  Given $\class[_{1}],\class[_{2}]$, \bul{$\rtp{\cc{\src{L}}{\trg{L}}}{\class[_{1}]}$}, and \rul{$\rtp{\cc{\trg{L}}{\obj{L}}}{\class[_{2}]}$}, then \oul{$\rtp{\cc{\src{L}}{\trg{L}}\circ\cc{\trg{L}}{\obj{L}}}{\class[_{1}]\cap\class[_{2}]}$}. \Coqed
\end{theorem}

Since the composition of secure compilers is again a secure compiler, the theorem generalizes to a whole chain of $n$ secure compilers.
Pretending that the following compilers are secure, consider the compilation chain for $\src{TypeScript}$.
First, $\src{TypeScript}$ programs are translated to $\trg{JavaScript}$ which, e.g., V8\MK{cit} eventually compiles in parts to $\irl{Ignition BC}$.
Were all these compilation steps robustly secure with respect to \gls{ms}, the resulting $\irl{Ignition BC}$ code would be \gls{ms} regardless of the context the binary runs in.

Notably, real-world compilation chains also perform a series of passes whose main purpose is not necessarily to translate from one language to another, but to, e.g., optimize the code or enforce a certain property.
Both examples can be seen in the wild, there are countless instances of them.\MK{cit}
Consider the compilation passes of LLVM\MK{cit} whose source-code optimisations are industry--competitive.
In LLVM, the pass manager can be used to schedule passes in a way where the optimisations yield the best results.
Take \gls{cf} and \gls{dce}.
Unfortunately, the order in which \gls{cf} and \gls{dce} are performed influences the final result of the compilation (see \Cref{fig:cfdceex}).
This {\em phase ordering problem} is well--known in literature and a practical solution is to simply perform a fixpoint iteration.
However, this costs additional time until compilation is done, which can be a valuable resource\MK{cit}.
Hence, compiler engineers typically try to find an order of optimizations that yields well-optimized programs as fast as possible.
The following corollary justifies that any such order of compilation passes is valid with respect to security.
So, given two compilation passes \bul{$\cc[_{1}]{\trg{L}}{\trg{L}}$, $\cc[_{2}]{\trg{L}}{\trg{L}}$, both robustly preserving class $\class[_{1}]$ or $\class[_{2}]$, respectively}, \oul{for any order of their composition the composed compiler robustly preserves the intersection of $\class[_{1}]$ and $\class[_{2}]$}.

\begin{corollary}[Sequential Composition of Secure Compilers]\label{corr:swappable}
  Given $\class[_{1}],\class[_{2}]$, \bul{$\rtp{\cc[_{1}]{\trg{L}}{\trg{L}}}{\class[_{1}]}$, and $\rtp{\cc[_{2}]{\trg{L}}{\trg{L}}}{\class[_{2}]}$}, then \oul{$\rtp{\cc[_{1}]{\trg{L}}{\trg{L}}\circ\cc[_{2}]{\trg{L}}{\trg{L}}}{\class[_{1}]\cap\class[_{2}]}$ and $\rtp{\cc[_{2}]{\trg{L}}{\trg{L}}\circ\cc[_{1}]{\trg{L}}{\trg{L}}}{\class[_{2}]\cap\class[_{1}]}$}. \Coqed
\end{corollary}

Besides the sequential composition, there are two other compositions that are more at the language- than the compiler--level.
Nevertheless, consider $\trg{JVM BC}$, which is a popular target for programming language designers due to its high performance and relevance in industry.
As an example, $\src{Java}$ and $\obj{Kotlin}$ compile to $\trg{JVM BC}$.
Technically speaking, they both lower to class files and $\obj{Kotlin}$ objects are considered to be the same as $\src{Java}$ objects at that point.
A compiler that accepts both $\src{Java}$ and $\obj{Kotlin}$ code translating to the same target language, or rather, intermediate representation, performs a kind of {\em upper} composition.
Given a secure compiler from $\src{Java}$ to $\trg{JVM BC}$ and one from $\obj{Kotlin}$ to $\trg{JVM BC}$, it is easy to envision that one can engineer a combined compiler that accepts both $\src{Java}$ and $\obj{Kotlin}$.
A practical example of this, which is, however, insecure, is {\tt Android Studio}\MK{cit}.
The proof of \Cref{thm:rtp} can be easily adapted to also works for this {\em upper} composition.
The corresponding theorem is not listed, since there is no general definition of this kind of composition.

Likewise, the {\em lower} composition is concerned about compilers that accept the same source but yield different target languages and the same theoretical results apply.
However, especially for this kind of composition, it is rather difficult to provide a general definition.
Consider two compilers both accepting $\src{LLVM IR}$ and one of them emits $\trg{x86\_64}$, while the other emits $\trg{ARMv8}$.
It is intuitive that they are in some sense composed in the LLVM framework, but the decision of when to use one over the other is inherently {\em unobservable} to the formalization effort of this kind of composition.
Either the user of LLVM provides an explicit flag that instructs the overall compiler to emit $\trg{x86\_64}$ or the framework itself detects the target platform via heuristics.
%Either way, the theoretical results suggest that it is possible to always find a ,,most--general'', secure compiler, given two secure compilers, that robustly preserves the least--upper bound of the classes involved in their compilation process.
In general, there are two options to deal with these nuances in a concrete, practical setting:
Given secure compilers, either (i) view the whole compilation chain involving them as the upper/sequential/lower compositions and conclude the robust preservation of the intersection of all involved classes, or (ii) specify meta-parameters that, e.g., specify the target language, and thus reduce the compilation chain to a nested sequential composition of the involved compilers.
The first approach yields a more imprecise statement about the whole compilation chain while the second approach is more precise, but also less flexible.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}
      \node[minimum width=3cm,minimum height=2.5cm,draw=black,very thick,align=left] (progunopt) {\begin{lstlisting}[language=ml,basicstyle=\scriptsize\ttfamily]
let a = true in
if a then
  print "a"
else
  print "b"
\end{lstlisting}};
      \node[minimum width=3cm,minimum height=2.5cm,draw=black,very thick,align=left,right=1.0 of progunopt] (progoptcf) {\begin{lstlisting}[language=ml,basicstyle=\scriptsize\ttfamily]
if true then
  print "a"
else
  print "b"
\end{lstlisting}};
      \node[minimum width=3cm,minimum height=2.5cm,draw=black,very thick,align=left,right=1.0 of progoptcf] (progoptcfdce) {\begin{lstlisting}[language=ml,basicstyle=\scriptsize\ttfamily]
print "a"
\end{lstlisting}};% the following is a hack to get my syntax highlighting to work again \end{lstlisting}
      % edges
      \draw[->,very thick] (progunopt) edge[loop left,left] node {\gls{dce}} (progunopt);
      \draw[->,very thick] (progunopt) edge[sloped,above] node {\gls{cf}} (progoptcf);
      \draw[->,very thick] (progoptcf) edge[sloped,above] node {\gls{dce}} (progoptcfdce);
    \end{tikzpicture}
  \end{center}
  \caption{Example program where the level of optimizations differ for one pass of applying \gls{cf} and \gls{dce} in any order. %
  Every edge is a compilation pass and the label on the edge states what the pass does, i.e., \gls{cf} or \gls{dce}. %
  The source code in the nodes is a glorified compiler intermediate representation and the code gets more optimized towards the righthandside of the figure.}\label{fig:cfdceex}
\end{figure}

%\section{Case Study: Memory Safe and Cryptographic Constant Time Code}\label{sec:casestud}
\section{Case Study: Preliminary Definitions\pages{3}}\label{sec:casestud:defs}

This section defines programming languages that the secure compilers defined in the next section will make use of.
To this end, this section defines the languages $\Ltms$, $\Ltrg$, $\Lms$, and $\Lscct$.
In this paper, $\Ltms$ is the only statically typed language and exhibits the property that all well-typed programs are \gls{tms}.
However, $\Ltms$ programs are not \gls{sms}.
That is, there are well--typed $\Ltms$ programs that perform an out--of--bounds access.
In contrast, $\Ltrg$ is untyped and does not provide any guarantees with regards to \gls{ms}.
$\Lms$ is exactly the same language as $\Ltrg$, but this paper still distinguishes the two for sake of readability.
All three languages --- so $\Ltms$, $\Ltrg$, and $\Lms$ --- assume \gls{cct} to hold.
Even though it is possible to write programs that, e.g., return early in loops, which is trivially not \gls{cct}, they can be transformed to adhere to \gls{cct}~\cite{cauligi2019fact}.
The language $\Lscct$ allows violating \gls{cct} by emitting events on, e.g., branching and division, that contain secrets.
As a countermeasure, the language provides a way to read and write to a {\em model--specific register} that enables a ``\gls{cct}-mode''.

\subsection{Shared Language Definitions}\label{subsec:cs:defs}

\begin{gather*}
  \begin{aligned}
  \mi{(Expressions)}~\expr&\bnfdef\ x \mid \valueexpr \mid \lbinop{\expr[_{1}]}{\expr[_{2}]} \mid \lget{x}{\expr} \mid \lnew{\expr[_{1}]}{\expr[_{2}]} \mid \ldelete{x} \mid \lset{x}{\expr[_{1}]}{\expr[_{2}]} \\
    & \mid \llet{x}{\expr[_{1}]}{\expr[_{2}]}  \mid \lreturn{\expr} \mid \lcall{g}{\expr} \mid \lifz{\expr}{\expr[_{1}]}{\expr[_{2}]} \mid \labort \\
  \mi{(Symbols)}~&\function\bnfdef\ \lfunction{g}{x}{e}\hspace{0.5cm}
  \mi{(Libraries)}~\library\bnfdef\ \hole{\cdot} \mid \function,\library \\
  \mi{(Programs)}~&\prog{\library_{\ctx}}{\library_{\comp}}\hspace{0.5cm}
  \mi{(Substitutions)}~\substvar\bnfdef \hole{\cdot} \mid \subst{\valueexpr}{x},\gamma \\
  \end{aligned}
\end{gather*}

Above is a fraction of the shared syntax of all the programming languages of this paper.
The syntax and semantics are mostly standard.
However, when allocating pointers with $\lnew{\expr[_{1}]}{\expr[_{2}]}$, the expression $\expr[_{1}]$ determines the initial value of the objects and $\expr[_{2}]$ the overall size of an array.
The data associated to pointers resides in the dynamic state $\Omega$ that contains sandboxed heaps, one for the context and the other for the component.
Because of the sandboxing, locations pointing into heaps must be associated with a control--tag to know the heap they point into.
Other metadata in $\Omega$ entails a list of callable objects with information on wether they belong to the context or the component.
That way, when calling a callable object, the semantics can take care of emitting appropriate events that signal a context switch.
For the languages considered in this paper, no callable objects are first--class.
So, the only values are pairs, pointers, and natural numbers.
Another non--standard part of the languages is the concept of the poison--tag.
The poison--tag marks a location as freed ($\poisoned$) without removing the information associated to the freed pointer from $\Omega$.
This measure prevents the semantics from getting stuck when an already freed pointer is freed again.
Because of this, it is possible that programs like $\llet{x}{\lnew{0}{5}}{\ldelete{x};\ldelete{x}}$ reduce and emit a trace along the lines of $\specificev{Alloc\ \loc\ \sandboxtag\ 5}\cdot\specificev{Dealloc\ \loc\ \sandboxtag}\cdot\specificev{Dealloc\ \loc\ \sandboxtag}$.

\begin{gather*}
  \begin{aligned}
  \mi{(Pre\text{--}Events)}~\event[_{b}]\bnfdef \ev{Alloc}\ \loc\ \valueexpr \mid \ev{Dealloc}\ \loc \mid \ev{Get}\ \loc\ \valueexpr &\mid \ev{Set}\ \loc\ \valueexpr\ \valueexpr['] \mid \ev{Call}\ \comm\ g\ \valueexpr \mid \ev{Ret}\ \comm\ \valueexpr \mid \ev{Start} \mid \ev{End}\ \valueexpr \\
  \mi{(Events)}~\event&\bnfdef \emptyevent \mid \lightning \mid \tup{\event[_{b}]}{\sandboxtag} \\
  \end{aligned}
\end{gather*}

Possible events that are emitted during execution are similar to the ones of the specification trace model.
The key difference is that, as standard in secure compilation work, the traces have a call and return event that signals context switches.
Hereby, a $\specificev{Call\ \ctxtocomp\ foo\ \valueexpr}$ and $\specificev{Return\ \ctxtocomp\ \valueexpr}$ signal that program execution transitions from context-- to component--level.
Contrary, $\specificev{Call\ \comptoctx\ foo\ \valueexpr}$ and $\specificev{Return\ \ctxtocomp\ \valueexpr}$ signal that program execution transitions from component-- to context--level.
The environmental semantics emits the tag $\nocomm$ for calls from context-- to context--level or component-- to component--level.
In the following, $\neg\ctx=\comp$ and $\neg\comp=\ctx$ and also $\operatorname{comm}(\ctx)=\ \ctxtocomp$ and $\operatorname{comm}(\comp)=\ \comptoctx$.

\begin{center}
  \judgbox{\estepto[]{\runtimetermvar}{\runtimetermvar}{\event}}{,,Contextual step from runtime--term $\runtimetermvar$ to $\runtimetermvar[']$ emitting event $\event$.''}
  %
  \typerule{$e-\text{ret}$}{
    \statevar.\ectxstack=\tup{\ectx}{\text{foo}},\ectxstack['] &
    \commlib\vdash\text{foo}:\Omega.\sandboxtag\dashv\comm
  }{
    \estepto[]{\rtt{\statevar}{\ectx[']\hole{\lreturn{\valueexpr}}}}{\rtt{\statevar\subst{\neg\statevar.\sandboxtag}{\sandboxtag}\subst{\ectxstack[']}{\ectxstack}}{\ectx\hole{\valueexpr}}}{\tup{\ev{Ret}\ \comm\ \valueexpr}{\statevar.\sandboxtag}}
  }{e-ret-notsame}
  %
  \typerule{$e-\text{call}-\text{notsame}$}{
    \lfunction{\text{foo}}{x}{e} \in \statevar.\library &
    \commlib\vdash\text{foo}:\Omega.\sandboxtag\dashv\comm
  }{
    \estepto[]{\rtt{\statevar}{\ectx\hole{\lcall{\text{foo}}{\valueexpr}}}}{\rtt{\statevar\subst{\neg\statevar.\sandboxtag}{\sandboxtag}\subst{\tup{\ectx}{\text{foo}},\statevar.\ectxstack}{\ectxstack}}{\expr\subst{\valueexpr}{x}}}{\tup{\ev{Call}\ \comm\ \text{foo}\ \valueexpr}{\statevar.\sandboxtag}}
  }{e-call-notsame}
\end{center}

The environmental semantics is also mostly straightforward.
In \Cref{tr:e-ret-notsame,tr:e-call-notsame} the judgement $\commlib\vdash\text{foo}:\Omega.\sandboxtag$ checks wether $\text{foo}$ is a component--level name by looking it up in the list of component-level names $\commlib$ and emits the appropriate transfer tag, i.e., either $\comptoctx$ or $\ctxtocomp$.
Additional rules that are left out ensure that, e.g., when calling the $\text{main}$ function, the event $\ev{Start}$ is emitted, which is a design choice this paper does for convenience when reasoning about call--chains.

The top--level execution $\progstepto{\prog{\library_{\ctx}}{\library_{\comp}}}{\runtimetermvar}{\trace}$ constructs an initial state $\Omega$ by linking $\library_{\ctx}$ and $\library_{\ctx}$ and then starts execution by calling the $\text{main}$ function.
The trace $\trace$ emitted during that execution serves as abstraction of the behavior of the program enabling the use of \Cref{def:propsat,def:proprsat}.

\subsection{$\src{L_{\tmssafe}}$: A Temporal but Not Spatial Memory Safe Language}\label{subsec:ltms}
\begin{gather*}
  \begin{aligned}
    \mi{(Pre\text{--}Types)}~\src{\type[_{e}]}\bnfdef&\ \src{\natt} \mid \src{\ptrn} &
    \mi{(Type~Environments)}~\src{\typenv}\bnfdef&\ \src{\hole{\cdot}} \mid \hastype{\src{x}}{\src{\type}},\src{\typenv} \\
    \mi{(Types)}~\src{\type}\bnfdef&\ \src{\type[_{e}]} \mid \src{\type[_{e}]\to\bot} \mid \src{\type[^{(1)}_{e}]\to\type[^{(2)}_{e}]} &
    \mi{(Pointer\ Qualifiers)}~\src{\ptrqual}\bnfdef&\ \src{\fullq} \mid \src{\halfq} \\
    \mi{(Symbols)}~\src{\function}\bnfdef&\src{\lfunction{g}{x:\type[_{e}]\to\type[_{e}]}{\expr}} \\
  \end{aligned}
\end{gather*}
\begin{center}
  \judgbox{\tcheck{\src{\typenv}}{\src{\expr}}{\src{\type}}}{,,Under environment $\src{\typenv}$, expression $\src{\expr}$ has type $\src{\type}$.''}
  %
  \typerule{t-$\src{x}$}{
    \src{\typenv}(\src{x})=\src{\type} &
    \notowned{\src{\typenv}}
  }{
    \tcheck{\src{\typenv}}{\src{x}}{\src{\type}}
  }{t-x}
  %
  \typerule{t-$\src{get}$}{
    \tcheck{\src{\typenv[_2]}}{\src{x}}{\src{\wptr}} &
    \tcheck{\src{\typenv[_1]}}{\src{\expr}}{\src{\natt}} &
  }{
    \tcheck{\typenvsplit{\src{\typenv[_1]}}{\src{\typenv[_2]}}}{\src{\lget{x}{\expr}}}{\src{\natt}}
  }{t-get}
  %
  \typerule{t-$\src{let}$}{
    \tcheck{\src{\typenv[_1]}}{\src{\expr[_1]}}{\src{\type[_e]}} &
    \tcheck{\hastype{\src{x}}{\src{\type[_e]}},\src{\typenv[_2]}}{\src{\expr[_2]}}{\src{\type}}
  }{
    \tcheck{\typenvsplit{\src{\typenv[_1]}}{\src{\typenv[_2]}}}{\src{\llet{x}{\expr[_1]}{\expr[_2]}}}{\src{\type}}
  }{t-let}
  %
  \typerule{t-$\src{delete}$}{
    \src{\typenv}(\src{x})=\src{\ptr} &
    \notowned{\src{\typenv}\setminus\left\{\hastype{\src{x}}{\src{\ptr}}\right\}}
  }{
    \tcheck{\src{\typenv}}{\src{\ldelete{x}}}{\src{\natt}}
  }{t-delete}
  %
  \typerule{t-$\src{abort}$}{
    \notowned{\src{\typenv}}
  }{
    \tcheck{\src{\typenv}}{\src{\labort}}{\src{\type}}
  }{t-abort}
  %
  \typerule{t-$\src{call}$}{
    \inttype{\src{\type[^{(1)}_e]}} &
    \inttype{\src{\type[^{(2)}_e]}} \\
    \tcheck{\src{\typenv}}{\src{foo}}{\src{\type[^{(1)}_e]\to\type[^{(2)}_e]}} &
    \tcheck{\src{\typenv}}{\src{\expr}}{\src{\type[^{(1)}_e]}}
  }{
    \tcheck{\src{\typenv}}{\src{\lcall{foo}{\expr}}}{\src{\type[^{(2)}_e]}}
  }{t-call}
  %
  \typerule{t-$\src{return}$}{
    \inttype{\src{\type[_e]}} &
    \tcheck{\src{\typenv}}{\src{\expr}}{\src{\type[_e]}}
  }{
    \tcheck{\src{\typenv}}{\src{\lreturn{\expr}}}{\src{\type[_e]\to\bot}}
  }{t-return}
\end{center}

$\src{L_{\tmssafe}}$ is a statically typed language where each well-typed term is temporal memory safe.
Most parts of the type system are entirely standard, so only the interesting bits are shown here.
To enforce this, the language marks pointers with respect to their ownership, where $\src{\fullq}$ means {\em owned} and $\src{\halfq}$ means {\em not owned}.
An owned pointer can only be used by a deallocation (\Cref{tr:t-delete}), whereas reads and writes must be done on non-owned pointers.
One can convert owned to non-owned pointers implicitly through context splitting $\typenvsplit{\src{\typenv[_{1}]}}{\src{\typenv[_{2}]}}$.\MK{list some rules and explain it a bit}
Syntactic constraints together with the type system ensure that non-owned pointers never ,,live'' longer than owned pointers.
For example, in an expression $\src{\llet{x}{\expr[_{1}]}{\expr[_{2}]}}$, if $y$ is a $\src{\ptr}$ in $\src{\expr[_{1}]}$, it cannot appear at all in $\src{\expr[_{2}]}$, but it can if it were of type $\src{\wptr}$ (\Cref{tr:t-let}).
This mechanism also prevents terms like $\src{\lget{x}{\ldelete{x}}}$ from typechecking (\Cref{tr:t-get}).
At leafs of the type derivation tree, the typing environment must not contain owned pointers, which is ensured with the $\notowned{\src{\typenv}}$ judgement (\Cref{tr:t-abort,tr:t-x}).
Lastly, calling or returning requires passed values to have an interface type ($\inttype{\src{\type[_{e}]}}$), which are just $\src{\natt}$ (\Cref{tr:t-call,tr:t-return}).
To ensure that no pointers live after a return, the type of a return is that of a continuation, which is only permitted to propagate towards the end of a term.
For example, we cannot bind $\src{\lreturn{e}}$ to an identifier in the typecheck of $\src{let}$, because the expression whose result is written into the binder has to be a pre--type, which the type of $\src{\lreturn{e}}$ is not.

\subsection{All Well-Typed $\Ltms$ Programs are Temporal Memory Safe}

\begin{center}
  \judgbox{\thelocmap(\src{\loc})=\loc}{,,Map an $\src{L_{\tmssafe}}$ location to a specification location $\loc$.''}
  \judgbox{\msfilterLtms{\src{\event}}=\event}{,,Project an $\src{L_{\tmssafe}}$ event $\src{\event}$ to a specification event $\event$.''}
  \typerule{$\src{L_{\tmssafe}}$-filter-context}{
    \src{\event[_b]}\not=\src{\lightning}
  }{
    \msfilterLtms{\src{\tup{\event[_b]}{\ctx}} = \emptyevent}
  }{ltms-filter-context}
  %
  \typerule{$\src{L_{\tmssafe}}$-filter-abort}{
  }{
    \msfilterLtms{\src{\lightning}} = \lightning
  }{ltms-filter-abort}
  %
%  \typerule{$\src{L_{\tmssafe}}$-filter-start}{
%  }{
%    \msfilterLtms{\src{\tup{Start}{\comp}}} = \emptyevent
%  }{ltms-filter-start}
  %
  \typerule{$\src{L_{\tmssafe}}$-filter-alloc}{
    \locmapsto{\src{\loc}}{\loc} &
    \src{n}=n
  }{
    \msfilterLtms{\src{\tup{Alloc\ \loc\ n}{\comp}}} = \tup{\ev{Alloc}\ \loc\ n}{\comp,\unlock}
  }{ltms-filter-alloc}
\end{center}
To prove that well-typed $\src{L_{\tmssafe}}$ programs are temporal memory safe, a map from $\src{L_{\tmssafe}}$ to specification events (see \Cref{subsec:propdefs}) allows the use of \Cref{def:monsat}.
The map is mostly entirely straight-forward.
Most notably, it filters any action that the context does (\Cref{tr:ltms-filter-context}), since a context is free to do anything.
Of course, a context invoking $\src{\labort}$ to crash the program must not go undetected (\Cref{tr:ltms-filter-abort}).
As for the component, pre--events are essentially recolored to go from blue $\src{L_{\tmssafe}}$ events to the events of the most general trace model (\Cref{tr:ltms-filter-alloc}).
Events that carry locations make use of a location--map from blue $\src{L_{\tmssafe}}$ locations to the more abstract ones.

\begin{lemma}[$\src{L_{\tmssafe}}$-programs are \gls{tms}]\label{lem:wt:tmsmon}
  If $\progstepto{\src{\prog{\library_{\ctx}}{\library_{\comp}}}}{\src{\rtt{\statevar}{\valueexpr}}}{\src{\trace}}$, then $\montmssafe{\msfilterLtms{\src{\trace}}}$.\Coqed
\end{lemma}
\begin{theorem}[$\src{L_{\tmssafe}}$-programs are \gls{tms}]\label{thm:wt:tms}
  For any $\src{\library_{\comp}}$, $\rsat{\src{\library_{\comp}}}{\tmssafe}$ \Coqed
\end{theorem}

\subsection{$\Ltrg$: A Memory-Unsafe Language}\label{subsec:lsms}

\begin{gather*}
  \begin{aligned}
    \mi{(Expressions)}~\trg{\expr}\bnfdef\ \dots \mid \trg{\lispoisoned{x}} \mid \trg{\lpair{\expr[_{1}]}{\expr[_{2}]}} &\mid \trg{\lproja{\expr}} \mid \trg{\lprojb{\expr}} \mid \trg{\lhast{\expr}{\type}} \hspace{0.5cm}
    \mi{(Types)}~\trg{\type}\bnfdef\ \trg{\natt} \mid \trg{\natt\times\natt} \\
    \mi{(Values)}~\trg{\valueexpr}&\bnfdef\ \dots \mid \trg{\lpair{n_{1}}{n_{2}}}
  \end{aligned}
\end{gather*}
\begin{center}
  \typerule{e-$\trg{\lispoisoned{}}$-yes}{
    \trg{\statevar.\store}(\trg{x})=\trg{\tup{\loc}{\statevar.\sandboxtag,\poisoned,n}}
  }{
    \pstepto{\rtt{\trg{\statevar}}{\trg{\lispoisoned{x}}}}{\rtt{\trg{\statevar}}{\trg{0}}}{\trg{\emptyevent}}
  }{e-ispoisoned-yes}
  %
%  \typerule{e-$\trg{\lispoisoned{}}$-no}{
%    \trg{\statevar.\store}(\trg{x})=\trg{\tup{\loc}{\statevar.\sandboxtag,\poisonless,n}}
%  }{
%    \pstepto{\rtt{\trg{\statevar}}{\trg{\lispoisoned{x}}}}{\rtt{\trg{\statevar}}{\trg{1}}}{\trg{\emptyevent}}
%  }{e-ispoisoned-no}
  %
  \typerule{e-$\trg{\lhast{n}{\natt}}$}{
  }{
    \pstepto{\rtt{\trg{\statevar}}{\trg{\lhast{n}{\natt}}}}{\rtt{\trg{\statevar}}{\trg{0}}}{\trg{\emptyevent}}
  }{e-n-has-nat}
  %
%  \typerule{e-$\trg{\lhast{x}{\natt}}$}{
%  }{
%    \pstepto{\rtt{\trg{\statevar}}{\trg{\lhast{x}{\natt}}}}{\rtt{\trg{\statevar}}{\trg{1}}}{\trg{\emptyevent}}
%  }{e-x-has-nat}
  %
  \typerule{e-$\trg{\lhast{n}{\natt\times\natt}}$}{
  }{
    \pstepto{\rtt{\trg{\statevar}}{\trg{\lhast{n}{\natt\times\natt}}}}{\rtt{\trg{\statevar}}{\trg{1}}}{\trg{\emptyevent}}
  }{e-n-has-nattimesnat}
\end{center}

The $\Ltrg$ language does not provide any guarantees with regards to memory safety.
The syntax of it extends the unified syntax for all languages (\Cref{subsec:cs:defs}) with pairs of natural numbers (\Cref{tr:e-proj1}) and two different kinds of dynamic checks.
One of those checks allows programmers to investigate wether a pointer is freed or not (\Cref{tr:e-ispoisoned-yes}).
The other check is a simple dynamic type check that evaluates to $\trg{0}$ if the check suceeds and to $\trg{1}$ otherwise (\Cref{tr:e-n-has-nat,tr:e-n-has-nattimesnat}).
The projection $\msfilterL{\trace}$ is entirely similar to $\msfilterLtms{\trace}$.

\subsection{$\Lms$: Another Memory-Unsafe Language}\label{subsec:lms}

This paper chooses to introduce $\Lms$, despite it being exactly equal to $\Ltrg$.
The main purpose of this decision is to enhance readability.
One thing that is added to $\Lms$ is another projection to the most general trace model for reasoning about \gls{scct}.
Here, any information irrelevant to \gls{scct} is filtered.

\begin{center}
  \typerule{$\Lms$-filter-alloc}{
  }{
    \scctfilterLms{\irl{\tup{Get\ \loc\ n}{\comp}}} = \emptyevent
  }{lms-filter-get}
  %
  \typerule{$\Lms$-filter-abort}{
  }{
    \scctfilterLms{\irl{\lightning}} = \lightning
  }{lms-filter-abort}
\end{center}

\subsection{$\Lscct$: An Unsafe Language}\label{subsec:lscct}

\begin{gather*}
  \begin{aligned}
    \mi{(Expressions)}~\obj{\expr}\bnfdef&\dots \mid \obj{\lwrdoit{\expr}} \mid \obj{\lrddoit{x}{\expr}} &
    \mi{(States)}~\obj{\statevar}\bnfdef&\obj{\tup{\cfstate}{\sandboxtag,n,\memstate}}
  \end{aligned}
\end{gather*}

$\Lscct$ extends the state presented earlier (\Cref{subsec:cs:defs}) with another entry that models the value of a register for a data (operand) independent timing mode.
To modify the register, $\Lscct$ extends expressions with a way to write a value to the register ($\obj{\lwrdoit{\expr}}$) and a way to read it ($\obj{\lrddoit{x}{\expr}}$).
Finals carry a secrecy annotation, indicating high ($\obj{\lock}$) or low ($\obj{\unlock}$) secrecy.
Whenever the register is marked as active, parts of the dynamics of $\Lscct$ do not leak information.
In general, $\Lscct$ can leak more information than the other languages:

\begin{gather*}
  \begin{aligned}
    \mi{(Pre\text{--}Events)}~\obj{\event[_{b}]}&\bnfdef\ \dots \mid \obj{{Branch}\ n} \mid \obj{{Binop}\ n} \mid \obj{\widehat{{Get}}\ \loc\ \valueexpr} \mid \obj{\widehat{{Set}}\ \loc\ \valueexpr\ \valueexpr[']} &
    \mi{(Events)}~\obj{\event}&\bnfdef\ \obj{\varepsilon} \mid \obj{\lightning} \mid \obj{\tup{\event[_{b}]}{\sandboxtag,\securitytag}}
  \end{aligned}
\end{gather*}

Events carry a secrecy tag instead of the data they carry.
Branches and binary operations leak information about the data they compute on.
If the data (object) independent timing register is set to be active, the read and write to memory events should not leak.
However, to emit $\obj{\emptyevent}$ in this case would mean that memory unsafe operations are hidden as well.
Since this language should not have a mechanism to hide memory unsafety, pre--events are extended to model reading from ($\obj{\widehat{{Get}}\ \loc\ \valueexpr}$) and writing to ($\obj{\widehat{Set}\ \loc\ \valueexpr}$) memory without leaking secret information involved in the access.

\begin{center}
  \typerule{e-$\obj{\lbinop{}{}}$-leak}{
    \obj{n_1}\oplus\obj{n_2}=\obj{n_3} &
    \obj{\securitytag}\sqcap\obj{\securitytag[']}=\obj{\securitytag['']} &
    \obj{\oplus}\notin\left\{\obj{\times}, \obj{/}, \obj{<}\right\}
  }{
    \pstepto{\rtt{\obj{\tup{\cfstate}{\sandboxtag,0,\memstate}}}{\obj{\lbinop{n_1^{\securitytag}}{n_2^{\securitytag[']}}}}}{\rtt{\obj{\tup{\cfstate}{\sandboxtag,0,\memstate}}}{\obj{n_3^{\securitytag['']}}}}{\obj{\tup{Binop\ n_3}{\sandboxtag,\securitytag['']}}}
  }{e-binop-leak}
\end{center}

\MKin{filters to spec events}

\section{Case Study: Secure Compiler Compositions in the Wild\pages{7}}\label{sec:casestud:rtp}

\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}
      \node (S) {$\src{L_{\tmssafe}}$};
      \node[right=1.5 of S] (T) {$\trg{L}$};
      \node[right=1.5 of T] (M) {$\irl{L_{\mssafe}}$};
      \node[below right=0.5 and 1.0 of M] (D0) {$\irl{L_{\mssafe}}$};
      \node[above right=0.5 and 1.0 of M] (C0) {$\irl{L_{\mssafe}}$};
      \node[right=3.0 of M] (E) {$\irl{L_{\mssafe}}$};
      \node[right=1.5 of E] (O) {$\obj{L_{\scctsafe}}$};

      \draw[->] (S) to[sloped] node[align=center,font=\scriptsize] (tmsedge) {\gls{tms}\\ \Cref{thm:cca:rtp:tms}} (T);
      \draw[->] (T) to[sloped] node[align=center,font=\scriptsize] {\gls{sms}\\ \Cref{thm:ccb:rtp:sms}} (M);
      \draw[->] (M) to[sloped] node[align=center,font=\scriptsize] {\gls{dce}\\ \Cref{thm:ccdce:rtp:ms}} (D0);
      \draw[->] (M) to[sloped] node[align=center,font=\scriptsize] {\gls{cf}\\ \Cref{thm:cccf:rtp:ms}} (C0);
      \draw[->] (D0) to[sloped] node[align=center,font=\scriptsize] {\gls{cf}\\ \Cref{thm:cccf:rtp:ms}} (E);
      \draw[->] (C0) to[sloped] node[align=center,font=\scriptsize] {\gls{dce}\\ \Cref{thm:ccdce:rtp:ms}} (E);
      \draw[->] (E) to[sloped,above] node[align=center,font=\scriptsize] {\gls{scct}\\ \Cref{thm:ccscct:rtp:scct}} (O);

      % Sections
      \node[above=1.0 of tmsedge] (sectms) {{\scriptsize\Cref{subsec:cs:tms}}};
      \node[right=0.5 of sectms] (secsms) {{\scriptsize\Cref{subsec:cs:ms}}};
      \node[right=1.75 of secsms] (secopts) {{\scriptsize\Cref{subsec:cs:opts}}};
      \node[right=1.75 of secopts] (secscct) {{\scriptsize\Cref{subsec:cs:scct}}};

      \draw[thick,dotted,->] (S) to[bend right=33,sloped] node[align=center,font=\scriptsize] {\gls{ms}\\ \Cref{thm:ccab:rtp:ms}} (M);
      \draw[thick,dotted,->] (M) to[bend right=0,sloped] node[align=center,font=\scriptsize] {\gls{ms}\\ \Cref{thm:cccfccdce:rtp:ms}} (E);
      \draw[thick,dotted,->] (S) to[out=-45,in=198,sloped] node[align=center,font=\scriptsize] {\gls{ms}+\gls{scct}\\ \Cref{thm:ccall:rtp:msscct}} (O);

      \draw[dashed] ($(sectms)-(0.8,0)$) -- ($(sectms)-(0.8,1.25)$);
      \draw[dashed] ($(sectms)-(-0.9,0)$) -- ($(sectms)-(-0.9,1.25)$);
      \draw[dashed] ($(secsms)-(-1.2,0)$) -- ($(secsms)-(-1.2,1.25)$);
      \draw[dashed] ($(secscct)-(1.2,0)$) -- ($(secscct)-(1.2,1.25)$);
      \draw[dashed] ($(secscct)-(-1.1,0)$) -- ($(secscct)-(-1.1,1.25)$);
    \end{tikzpicture}
  \end{center}
  \caption{Visualisation of the optimizing compilation pipeline that attains a combination of \gls{ms} and \gls{cct}.}\label{fig:pipeline}
\end{figure}
This section defines several secure compilers, each of which robustly preserves a different property of interest (\Cref{fig:pipeline}).
The power of the framework (\Cref{sec:compprop,sec:compcomp}) is demonstrated by composing these compilers for a secure, but optimizing, compilation chain that robustly preserves \gls{ms} and \gls{cct}.
Concretely, the section starts with a base-line definition for the used languages (\Cref{subsec:cs:defs}) and extends that to define languages $\src{L_{TMS}}$ and $\trg{L}$.
For programmers using $\src{L_{TMS}}$, their mental model should be that their code is temporal memory safe and cryptographic constant time.
The former is proven to be enforced by the static semantics of $\src{L_{TMS}}$, where each well-typed program is temporal memory safe.
The latter is completely untyped.
Having languages defined, this section continues with a compiler $\cc{\src{L_{\tmssafe}}}{\trg{L}}$ and proves that $\cc{\src{L_{\tmssafe}}}{\trg{L}}$ robustly preserves \gls{tms} (\Cref{subsec:cs:tms}).
For readability purposes, it defines $\irl{L_{MS}}$ to be exactly the same as $\trg{L}$ and continues to present a compiler $\cc{\trg{L}}{\irl{L_{MS}}}$ that robustly preserves \gls{sms} (\Cref{subsec:cs:ms}).
Now leaveraging the power of the framework that this paper introduces (\Cref{sec:compcomp,sec:compprop}), a compiler $\rtp{\cc{\src{L_{TMS}}}{\irl{L_{MS}}}}{\mssafe}$ is attained.
The next steps in the compilation pipeline are two secure compilers $\cc[_{\gls{dce}}]{\irl{L_{MS}}}{\irl{L_{MS}}}$ and $\cc[_{\gls{cf}}]{\irl{L_{MS}}}{\irl{L_{MS}}}$ that perform \glsfirst{dce} and \glsfirst{cf}, respectively, to model an optimzing pipeline happening somewhere in the compilation chain (\Cref{subsec:cs:opts}).
Finally, this section defines the language $\obj{L_{\scctsafe}}$ that is, in contrast to the other languages, not cryptographic constant time by definition.
Concluding, a compiler $\cc{\irl{L_{MS}}}{\obj{L_{CCT}}}$ that robustly preserves \gls{cct} (\Cref{subsec:cs:scct}) is shown and composed with $\cc{\src{L_{TMS}}}{\irl{L_{MS}}}$ and the optimizing compilers $\cc[_{\gls{dce}}]{\irl{L_{MS}}}{\irl{L_{MS}}}$ and $\cc[_{\gls{cf}}]{\irl{L_{MS}}}{\irl{L_{MS}}}$.
In turn, this yields $\cc{\src{L_{TMS}}}{\obj{L_{CCT}}}$, a compiler that robustly preserves a combination of \gls{ms} and \gls{cct}.



\subsection{Robust Temporal Memory Safety Preservation}\label{subsec:cs:tms}

\begin{center}
  $$
  \begin{array}{rcl}
%    \cca(\src{\lbinop{\expr[_{1}]}{\expr[_{2}]}}) & = & \lbinop[\trg]{\left[\cca(\src{\expr[_{1}]})\right]}{\left[\cca(\src{\expr[_{2}]})\right]} \\ [0.33cm]
    \cca(\src{\lfunction{g}{x:\natt\to\type[_{e}]}{\expr}}) & = & \lfunction[\trg]{\trg{g}}{\trg{x}}{\lifz[\trg]{\trg{\lhast{x}{\natt}}}{%
                                                                                                \left[\cca(\src{\expr})\right] %
                                                                                                 }{\labort[\trg]}}
  \end{array}
  $$
\end{center}

The only case where the compiler does something interesting is for top-level functions.
Here, a dynamic typecheck is inserted to respect the calling-convention.
Since $\trg{L}$ has no static typechecks, it could happen that a bogus context $\trg{\library_{\ctx}}$ calls a symbol accepting a $\src{\natt}$ with $\trg{\lpair{17}{29}}$.
The compiler ensures that execution does not proceed in cases like that.
This paper considers symbols on $\src{\natt}$.

\begin{theorem}[Compiler $\cca$ is secure with respect to \gls{tms}]\label{thm:cca:rtp:tms}
  $\rtp{\cca}{\tmssafe}$ % \Coqed
\end{theorem}

\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}[state/.style={minimum height=0.6cm}]
      % relative horizontal/vertical distance between states
      \pgfmathsetmacro{\hdist}{0.95}
      \pgfmathsetmacro{\vdist}{1.35}
      \pgfmathsetmacro{\halfvdist}{0.725}

      % row of src states
      \node[state] (srcempty) {$\src{\emptyset}$};
      \foreach \s [remember=\s as \cur (initially empty)] in {1,w_1,p,w_2,2} {
        \node[state,right=\hdist of src\cur] (src\s) {$\src{\Omega_{\s}}$};
      }
      % row of trg states
      \node[state,below=\vdist of srcempty] (trgempty) {$\trg{\emptyset}$};
      \foreach \s in {1,w_1,p,w_2,2} {
        \node[state,below=\vdist of src\s] (trg\s) {$\trg{\Omega_{\s}}$};
      }
      %% illustrations
        % backtrans wrapper 1
        \draw[thick,loosely dotted,Peach!50,rounded corners] (src1.north east) -- (srcw\string_1.north east)
          -- (trgw\string_1.south east) -- (trg1.south west) -- (src1.north west) -- cycle;
        % backtrans wrapper 2
        \draw[thick,loosely dotted,Peach!50,rounded corners] (srcp.north east) -- (srcw\string_2.north east)
          -- (trgw\string_2.south east) -- (trgp.south west) -- (srcp.north west) -- cycle;
        % compiler correctness
        \draw[thick,loosely dashed,Emerald!50,rounded corners] ($(srcw\string_1.north east)+(0,0.05)$) -- ($(srcp.north east)+(0,0.05)$)
          -- ($(trgw\string_2.north east)+(0.05,0)$) -- ($(trgw\string_2.south east)+(0.05,-0.05)$)
          -- ($(trg1.south west)+(-0.05,-0.05)$) -- ($(trg1.north west)+(-0.05,0)$) -- ($(srcw\string_1.north west)+(0,0.05)$) -- cycle;
      % state relations
      \path (srcempty) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_\emptyset$} (trgempty)
        (src1) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_1}$} (trg1)
        (srcp) edge[draw=gray!25] node[pos=0.5,sloped,fill=white] {\scriptsize$\approx_{\delta_p}$} (trgp)
        (src2) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_2}$} (trg2)
        (srcw\string_1) edge[draw=gray!25] node[pos=0.5,sloped,fill=white] {\scriptsize$\approx_{\delta_{w_1}}$} (trgw\string_1)
        (srcw\string_2) edge[draw=gray!25] node[pos=0.5,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_{w_2}}$} (trgw\string_2)
        % diagonals
        (srcw\string_1) edge[draw=gray!25] node[pos=0.16,sloped,rotate=180,fill=white] {\scriptsize$\approx_{\delta_{w_1}}$} (trg1)
        (src1) edge[draw=gray!25] node[pos=0.16,sloped,rotate=180,fill=white] {\scriptsize$\multimap_{\delta_1}$} (trgw\string_1)
        (srcp) edge[draw=gray!25] node[pos=0.2,sloped,fill=white] {\scriptsize$\approx_{\delta_p}$} (trgw\string_2)
        (trgp) edge[draw=gray!25] node[pos=0.2,sloped,fill=white] {\scriptsize$\multimap_{\delta_{w_2}}$} (srcw\string_2)
        ;
      %\drawpolygon src1,srcw\string_1,trgw\string_1,trg1;
      %\drawpolygon srcp,srcw\string_2,trgw\string_2,trgp;
      %\node[font=\tiny,align=center,above=0.2 of srcw1srcp] (wrapper) {Backtranslation\\Wrapper};
      %\path[->,draw] (wrapper) -- (srcw\string_1);
      %\path[->,draw] (wrapper) -- (srcp);
      % steps
      \path[color=\stlccol] (srcempty) edge[draw=none] node {\ $\xrightarrow{\trace[_1]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (src1)
        (src1) edge[draw=none] node {\ $\xrightarrow{\trace[_c]}{}{\kern-3.5pt}_{\text{ctx}}$} (srcw\string_1)
        (srcw\string_1) edge[draw=none] node {\ $\xrightarrow{\trace[_p]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (srcp)
        (srcp) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\trace[_r]}{}{\kern-3.5pt}_{\text{ctx}}$} (srcw\string_2)
        (srcw\string_2) edge[draw=none] node {\ $\xrightarrow{\trace[_2]}{}{\kern-3.5pt}_{\text{ctx}}^*$} (src2)
        ;
      \path[color=\ulccol] (trgempty) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\phantom{\trace[_1]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trg1)
        (trg1) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgw\string_1)
        (trgw\string_1) edge[draw=none] node[fill=white,inner sep=0,outer sep=0] {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgp)
        (trgp) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_p]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trgw\string_2)
        (trgw\string_2) edge[draw=none] node {\ $\xrightarrow{\phantom{\trace[_2]}}{}{\kern-3.5pt}_{\text{ctx}}^*$} (trg2)
        ;
      % legend
      \node[align=left,below right=0.3 and 0.3 of trgempty,font=\tiny] (legend) {%
        ${\src{\trace[_c]}}\cong{\backt{\Ltms}{\Ltrg}(\trg{Call\ ?\finalexpr_i})}$\\%
        ${\src{\trace[_r]}}\cong{\backt{\Ltms}{\Ltrg}(\trg{Ret\ !\finalexpr_o})}$
        };
      \draw[thick,loosely dotted,Peach!50,rounded corners] ($(legend.north east)+(0.5,-0.4)$) -- ($(legend.north east)+(1,-0.4)$);
      \node at ($(legend.north east)+(1.5,-0.4)$) (legendwrapper) {};
      \node[right of=legendwrapper] {\tiny Backtranslation Wrapper};
      \draw[thick,loosely dashed,Emerald!50,rounded corners] ($(legend.south east)+(0.5,0.4)$) -- ($(legend.south east)+(1,0.4)$);
      \node at ($(legend.south east)+(1.5,0.4)$) (legendcorrectness) {};
      \node[right of=legendcorrectness] {\tiny Compiler Correctness};
    \end{tikzpicture}
    \caption{Proof diagram for \Cref{thm:cca:rtp:tms} depicting the general structure of robust preservation proofs.}\label{fig:proofdiag:rtp}
  \end{center}
\end{figure}

\subsection{Robust (Spatial) Memory Safety Preservation}\label{subsec:cs:ms}

In this section, the language $\irl{L_{\mssafe}}$ is exactly the same as $\trg{L}$ and are considered equal.
However, it is still named and collored differently to emphasize the fact that after this section, compiled $\irl{L_{\mssafe}}$ programs are \gls{ms}.

\begin{center}
  $$
  \begin{array}{rcl}
    \ccb(\trg{\lnew{x}{\expr[_{1}]}{\expr[_{2}]}}) & = & \llet[\irl]{\irl{x_{SIZE}}}{\ccb(\trg{\expr[_{1}]})}{\lnew[\irl]{\irl{x}}{\irl{x_{SIZE}}}{\ccb(\trg{\expr[_{2}]})}} \\
    \ccb(\trg{\lget{x}{\expr}}) & = & \llet[\irl]{\irl{x_{n}}}{\ccb(\trg{\expr})}{\irl{\lifz{0\le x_{n}<x_{SIZE}}{\lget{x}{x_{n}}}{\labort}}} \\
    \ccb(\trg{\lset{x}{\expr[_{1}]}{\expr[_{2}]}}) & = & \llet[\irl]{\irl{x_{n}}}{\ccb(\trg{\expr[_{1}]})}{\lifz[\irl]{\irl{0\le x_{n}<x_{SIZE}}}{\lset[\irl]{\irl{x}}{\irl{x_{n}}}{\ccb(\trg{\expr[_{2}]})}}{\irl{\labort}}} \\
  \end{array}
  $$
\end{center}

Up to getting and setting memory, the compiler is the identity function.
For memory accesses, however, a bounds--check is inserted that enforces \gls{sms}.
To this end, the compiler introduces another, fresh identifier $\irl{x_{SIZE}}$ for each allocation that binds $\irl{x}$ to keep track of the allocation size.

\begin{theorem}[Compiler $\ccb$ is secure with respect to \gls{sms}]\label{thm:ccb:rtp:sms}
  $\rtp{\ccb}{\smssafe}$ % \Coqed
\end{theorem}

The composition of $\cca$ and $\ccb$ attains full memory safety using \Cref{thm:rtp,thm:cca:rtp:tms,thm:ccb:rtp:sms}.

\begin{theorem}[Compiler $\cca\circ\ccb$ is secure with respect to \gls{ms}]\label{thm:ccab:rtp:ms}
  $\rtp{\cca\circ\ccb}{\mssafe}$ % \Coqed
\end{theorem}

\subsection{Optimizing Compilers}\label{subsec:cs:opts}

\begin{center}
  $$
  \begin{array}{rcl}
    \ccdce(\irl{\lifz{true}{\expr[_{1}]}{\expr[_{2}]}}) & = & \ccdce(\irl{\expr[_{1}]}) \\
    \ccdce(\irl{\lifz{false}{\expr[_{1}]}{\expr[_{2}]}}) & = & \ccdce(\irl{\expr[_{2}]}) \\
  \end{array}
  $$
\end{center}

\begin{center}
  $$
  \begin{array}{rcll}
    \cccf(\irl{\llet{x}{n}{\expr}}) & = & \cccf(\irl{\expr\subst{n}{x}}) &\\
    \cccf(\irl{\lbinop{n_{1}}{n_{2}}}) & = & \irl{n_{3}} & \text{where }\irl{n_{3}}\text{ is }\lbinop{\irl{n_{1}}}{\irl{n_{2}}}\\
  \end{array}
  $$
\end{center}

\begin{theorem}[Compiler $\ccdce$ is secure with respect to \gls{ms}]\label{thm:ccdce:rtp:ms}
  $\rtp{\ccdce}{\mssafe}$ % \Coqed
\end{theorem}
\begin{theorem}[Compiler $\cccf$ is secure with respect to \gls{ms}]\label{thm:cccf:rtp:ms}
  $\rtp{\cccf}{\mssafe}$ % \Coqed
\end{theorem}

\begin{theorem}[Compilers $\cccf\circ\ccdce$ and $\cccf\circ\ccdce$ are secure with respect to \gls{ms}]\label{thm:cccfccdce:rtp:ms}
  $\rtp{\cccf\circ\ccdce}{\mssafe}$ and $\rtp{\ccdce\circ\cccf}{\mssafe}$ % \Coqed
\end{theorem}

\subsection{Robust Strict Cryptographic Constant Time Preservation}\label{subsec:cs:scct}

\begin{center}
  $$
  \begin{array}{rcl}
    \ccscct(\irl{\lfunction{g}{x}{\expr}}) & = & \lfunction[\obj]{\obj{g}}{\obj{x}}{\obj{\lwrdoit{1};}\ccscct(\irl{\expr})}
  \end{array}
  $$
\end{center}

\begin{theorem}[Compiler $\ccscct$ is secure with respect to \gls{scct}]\label{thm:ccscct:rtp:scct}
  $\rtp{\ccscct}{\scctsafe}$ % \Coqed
\end{theorem}

\subsection{Robust Preservation of Intersection of Memory Safety and Strict Cryptographic Constant Time}

Let $\cc{\Ltms}{\Lscct}$ be the compiler that is the composition of $\cca$, $\ccb$, $\cccf$, $\ccdce$, and $\ccscct$, then the following theorem can be shown.

\begin{theorem}[Compiler $\ccscct$ is secure with respect to \gls{scct}]\label{thm:ccscct:rtp:scct}
  $\rtp{\ccscct}{\scctsafe}$ % \Coqed
\end{theorem}

\begin{theorem}[Compiler $\ccscct$ is secure with respect to \gls{scct}]\label{thm:ccall:rtp:msscct}
  $\rtp{\cc{\Ltms}{\Lscct}}{\mssafe\cap\scctsafe}$ % \Coqed
\end{theorem}

%\begin{lstlisting}[language=c,caption=``Wrong bounds check of two 64-bit integers.'']
%if at <= bounds {
%  x[at] = 42;
%}
%\end{lstlisting}
%Note the subtle bug of using \verb|<=| instead of \verb|<|, leading to an out-of-bounds access whenever \verb|at = bounds|.
%Furthermore, when \verb|at| and \verb|bounds| are 64-bit integers on a 32-bit architecture, the comparison may not be performed in constant-time: The compiler may bail out as soon as the lower 32 bits are unequal, not bothering to compare the higher 32 bits.


\section{Related Work\pages{2}}\label{sec:relwork}

This section compares existing work with the one presented in this paper.
To this end, work on robust preservation criteria (\Cref{subsec:relw:seccomprtp}) and on other secure compiler criteria (\Cref{subsec:relw:seccompcrit}) is being looked at.
The case study of this paper (\Cref{sec:casestud:defs,sec:casestud:rtp}) implements measures for ensuring \gls{ms} as well as \gls{cct} and these are compared with previous work as well (\Cref{subsec:relw:msmechs,subsec:relw:cctmechs}).

\subsection{Secure Compilation as Robust Preservation}\label{subsec:relw:seccomprtp}

The robust preservation of properties as a compiler--level criterion has been analyzed extensively~\cite{abate2019jour,patrignani2021rsc,abate2021extacc,patrignani2022universal,patrignani2019survey,kruse2022csc}.
This work has made use of that previous work.
While there exists a composition theorem~\cite{abate2019jour} already, that theorem is not concerned with composing robustly safe compilers, but rather program components and contexts.
The work relating robust preservation with universal composability~\cite{patrignani2022universal} is closest to what this paper presents.
The authors demonstrate a similar compositionality theorem to what is presented here (\Cref{sec:compcomp}) as well as in an earlier version of this work~\cite{kruse2022csc}.
However, they do not demonstrate the scalability of the approach in the context of a compilation chain.

\subsection{Other Secure Compilation Criteria}\label{subsec:relw:seccompcrit}


\MKin{category theory stuff}
\MKin{full abstraction -> not compositional}
\MKin{compositional compiler correctness?}

\subsection{Memory Safety Mechanisms}\label{subsec:relw:msmechs}

There is still no consensus what the formal definition of memory safety as a program property should be. %cite
Yet, different mechanisms for memory safety exist that also consider the secure compilation domain, i.e., have an attacker model that is not just the observing attacker.
For example, the ,,pointers as capabilities'' principle represents pointers as machine--level capabilities~\cite{korashy2021capableptrs}, which behave in a similar fashion to capabilities by means of  linear typing~\cite{morrisett2005L3}.
The approach of this paper to memory safety and the countermeasures against memory safety insecurities are inspired by seminal work in the literature~\cite{nagarakatte2009soft,nagarakatte2010cets}.
The view of memory safety in this paper exhibits the classic split between temporal and spatial memory safety.
The former making sure that there are no double deallocations or use after frees.
The latter making sure that there are no out of bounds accesses.
When extending the languages in this paper with a less restricted form of pointer arithmetic, the region coloring memory safety monitor presented in earlier work~\cite{michael2023mswasm} can be used.
The work presenting this monitor provides an approach for the robust {\em enforcement}, which implies robust preservation, of memory safety.
But, they do not compose the enforcement mechanism with other secure compilation passes.

\subsection{Cryptographic Constant Time Mechanisms}\label{subsec:relw:cctmechs}

\section{Conclusion\pages{$\sfrac{1}{2}$}}\label{sec:concl}

This paper does a first step towards practical secure compilation chains by introducing a theoretical framework demonstrating that secure compilers compose.
The paper exercises this framework on a case-study that consists of an optimizing compilation chain that is secure with respect to \gls{msscct}.
In future work, it would be interesting to investigate wether it is possible to provide {\em secure compiler combinators}, similarily to how parser combinators work.
%To this end, it may be necessary to extend existing frameworks for multi--language semantics.
It is also interesting to extend our case--study and verify all results of it in Coq.
This way, it is possible to obtain an executable, secure compiler.
However, the formalization effort for backtranslation proofs is known to be enormous, so another research avenue may be to find better ways to (semi-)automate standard secure compilation proofs.

%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
  We would like to thank the anonymous reviewers for their feedback.
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

%%
%% If your work has an appendix, this is the place to put it.
\appendix

\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
