@article{10.1145/1837855.1806657,
author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo M.K. and Zdancewic, Steve},
title = {CETS: Compiler Enforced Temporal Safety for C},
year = {2010},
issue_date = {August 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {8},
issn = {0362-1340},
url = {https://doi.org/10.1145/1837855.1806657},
doi = {10.1145/1837855.1806657},
abstract = {Temporal memory safety errors, such as dangling pointer dereferences and double frees,
are a prevalent source of software bugs in unmanaged languages such as C. Existing
schemes that attempt to retrofit temporal safety for such languages have high runtime
overheads and/or are incomplete, thereby limiting their effectiveness as debugging
aids. This paper presents CETS, a compile-time transformation for detecting all violations
of temporal safety in C programs. Inspired by existing approaches, CETS maintains
a unique identifier with each object, associates this metadata with the pointers in
a disjoint metadata space to retain memory layout compatibility, and checks that the
object is still allocated on pointer dereferences. A formal proof shows that this
is sufficient to provide temporal safety even in the presence of arbitrary casts if
the program contains no spatial safety violations. Our CETS prototype employs both
temporal check removal optimizations and traditional compiler optimizations to achieve
a runtime overhead of just 48% on average. When combined with a spatial-checking system,
the average overall overhead is 116% for complete memory safety},
journal = {SIGPLAN Not.},
month = jun,
pages = {31–40},
numpages = {10},
keywords = {temporal errors, c, dangling pointers, memory safety}
}
@INPROCEEDINGS{watson15,
  author={Watson, Robert N.M. and Woodruff, Jonathan and Neumann, Peter G. and Moore, Simon W. and Anderson, Jonathan and Chisnall, David and Dave, Nirav and Davis, Brooks and Gudka, Khilan and Laurie, Ben and Murdoch, Steven J. and Norton, Robert and Roe, Michael and Son, Stacey and Vadera, Munraj},
  booktitle={2015 IEEE Symposium on Security and Privacy},
  title={CHERI: A Hybrid Capability-System Architecture for Scalable Software Compartmentalization},
  year={2015},
  volume={},
  number={},
  pages={20-37},
  doi={10.1109/SP.2015.9}
}
@misc{vassena19,
  title={Memory Safety Preservation for WebAssembly},
  author={Marco Vassena and Marco Patrignani},
  year={2019},
  eprint={1910.09586},
  archivePrefix={arXiv},
  primaryClass={cs.PL}
}

@inproceedings{sammler21,
  author = {Sammler, Michael and Lepigre, Rodolphe and Krebbers, Robbert and Memarian, Kayvan and Dreyer, Derek and Garg, Deepak},
  title = {RefinedC: Automating the Foundational Verification of C Code with Refined Ownership Types},
  year = {2021},
  isbn = {9781450383912},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3453483.3454036},
  doi = {10.1145/3453483.3454036},
  abstract = {Given the central role that C continues to play in systems software, and the difficulty
  of writing safe and correct C code, it remains a grand challenge to develop effective
  formal methods for verifying C programs. In this paper, we propose a new approach
  to this problem: a type system we call RefinedC, which combines ownership types (for
  modular reasoning about shared state and concurrency) with refinement types (for encoding
  precise invariants on C data types and Hoare-style specifications for C functions).
  RefinedC is both automated (requiring minimal user intervention) and foundational
  (producing a proof of program correctness in Coq), while at the same time handling
  a range of low-level programming idioms such as pointer arithmetic. In particular,
  following the approach of RustBelt, the soundness of the RefinedC type system is justified
  semantically by interpretation into the Coq-based Iris framework for higher-order
  concurrent separation logic. However, the typing rules of RefinedC are also designed
  to be encodable in a new “separation logic programming” language we call Lithium.
  By restricting to a carefully chosen (yet expressive) fragment of separation logic,
  Lithium supports predictable, automatic, goal-directed proof search without backtracking.
  We demonstrate the effectiveness of RefinedC on a range of representative examples
  of C code.},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages = {158–174},
  numpages = {17},
  keywords = {separation logic, ownership types, Iris, Coq, refinement types, C programming language, proof automation},
  location = {Virtual, Canada},
  series = {PLDI 2021}
}

@inproceedings{kouwe17,
  author = {van der Kouwe, Erik and Nigade, Vinod and Giuffrida, Cristiano},
  title = {DangSan: Scalable Use-after-Free Detection},
  year = {2017},
  isbn = {9781450349383},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3064176.3064211},
  doi = {10.1145/3064176.3064211},
  abstract = {Use-after-free vulnerabilities due to dangling pointers are an important and growing
  threat to systems security. While various solutions exist to address this problem,
  none of them is sufficiently practical for real-world adoption. Some can be bypassed
  by attackers, others cannot support complex multithreaded applications prone to dangling
  pointers, and the remainder have prohibitively high overhead. One major source of
  overhead is the need to synchronize threads on every pointer write due to pointer
  tracking.In this paper, we present DangSan, a use-after-free detection system that
  scales efficiently to large numbers of pointer writes as well as to many concurrent
  threads. To significantly reduce the overhead of existing solutions, we observe that
  pointer tracking is write-intensive but requires very few reads. Moreover, there is
  no need for strong consistency guarantees as inconsistencies can be reconciled at
  read (i.e., object deallocation) time. Building on these intuitions, DangSan's design
  mimics that of log-structured file systems, which are ideally suited for similar workloads.
  Our results show that DangSan can run heavily multithreaded applications, while introducing
  only half the overhead of previous multithreaded use-after-free detectors.},
  booktitle = {Proceedings of the Twelfth European Conference on Computer Systems},
  pages = {405–419},
  numpages = {15},
  keywords = {use-after-free, LLVM, Dangling pointers},
  location = {Belgrade, Serbia},
  series = {EuroSys '17}
}

@INPROCEEDINGS{stepanov,
  author={Stepanov, Evgeniy and Serebryany, Konstantin},
  booktitle={2015 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)},
  title={MemorySanitizer: Fast detector of uninitialized memory use in C++},
  year={2015},
  volume={},
  number={},
  pages={46-55},
  doi={10.1109/CGO.2015.7054186}
}

@inproceedings{akritidis09,
  author = {Akritidis, Periklis and Costa, Manuel and Castro, Miguel and Hand, Steven},
  title = {Baggy Bounds Checking: An Efficient and Backwards-Compatible Defense against out-of-Bounds Errors},
  year = {2009},
  publisher = {USENIX Association},
  address = {USA},
  abstract = {Attacks that exploit out-of-bounds errors in C and C++ programs are still prevalent
  despite many years of research on bounds checking. Previous backwards compatible bounds
  checking techniques, which can be applied to unmodified C and C++ programs, maintain
  a data structure with the bounds for each allocated object and perform lookups in
  this data structure to check if pointers remain within bounds. This data structure
  can grow large and the lookups are expensive.In this paper we present a backwards
  compatible bounds checking technique that substantially reduces performance overhead.
  The key insight is to constrain the sizes of allocated memory regions and their alignment
  to enable efficient bounds lookups and hence efficient bounds checks at runtime. Our
  technique has low overhead in practice--only 8% throughput decrease for Apache-- and
  is more than two times faster than the fastest previous technique and about five times
  faster--using less memory--than recording object bounds using a splay tree.},
  booktitle = {Proceedings of the 18th Conference on USENIX Security Symposium},
  pages = {51–66},
  numpages = {16},
  location = {Montreal, Canada},
  series = {SSYM'09}
}

@inproceedings{rigger17,
  author = {Rigger, Manuel and Schatz, Roland and Grimmer, Matthias and M\"{o}ssenb\"{o}ck, Hanspeter},
  title = {Lenient Execution of C on a Java Virtual Machine: Or: How I Learned to Stop Worrying and Run the Code},
  year = {2017},
  isbn = {9781450353403},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3132190.3132204},
  doi = {10.1145/3132190.3132204},
  abstract = {Most C programs do not conform strictly to the C standard, and often show undefined
  behaviors, for instance, in the case of signed integer overflow. When compiled by
  non-optimizing compilers, such programs often behave as the programmer intended. However,
  optimizing compilers may exploit undefined semantics to achieve more aggressive optimizations,
  possibly breaking the code in the process. Analysis tools can help to find and fix
  such issues. Alternatively, a C dialect could be defined in which clear semantics
  are specified for frequently occurring program patterns with otherwise undefined behaviors.
  In this paper, we present Lenient C, a C dialect that specifies semantics for behaviors
  left open for interpretation in the standard. Specifying additional semantics enables
  programmers to make safe use of otherwise undefined patterns. We demonstrate how we
  implemented the dialect in Safe Sulong, a C interpreter with a dynamic compiler that
  runs on the JVM.},
  booktitle = {Proceedings of the 14th International Conference on Managed Languages and Runtimes},
  pages = {35–47},
  numpages = {13},
  keywords = {Sulong, C, Undefined Behavior},
  location = {Prague, Czech Republic},
  series = {ManLang 2017}
}

@InProceedings{tarditi2018,
author = {Tarditi, David and Elliott, Archibald Samuel and Ruef, Andrew and Hicks, Michael},
title = {Checked C: Making C Safe by Extension},
booktitle = {IEEE Cybersecurity Development Conference 2018 (SecDev)},
year = {2018},
month = {September},
abstract = {This paper presents Checked C, an extension to C designed to support spatial safety, implemented in Clang and LLVM. Checked C's design is distinguished by its focus on backward-compatibility, incremental conversion, developer control, and enabling highly performant code. Like past approaches to a safer C, Checked C employs a form of checked pointer whose accesses can be statically or dynamically verified. Performance evaluation on a set of standard benchmark programs shows overheads to be relatively low. More interestingly, Checked C introduces the notions of a checked region and bounds-safe interfaces.

&nbsp;},
publisher = {IEEE},
url = {https://www.microsoft.com/en-us/research/publication/checkedc-making-c-safe-by-extension/},
pages = {53-60},
}

@article{aurajo16,
  title = {Týr: A Dependent Type System for Spatial Memory Safety in LLVM},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {324},
  pages = {3-13},
  year = {2016},
  note = {WEIT 2015, the Third Workshop-School on Theoretical Computer Science},
  issn = {1571-0661},
  doi = {https://doi.org/10.1016/j.entcs.2016.09.003},
  url = {https://www.sciencedirect.com/science/article/pii/S1571066116300469},
  author = {Vítor Bujés Ubatuba {De Araújo} and Álvaro Freitas Moreira and Rodrigo Machado},
  keywords = {Spatial memory, dependent types, type safety, LLVM},
  abstract = {This work proposes a dependent type system for the LLVM Intermediate Representation language for keeping track of pointer bounds information. The system employs a combination of static analysis and runtime checks to avoid spatial memory safety violations, such as buffer overflows. By working on LLVM IR, the system serves a foundation for ensuring spatial memory safety in languages which can be compiled to LLVM, such as C and C++.}
}

@inproceedings{nagarakatte10,
  author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo M.K. and Zdancewic, Steve},
  title = {CETS: Compiler Enforced Temporal Safety for C},
  year = {2010},
  isbn = {9781450300544},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1806651.1806657},
  doi = {10.1145/1806651.1806657},
  abstract = {Temporal memory safety errors, such as dangling pointer dereferences and double frees,
  are a prevalent source of software bugs in unmanaged languages such as C. Existing
  schemes that attempt to retrofit temporal safety for such languages have high runtime
  overheads and/or are incomplete, thereby limiting their effectiveness as debugging
  aids. This paper presents CETS, a compile-time transformation for detecting all violations
  of temporal safety in C programs. Inspired by existing approaches, CETS maintains
  a unique identifier with each object, associates this metadata with the pointers in
  a disjoint metadata space to retain memory layout compatibility, and checks that the
  object is still allocated on pointer dereferences. A formal proof shows that this
  is sufficient to provide temporal safety even in the presence of arbitrary casts if
  the program contains no spatial safety violations. Our CETS prototype employs both
  temporal check removal optimizations and traditional compiler optimizations to achieve
  a runtime overhead of just 48% on average. When combined with a spatial-checking system,
  the average overall overhead is 116% for complete memory safety},
  booktitle = {Proceedings of the 2010 International Symposium on Memory Management},
  pages = {31–40},
  numpages = {10},
  keywords = {dangling pointers, memory safety, temporal errors, c},
  location = {Toronto, Ontario, Canada},
  series = {ISMM '10}
}

@InProceedings{barthe11,
  author="Barthe, Gilles
  and Crespo, Juan Manuel
  and Kunz, C{\'e}sar",
  editor="Butler, Michael
  and Schulte, Wolfram",
  title="Relational Verification Using Product Programs",
  booktitle="FM 2011: Formal Methods",
  year="2011",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="200--214",
  abstract="Relational program logics are formalisms for specifying and verifying properties about two programs or two runs of the same program. These properties range from correctness of compiler optimizations or equivalence between two implementations of an abstract data type, to properties like non-interference or determinism. Yet the current technology for relational verification remains underdeveloped. We provide a general notion of product program that supports a direct reduction of relational verification to standard verification. We illustrate the benefits of our method with selected examples, including non-interference, standard loop optimizations, and a state-of-the-art optimization for incremental computation. All examples have been verified using the Why tool.",
  isbn="978-3-642-21437-0"
}

@article{patrignani18,
  title={Robustly safe compilation or, efficient, provably secure compilation},
  author={Patrignani, Marco and Garg, Deepak},
  journal={arXiv preprint arXiv:1804.00489},
  year={2018}
}

@InProceedings{patrignani19,
  author="Patrignani, Marco
  and Garg, Deepak",
  editor="Caires, Lu{\'i}s",
  title="Robustly Safe Compilation",
  booktitle="Programming Languages and Systems",
  year="2019",
  publisher="Springer International Publishing",
  address="Cham",
  pages="469--498",
  abstract="Secure compilers generate compiled code that withstands many target-level attacks such as alteration of control flow, data leaks or memory corruption. Many existing secure compilers are proven to be fully abstract, meaning that they reflect and preserve observational equivalence. Fully abstract compilation is strong and useful but, in certain cases, comes at the cost of requiring expensive runtime constructs in compiled code. These constructs may have no relevance for security, but are needed to accommodate differences between the source and target languages that fully abstract compilation necessarily needs.",
  isbn="978-3-030-17184-1"
}

@article{patrignani21,
  author    = {Marco Patrignani and
               Deepak Garg},
  title     = {Robustly Safe Compilation, an Efficient Form of Secure Compilation},
  journal   = {{ACM} Trans. Program. Lang. Syst.},
  volume    = {43},
  number    = {1},
  pages     = {1:1--1:41},
  year      = {2021},
  url       = {https://doi.org/10.1145/3436809},
  doi       = {10.1145/3436809},
  timestamp = {Wed, 26 May 2021 08:56:20 +0200},
  biburl    = {https://dblp.org/rec/journals/toplas/PatrignaniG21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{clarkson08,
  author    = {Michael R. Clarkson and
               Fred B. Schneider},
  title     = {Hyperproperties},
  booktitle = {Proceedings of the 21st {IEEE} Computer Security Foundations Symposium,
               {CSF} 2008, Pittsburgh, Pennsylvania, USA, 23-25 June 2008},
  pages     = {51--65},
  publisher = {{IEEE} Computer Society},
  year      = {2008},
  url       = {https://doi.org/10.1109/CSF.2008.7},
  doi       = {10.1109/CSF.2008.7},
  timestamp = {Wed, 16 Oct 2019 14:14:49 +0200},
  biburl    = {https://dblp.org/rec/conf/csfw/ClarksonS08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{abate20,
  author="Abate, Carmine
  and Blanco, Roberto
  and Ciob{\^a}c{\u{a}}, Ștefan
  and Durier, Adrien
  and Garg, Deepak
  and Hrițcu, C{\u{a}}t{\u{a}}lin
  and Patrignani, Marco
  and Tanter, {\'E}ric
  and Thibault, J{\'e}r{\'e}my",
  editor="M{\"u}ller, Peter",
  title="Trace-Relating Compiler Correctness and Secure Compilation",
  booktitle="Programming Languages and Systems",
  year="2020",
  publisher="Springer International Publishing",
  address="Cham",
  pages="1--28",
  abstract="Compiler correctness is, in its simplest form, defined as the inclusion of the set of traces of the compiled program into the set of traces of the original program, which is equivalent to the preservation of all trace properties. Here traces collect, for instance, the externally observable events of each execution. This definition requires, however, the set of traces of the source and target languages to be exactly the same, which is not the case when the languages are far apart or when observations are fine-grained. To overcome this issue, we study a generalized compiler correctness definition, which uses source and target traces drawn from potentially different sets and connected by an arbitrary relation. We set out to understand what guarantees this generalized compiler correctness definition gives us when instantiated with a non-trivial relation on traces. When this trace relation is not equality, it is no longer possible to preserve the trace properties of the source program unchanged. Instead, we provide a generic characterization of the target trace property ensured by correctly compiling a program that satisfies a given source property, and dually, of the source trace property one is required to show in order to obtain a certain target property for the compiled code. We show that this view on compiler correctness can naturally account for undefined behavior, resource exhaustion, different source and target values, side-channels, and various abstraction mismatches. Finally, we show that the same generalization also applies to many secure compilation definitions, which characterize the protection of a compiled program against linked adversarial code.",
  isbn="978-3-030-44914-8"
}

@inproceedings{azevedodeamorim15,
  TITLE = {{Micro-Policies: Formally Verified, Tag-Based Security Monitors}},
  AUTHOR = {Azevedo de Amorim, Arthur and D{\'e}n{\`e}s, Maxime and Giannarakis, Nick and Hriţcu, C{\u a}t{\u a}lin and Pierce, Benjamin  C. and Spector-Zabusky, Antal and Tolmach, Andrew},
  URL = {https://hal.inria.fr/hal-01265666},
  BOOKTITLE = {{2015 IEEE Symposium on Security and Privacy}},
  ADDRESS = {San Jose, United States},
  SERIES = {2015 IEEE Symposium on Security and Privacy},
  PAGES = {813 - 830},
  YEAR = {2015},
  MONTH = May,
  DOI = {10.1109/SP.2015.55},
  KEYWORDS = {control-flow integrity ; memory safety ; Index Terms-security ; dynamic enforcement ; reference mon-itors ; low-level code ; tagged hardware architecture ; metadata ; formal verification ; refinement ; machine-checked proofs ; Coq ; dynamic sealing ; compartmentalization ; isolation ; least privilege},
  PDF = {https://hal.inria.fr/hal-01265666/file/micro-policies.pdf},
  HAL_ID = {hal-01265666},
  HAL_VERSION = {v1},
}

@inproceedings{10.1145/2694344.2694383,
author = {Dhawan, Udit and Hritcu, Catalin and Rubin, Raphael and Vasilakis, Nikos and Chiricescu, Silviu and Smith, Jonathan M. and Knight, Thomas F. and Pierce, Benjamin C. and DeHon, Andre},
title = {Architectural Support for Software-Defined Metadata Processing},
year = {2015},
isbn = {9781450328357},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2694344.2694383},
doi = {10.1145/2694344.2694383},
abstract = {Optimized hardware for propagating and checking software-programmable metadata tags
can achieve low runtime overhead. We generalize prior work on hardware tagging by
considering a generic architecture that supports software-defined policies over metadata
of arbitrary size and complexity; we introduce several novel microarchitectural optimizations
that keep the overhead of this rich processing low. Our model thus achieves the efficiency
of previous hardware-based approaches with the flexibility of the software-based ones.
We demonstrate this by using it to enforce four diverse safety and security policies---spatial
and temporal memory safety, taint tracking, control-flow integrity, and code and data
separation---plus a composite policy that enforces all of them simultaneously. Experiments
on SPEC CPU2006 benchmarks with a PUMP-enhanced RISC processor show modest impact
on runtime (typically under 10%) and power ceiling (less than 10%), in return for
some increase in energy usage (typically under 60%) and area for on-chip memory structures
(110%).},
booktitle = {Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {487–502},
numpages = {16},
keywords = {security, tagged architecture, memory safety, CFI, taint tracking, metadata},
location = {Istanbul, Turkey},
series = {ASPLOS '15}
}



@article{10.1145/2775054.2694383,
author = {Dhawan, Udit and Hritcu, Catalin and Rubin, Raphael and Vasilakis, Nikos and Chiricescu, Silviu and Smith, Jonathan M. and Knight, Thomas F. and Pierce, Benjamin C. and DeHon, Andre},
title = {Architectural Support for Software-Defined Metadata Processing},
year = {2015},
issue_date = {April 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {4},
issn = {0362-1340},
url = {https://doi.org/10.1145/2775054.2694383},
doi = {10.1145/2775054.2694383},
abstract = {Optimized hardware for propagating and checking software-programmable metadata tags
can achieve low runtime overhead. We generalize prior work on hardware tagging by
considering a generic architecture that supports software-defined policies over metadata
of arbitrary size and complexity; we introduce several novel microarchitectural optimizations
that keep the overhead of this rich processing low. Our model thus achieves the efficiency
of previous hardware-based approaches with the flexibility of the software-based ones.
We demonstrate this by using it to enforce four diverse safety and security policies---spatial
and temporal memory safety, taint tracking, control-flow integrity, and code and data
separation---plus a composite policy that enforces all of them simultaneously. Experiments
on SPEC CPU2006 benchmarks with a PUMP-enhanced RISC processor show modest impact
on runtime (typically under 10%) and power ceiling (less than 10%), in return for
some increase in energy usage (typically under 60%) and area for on-chip memory structures
(110%).},
journal = {SIGPLAN Not.},
month = mar,
pages = {487–502},
numpages = {16},
keywords = {CFI, metadata, taint tracking, security, memory safety, tagged architecture}
}

@inproceedings{barthe18,
  TITLE = {{Secure Compilation of Side-Channel Countermeasures: The Case of Cryptographic ``Constant-Time''}},
  AUTHOR = {Barthe, Gilles and Gr{\'e}goire, Benjamin and Laporte, Vincent},
  URL = {https://hal.archives-ouvertes.fr/hal-01959560},
  BOOKTITLE = {{CSF 2018 - 31st IEEE Computer Security Foundations Symposium}},
  ADDRESS = {Oxford, United Kingdom},
  YEAR = {2018},
  MONTH = Jul,
  PDF = {https://hal.archives-ouvertes.fr/hal-01959560/file/main.pdf},
  HAL_ID = {hal-01959560},
  HAL_VERSION = {v1},
}

@article{dhawan15,
author = {Dhawan, Udit and Hritcu, Catalin and Rubin, Raphael and Vasilakis, Nikos and Chiricescu, Silviu and Smith, Jonathan M. and Knight, Thomas F. and Pierce, Benjamin C. and DeHon, Andre},
title = {Architectural Support for Software-Defined Metadata Processing},
year = {2015},
issue_date = {March 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {1},
issn = {0163-5964},
url = {https://doi.org/10.1145/2786763.2694383},
doi = {10.1145/2786763.2694383},
abstract = {Optimized hardware for propagating and checking software-programmable metadata tags
can achieve low runtime overhead. We generalize prior work on hardware tagging by
considering a generic architecture that supports software-defined policies over metadata
of arbitrary size and complexity; we introduce several novel microarchitectural optimizations
that keep the overhead of this rich processing low. Our model thus achieves the efficiency
of previous hardware-based approaches with the flexibility of the software-based ones.
We demonstrate this by using it to enforce four diverse safety and security policies---spatial
and temporal memory safety, taint tracking, control-flow integrity, and code and data
separation---plus a composite policy that enforces all of them simultaneously. Experiments
on SPEC CPU2006 benchmarks with a PUMP-enhanced RISC processor show modest impact
on runtime (typically under 10%) and power ceiling (less than 10%), in return for
some increase in energy usage (typically under 60%) and area for on-chip memory structures
(110%).},
journal = {SIGARCH Comput. Archit. News},
month = mar,
pages = {487–502},
numpages = {16},
keywords = {metadata, memory safety, CFI, taint tracking, security, tagged architecture}
}

@InProceedings{azevedodeamorim18,
  author="Azevedo de Amorim, Arthur
  and Hri{\c{T}}cu, C{\u{a}}t{\u{a}}lin
  and Pierce, Benjamin C.",
  editor="Bauer, Lujo
  and K{\"u}sters, Ralf",
  title="The Meaning of Memory Safety",
  booktitle="Principles of Security and Trust",
  year="2018",
  publisher="Springer International Publishing",
  address="Cham",
  pages="79--105",
  abstract="We give a rigorous characterization of what it means for a programming language to be memory safe, capturing the intuition that memory safety supports local reasoning about state. We formalize this principle in two ways. First, we show how a small memory-safe language validates a noninterference property: a program can neither affect nor be affected by unreachable parts of the state. Second, we extend separation logic, a proof system for heap-manipulating programs, with a ``memory-safe variant'' of its frame rule. The new rule is stronger because it applies even when parts of the program are buggy or malicious, but also weaker because it demands a stricter form of separation between parts of the program state. We also consider a number of pragmatically motivated variations on memory safety and the reasoning principles they support. As an application of our characterization, we evaluate the security of a previously proposed dynamic monitor for memory safety of heap-allocated data.",
  isbn="978-3-319-89722-6"
}

@misc{guarnieri19,
      title={SPECTECTOR: Principled Detection of Speculative Information Flows},
      author={Marco Guarnieri and Boris Köpf and José F. Morales and Jan Reineke and Andrés Sánchez},
      year={2019},
      eprint={1812.08639},
      archivePrefix={arXiv},
      primaryClass={cs.CR}
}

@INPROCEEDINGS{abate19,
  author={Abate, Carmine and Blanco, Roberto and Garg, Deepak and Hritcu, Catalin and Patrignani, Marco and Thibault, Jérémy},
  booktitle={2019 IEEE 32nd Computer Security Foundations Symposium (CSF)},
  title={Journey Beyond Full Abstraction: Exploring Robust Property Preservation for Secure Compilation},
  year={2019},
  volume={},
  number={},
  pages={256-25615},
  doi={10.1109/CSF.2019.00025}
}

﻿@article{Futamura1999,
  author={Futamura, Yoshihiko},
  title={Partial Evaluation of Computation Process--An Approach to a Compiler-Compiler},
  journal={Higher-Order and Symbolic Computation},
  year={1999},
  month={Dec},
  day={01},
  volume={12},
  number={4},
  pages={381-391},
  abstract={This paper reports the relationship between formal description of semantics (i.e., interpreter) of a programming language and an actual compiler. The paper also describes a method to automatically generate an actual compiler from a formal description which is, in some sense, the partial evaluation of a computation process. The compiler-compiler inspired by this method differs from conventional ones in that the compiler-compiler based on our method can describe an evaluation procedure (interpreter) in defining the semantics of a programming language, while the conventional one describes a translation process.},
  issn={1573-0557},
  doi={10.1023/A:1010095604496},
  url={https://doi.org/10.1023/A:1010095604496}
}

@article{exorcisingSpectres,
  author    = {Marco Guarnieri and
               Marco Patrignani},
  title     = {Exorcising Spectres with Secure Compilers},
  journal   = {CoRR},
  volume    = {abs/1910.08607},
  year      = {2019},
  url       = {http://arxiv.org/abs/1910.08607},
  eprinttype = {arXiv},
  eprint    = {1910.08607},
  timestamp = {Tue, 22 Oct 2019 18:17:16 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1910-08607.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{lattner04,
     Author  = {Chris Lattner and Vikram Adve},
     Title = {{LLVM}: A Compilation Framework for Lifelong Program
Analysis and Transformation},
     Booktitle = CGO,
     Address = {San Jose, CA, USA},
     Month = {Mar},
     Year  = {2004},
     pages       = {75--88},
}

@misc{kruse23,
  title={Secure Composition of Robust and Optimising Compilers}, 
  author={Matthis Kruse and Michael Backes and Marco Patrignani},
  year={2023},
  eprint={2307.08681},
  archivePrefix={arXiv},
  primaryClass={cs.CR}
}

@article{abate21,
  title={An extended account of trace-relating compiler correctness and secure compilation},
  author={Abate, Carmine and Blanco, Roberto and Ciob{\^a}c{\u{a}}, {\c{S}}tefan and Durier, Adrien and Garg, Deepak and Hri{\c{t}}cu, C{\u{a}}t{\u{a}}lin and Patrignani, Marco and Tanter, {\'E}ric and Thibault, J{\'e}r{\'e}my},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={43},
  number={4},
  pages={1--48},
  year={2021},
  publisher={ACM New York, NY}
}

@inproceedings{kruse22,
 author = {Matthis Kruse, Marco Patrignani},
 maintitle = {ACM SIGPLAN Workshop on Principles of Secure Compilation},
 month = {January},
 title = {Composing Secure Compilers},
 year = {2022}
}

@misc{pizlo18,
  author = {Filip Pizlo},
  year = {2018},
  title = {What Spectre and Meltdown Mean For WebKit},
  howpublished = {https://webkit.org/blog/8048/what-spectre-and-meltdown-mean-for-webkit/}
}

@misc{turnerret,
  author = {Paul Turner},
  title = {Retpoline: a software construct for preventing branch-target-injection},
  howpublished = {https://support.google.com/faqs/answer/7625886}
}

@article{taram22,
  title={Mitigating speculative execution attacks via context-sensitive fencing},
  author={Taram, Mohammadkazem and Venkat, Ashish and Tullsen, Dean},
  journal={IEEE Design \& Test},
  year={2022}
}

@misc{redhatmsr,
  author = {Red Hat},
  title = {Controlling the Performance Impact of Microcode and Security Patches for CVE-2017-5754 CVE-2017-5715 and CVE-2017-5753 using Red Hat Enterprise Linux Tunables},
  howpublished = {https://access.redhat.com/articles/3311301}
}

@inproceedings{patrignani21b,
  title={Exorcising Spectres with secure compilers},
  author={Patrignani, Marco and Guarnieri, Marco},
  booktitle={Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security},
  pages={445--461},
  year={2021}
}

@article{markey03,
  title={Temporal logic with past is exponentially more succinct},
  author={Markey, Nicolas},
  journal={Bulletin-European Association for Theoretical Computer Science},
  volume={79},
  pages={122--128},
  year={2003},
  publisher={European Association for Theoretical Computer Science}
}
