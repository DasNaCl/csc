%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
\documentclass[sigplan,dvipsnames]{acmart}\settopmatter{}
%% "not anonymous"
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'22]{ACM SIGPLAN Workshop on Principles of Secure Compilation}{January 22nd, 2022}{Philadelphia, PA, USA}
\acmYear{2022}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1} 

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2022}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\hmmax{0}
\newcommand\bmmax{0}

%% Some recommended packages.
\usepackage[colorinlistoftodos]{todonotes}
\newcommand{\MK}[1]{\todo[color=orange!30]{TODO: #1}}
\newcommand{\MP}[1]{\todo[color=blue!30]{TODO: #1}}

\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{stmaryrd}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{cleveref}
\usepackage{listings}
\usepackage{./../mmmacros}
\usepackage[switch]{lineno}
%\modulolinenumbers[2]
\renewcommand{\linenumberfont}{\normalfont\bfseries\small\color{red}}

\begin{document}

%% Title information
\title{Composing Compilers}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Matthis Kruse}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0003-4062-9666}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{CISPA Helmholtz Center for Information Security}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
  \country{Germany}                    %% \country is recommended
}
\email{matthis.kruse@cispa.de}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Marco Patrignani}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0003-3411-9678}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
%  \department{Department2a}             %% \department is recommended
  \institution{CISPA Helmholtz Center for Information Security}            %% \institution is required
%  \streetaddress{Street2a Address2a}
%  \city{City2a}
%  \state{State2a}
%  \postcode{Post-Code2a}
  \country{Germany}                   %% \country is recommended
}
\email{marco.patrignani@cispa.de}         %% \email is recommended

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
%\begin{abstract}
%Text of abstract \ldots.
%\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10011007.10011006.10011008</concept_id>
%<concept_desc>Software and its engineering~General programming languages</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%<concept>
%<concept_id>10003456.10003457.10003521.10003525</concept_id>
%<concept_desc>Social and professional topics~History of programming languages</concept_desc>
%<concept_significance>300</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}

%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
%\keywords{compilers, security}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\linenumbers

\section{Introduction}

Compilers translate programs from a source to a target programming language.
Secure Compilation studies the preservation of security properties and hyperproperties when compiling a source to a target program.
Robust Compilation~\cite{patrignani18,abate2019,patrignani19,patrignani21} is a novel compiler property that does not require the compiler to add such unnecessary measures.
Informally, if a given (partial) source program linked with an arbitrary source context satisfies some properties of interest, so should its compiled version linked with an arbitrary target context.
Even though there exist robust compilers, they are far from practical.
Real-world compilers consist of several smaller compilers that are composed with each other in a certain way.
A prominent example would be any compiler based on the LLVM toolchain~\cite{lattner04}, whose optimization pipeline consists of many passes, which one can view as independent compilers composed to achieve speedups.
To the best of our knowledge, current work does not discuss which properties are preserved by compilation chains.

This paper investigates how different compiler compositions preserve hyperproperties, given that the compilers involved in the composition fulfil certain assumptions.
To reason about hyperproperty preservation, we will look at the lattice of classes of hyperproperties.
Within the lattice of such classes, we examine whether at least the least upper bound is preserved by our chosen compositions.
We conclude with a preliminary result: We show that the order of optimizations in a compilation pipeline does not matter for property preservation, assuming that each such pass preserves the class of interest.

\section{Compositionality}
Programs are written in some programming language.
In this work, programs are elements of $\partials$, the set of partial programs of a given programming language.
A compiler between languages $\S$ and $\T$ is a partial function $\stcomp{\bullet}$ from $\src{\partials}$ to $\trg{\partials}$.
To reason about the preservation of program behaviour (hyperproperties~\cite{clarkson08}), we have to define a suitable compiler property.

\begin{definition}[Robust Trace-Hyperproperty Preservation]\label{def:rtp}
  For a given class $\cC$, a compiler from languages $\S$ to $\T$ robustly preserves $\cC$ iff
  $$
  \forall\Pi\in\cC,\forall\src{p}\in\src{\partials},\rsat{\src{p}}{\Pi}\implies\rsat{\stcomp{\src{p}}}{\Pi}
  $$
  We write $\rtp{\stcomp{\bullet}}{\cC}$.
\end{definition}
\noindent
So, given any restriction on a program's behavior $\Pi$ and a source program $\src{p}$ that robustly satisfies $\Pi$ ($\rsat{\src{p}}{\Pi}$), the compiled program $\stcomp{\src{p}}$ also needs to robustly satisfy $\Pi$.
The intuition of \Cref{def:rtp} is as follows: If the programmer makes certain assumptions on what a program does, these assumptions should also hold for the compiled program.
% example (?)
Practical compilers are composed of numerous others.
Therefore, we now investigate the compositionality of robust compilers.

We begin with the most straightforward one, which coincides with ordinary function composition.
From a practical perspective, this means plugging the result of one compiler into another one.
Such pipelines happen when optimizing source code, so at the level of a suitable intermediate representation, but also on a higher level:
Consider as an example a typical TypeScript compilation pipeline.
First, it translates TypeScript code to JavaScript, which V8 compiles to Ignition bytecode that, after some runtime-performance analysis, is just-in-time compiled via TurboFan to machine code such as x86.

\begin{definition}[Sequential Composition of Compilers]
  Given two compilers $\sicomp{\bullet}$ and $\itcomp{\bullet}$, their sequential composition is $\sitcomp{\bullet}=\itcompN{\sicomp{\bullet}}$.
\end{definition}
Now, assuming that two compilers preserve certain classes, we know that their sequential composition preserves the least upper bound:
\begin{lemma}[Sequential Composition with RTP]\label{lem:seqcompo}
  Given $\rtp{\sicomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\sitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
The lemma also generalizes to $n$ robust compilers, each preserving one of $n$ classes.

An intuitive lemma that also follows is that a robust compiler preserving some class $\cC_{2}\supseteq\cC_{1}$ also preserves $\cC_{1}$.
\begin{lemma}[Weakening RTP]\label{lem:weaken}
  Given classes $\cC_{1}, \cC_{2}$ such that $\cC_{1}\subseteq\cC_{2}$ and $\rtp{\stcomp{\bullet}}{\cC_{2}}$, it holds that $\rtp{\stcomp{\bullet}}{\cC_{1}}$.
\end{lemma}

We now consider a compiler that invokes two other compilers.
HTML, CSS, and JavaScript are the most obvious example of such a composition.
One writes down some code of any of these three languages embedded in the same file, but different compiler toolchains process them.

\begin{definition}[Upper Composition]
  Given two compilers $\stcomp{\bullet}$ and $\itcomp{\bullet}$, their upper composition is

  $$\uhcsitcomp{\bullet}=\lambda p.\begin{cases}\stcomp{p} &\text{if }p\in\src{\partials}\\
                                                \itcomp{p} &\text{if }p\in\irl{\partials}\end{cases}$$.
\end{definition}
\noindent
We can derive a similar result to \Cref{lem:seqcompo}:
\begin{lemma}[Upper Composition with RTP]\label{lem:useqcompo}
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\itcomp{\bullet}}{\cC_{2}}$, then $\rtp{\uhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}
\Cref{lem:useqcompo} also generalizes to a number of compilers and classes, as expected.

With the same idea, we define a dual composition that goes from a single source language to multiple target languages.
RubyOnRails is a framework where the processed code is emitted to different target languages at once, in this case, HTML and JavaScript.
\begin{definition}[Lower Composition]
  Given two compilers $\stcomp{\bullet}$ and $\sicomp{\bullet}$, their lower composition is $\lhcsitcomp{\bullet}$.
\end{definition}

\begin{lemma}[Lower Composition with RTP]
  Given $\rtp{\stcomp{\bullet}}{\cC_{1}}$ and $\rtp{\sicomp{\bullet}}{\cC_{2}}$, then $\rtp{\lhcsitcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}

%\MP{Confusing and possibly wrong}
%Using the upper and lower composition, we may end up with a diamond situation, which the following lemma describes.
%Especially from a security researcher perspective, the diamond lemma is attractive as it says that there is no harm to prove compiler passes robust property preserving in a modular way.
%That is, consider some program instrumented against SPECTRE v1 attacks and, in parallel to that, against SPECTRE v4.
%If the compiler instrumentation for v1 does not violate v4, the lemma tells us that combining both instrumentations in some way yields an instrumentation that protects against both v1 and v4.

%\begin{lemma}[Diamond]\label{lem:diamond}
%  Given $\rtp{\lhcsiocomp{\bullet}}{\cC_{1}}$ and $\rtp{\uhciotcomp{\bullet}}{\cC_{2}}$ with $\stcomp{\bullet} = \lambda\src{p}.\uhciotcomp{\lhcsiocomp{p}}$, then $\rtp{\stcomp{\bullet}}{\cC_{1}\cap\cC_{2}}$.
%\end{lemma}

The following free theorem is a direct consequence of \Cref{lem:seqcompo} where the involved compilers' input and output are both partial programs in the same language.
Given that some compiler passes are robustly preserving properties, we can combine them in an arbitrary order and preserve the same least upper bound.
A compiler's pipeline ordering is difficult and often hand-tuned.
The lemma allows us to not care about the particular order of optimizations regarding their robust property preservation.
So, the compiler developer is free to swap passes around.
\begin{lemma}[Swappable]
  Given $\rtp{\ttcomp{\bullet}_{(1)}}{\cC_{1}}$ and $\rtp{\ttcomp{\bullet}_{(2)}}{\cC_{2}}$, then $\rtp{\ttcompN{\ttcomp{\bullet}_{(2)}}_{(1)}}{\cC_{1}\cap\cC_{2}}$ and $\rtp{\ttcompN{\ttcomp{\bullet}_{(1)}}_{(2)}}{\cC_{1}\cap\cC_{2}}$.
\end{lemma}

However, in practice, compiler passes are not necessarily robustly preserving.
Consider the following C code snippet that performs an infinite loop if an invalid pointer is given:
\begin{lstlisting}[language=c]
int something(int* ptr) {
  while(!ptr);
  return *ptr;
}
\end{lstlisting}
Compiling such code with optimizations turned on yields an x86-program where the potentially infinite loop has been removed:
\begin{lstlisting}[language={[x86masm]Assembler}]
something(int*):
  mov eax, DWORD PTR [rdi]
  ret
\end{lstlisting}
Not only does the program terminate given an invalid pointer, it violates memory safety, which it did not before.

There exist several memory-safety instrumentations, both for target level~\cite{watson15,aurajo16,vassena19,kouwe17} and source level~\cite{nagarakatte10,akritidis09,rigger17,tarditi2018}.
These compilation passes \textit{enforce} memory safety by adding dynamic checks to the program and crashing appropriately.
So, even though the programmer has written a memory-insecure program, we might still be interested in a memory-safe binary.

We plan to extend our work with such source-code instrumentations, which enforce classes of trace hyperproperties.
A sketch of the theory is as follows.

\begin{definition}[Secure Instrumentation for Preserving $\cC$]\label{def:secure-instrumentation}
  A secure instrumentation with respect to some class $\cC$ ensures hyperproperties described by some class $\cC'$ without violating $\cC$-satisfying programs:

  \begin{enumerate}
  \item $\rtp{\stcomp{\bullet}}{\cC}$
  \item $\rtp{\stcomp{\bullet}}{\cC}\implies\rtp{\stcomp{\bullet}}{\cC\cup\cC'}$
  \end{enumerate}

\noindent
  We write $\sinstr{\stcomp{\bullet}}{\cC'}{\cC}$.
\end{definition}
We can now investigate an insecure compilation chain from e.g.\ memory-safe Rust to optimized, insecure C, to memory-safe CheckedC.
The intuition that a secure instrumentation saves the day holds and is captured by the following lemma.
\begin{lemma}[Final Enforcement]
  Given classes $\cC_{1},\cC_{2}$ and compilers $\sicomp{\bullet}$,$\itcomp{\bullet}$, we assume:

  \begin{itemize}
  \item $\rtp{\sicomp{\bullet}}{\cC_{1}}$
  \item $\sinstr{\itcomp{\bullet}}{\cC_{2}}{\cC_{1}}$
  \end{itemize}
\noindent
  Then, $\rtp{\sitcomp{\bullet}}{\cC_{1}\cup\cC_{2}}$.
\end{lemma}

Likewise, running a compiler that does not respect e.g.\ memory-safety after a memory-safety instrumentation nullifies the preservation of memory-safety:
\begin{lemma}[Final Destination]
  Given classes $\cC_{1},\cC_{2}$ and compilers $\sicomp{\bullet}$,$\itcomp{\bullet}$, we assume:

  \begin{itemize}
  \item $\sinstr{\sicomp{\bullet}}{\cC_{2}}{\cC_{1}}$
  \item $\rtp{\itcomp{\bullet}}{\cC_{1}}$
  \end{itemize}
\noindent
  Then, $\rtp{\sitcomp{\bullet}}{\cC_{1}}$.
\end{lemma}

Now, consider any stereotypical compilation pipeline.
The security researcher has a strong interest to ensure that properties at the source level are preserved at the target level.
Thus, if source programs robustly satisfy some property, so should the target.
However, it might not be necessary for compilation passes from one intermediate representation to the other to preserve properties robustly since compiler intermediate representations are outside the considered attack vector.
So, there might be some weaker property a pass has to satisfy in order to render the whole compilation pipeline secure.

We intend to study property-free characterizations of the presented material.
Another area is its specialization to specific classes, such as $\cSafety$, and subsets thereof.

%% Acknowledgments
%\begin{acks}                            %% acks environment is optional
%                                        %% contents suppressed with 'anonymous'
%  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
%  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
%  %% acknowledge financial support and will be used by metadata
%  %% extraction tools.
%  This material is based upon work supported by the
%  \grantsponsor{GS100000001}{National Science
%    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
%  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
%  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
%  conclusions or recommendations expressed in this material are those
%  of the author and do not necessarily reflect the views of the
%  National Science Foundation.
%\end{acks}


%% Bibliography
\bibliography{library}


%% Appendix
%\appendix
%\section{Appendix}

%Text of appendix \ldots

\end{document}
