% Fixing: Too many math alphabets used in version normal.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\documentclass[12pt]{article}
\usepackage[left=1.0cm,top=1.5cm,right=1.0cm,bottom=1.5cm]{geometry}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage[numbers]{natbib}
\usepackage{trimclip}
\makeatletter
\DeclareRobustCommand{\circbullet}{\mathbin{\vphantom{\circ}\text{\circbullet@}}}
\newcommand{\circbullet@}{%
  \check@mathfonts
  \m@th\ooalign{%
    \clipbox{0 0 0 {\dimexpr\height-\fontdimen22\textfont2}}{$\bullet$}\cr
    $\circ$\cr
  }%
}
\DeclareRobustCommand{\bulletcirc}{\mathbin{\text{\bulletcirc@}}}
\newcommand{\bulletcirc@}{%
  \check@mathfonts
  \m@th\ooalign{%
    \raisebox{\fontdimen22\textfont2}{\clipbox{0 {\fontdimen22\textfont2} 0 0}{$\bullet$}}\cr
    $\circ$\cr
  }%
}
\makeatother

% https://tex.stackexchange.com/questions/648845/sans-serif-uppercase-greek-no-longer-showing-in-acmart
\DeclareMathAlphabet{\mathsf}{OT1}{LibertinusSans-LF}{m}{n}
\SetMathAlphabet{\mathsf}{bold}{OT1}{LibertinusSans-LF}{bx}{n}
\DeclareMathAlphabet{\mathtt}{OT1}{lmtt}{m}{n}
\SetMathAlphabet{\mathtt}{bold}{OT1}{lmtt}{bx}{n}

\input{cmds.tex}

\newcommand{\ccseqct}{\ensuremath\llbracket\cdot\rrbracket^{\text{seq}}_{\text{ct}}}
\newcommand{\ccseqmem}{\ensuremath\llbracket\cdot\rrbracket^{\text{seq}}_{\text{mem}}}
\newcommand{\ccspecmem}{\ensuremath\llbracket\cdot\rrbracket^{\text{spec}}_{\text{mem}}}
\newcommand{\ccspecct}{\ensuremath\llbracket\cdot\rrbracket^{\text{spec}}_{\text{ct}}}
\newcommand{\ccspecpathct}{\ensuremath\llbracket\cdot\rrbracket^{\text{spec}}_{\text{ct}}}
\newcommand{\ccseqarch}{\ensuremath\llbracket\cdot\rrbracket^{\text{seq}}_{\text{arch}}}
\newcommand{\ccspecarch}{\ensuremath\llbracket\cdot\rrbracket^{\text{spec}}_{\text{arch}}}
\newcommand{\ccseqspecctpc}{\ensuremath\llbracket\cdot\rrbracket^{\text{seq-spec}}_{\text{ct-pc}}}
\newcommand{\ccbot}{\ensuremath\llbracket\cdot\rrbracket_\top}

\newcommand{\partialsec}{\ensuremath\circbullet}
\newcommand{\fullsec}{\ensuremath\bullet}

\newcommand{\proven}{\ensuremath\checkmark}
\newcommand{\partiallyproven}{\ensuremath(\checkmark)}
\newcommand{\informal}{\ensuremath\times}

\newcommand{\specpht}{\ensuremath\text{PHT}}
\newcommand{\specssb}{\ensuremath\text{SSB}} %is this relevant?
\newcommand{\specrsb}{\ensuremath\text{RSB}}
\newcommand{\specbtb}{\ensuremath\text{BTB}}
\newcommand{\specstl}{\ensuremath\text{STL}}
\newcommand{\specpsf}{\ensuremath\text{PSF}}

\loadglsentries{acronyms}
\makeglossaries

\begin{document}

\begin{center}
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    Ref. &
    Cont. &
    Variants &
    Mitigations &
    Proof &
    Security &
    Platform
    \\\hline
    %
    \cite{vassena2021blade} &
    \acrshort{ccspecct} &
    $\specpht,\specrsb$ &
    \acrshort{fi}, \acrshort{slh} &
    $\partiallyproven$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    \cite{elatali2024cmr} &
    \acrshort{ccspecct} &
    $\specpht,\specrsb$ &
    \acrshort{cmr} &
    $\informal$ &
    $\partialsec$ &
    \acrshort{hs}
    \\
    %
    \cite{yu2019stt} &
    \acrshort{ccspecarch} &
    $\specpht$ &
    \acrshort{dtt} &
    $\partiallyproven$ &
    $\partialsec$ &
    \acrshort{h}
    \\
    %
    \cite{lfence} &
    ? &
    $\specpht$ &
    \acrshort{fi} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    \cite{lfence} &
    ? &
    $\specssb$ &
    \acrshort{msr} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}/\acrshort{h}
    \\
    %
    \cite{mosier2023serberus} &
    \acrshort{ccspecct} &
    $\specpht$, $\specbtb$, $\specrsb$, $\specstl$, $\specpsf$ &
    \acrshort{fi},\acrshort{iso},\acrshort{rz} &
    $\partiallyproven$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    \cite{narayan2021swivel} &
    \acrshort{ccspecmem} &
    $\specpht$, $\specbtb$, $\specrsb$, $\specstl$, $\specpsf$ &
    \acrshort{iso},\acrshort{sm},\acrshort{ri} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}/\acrshort{h}
    \\
    %
    \cite{barber2019specshield} &
    \acrshort{ccspecmem} &
    $\specpht$, $\specbtb$, $\specssb$, $\specstl$ &
    - &
    $\informal$ &
    $\partialsec$ &
    \acrshort{hs}
    \\
    %
    \cite{weisse2019nda} &
    ? &
    $\specpht$, $\specbtb$, $\specrsb$, $\specssb$, $\specstl$ &
    - &
    $\informal$ &
    $\fullsec$ &
    \acrshort{hs}
    \\
    %
    \cite{schwarz2019context} &
    ? &
    $\specpht$, $\specbtb$, $\specrsb$, $\specssb$, $\specstl$ &
    \acrshort{ntmmap} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}/\acrshort{h}
    \\
    %
    \cite{khasawneh2018safespec} &
    \acrshort{ccspecct} &
    $\specpht$, $\specbtb$ &
    \acrshort{sm} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{h}
    \\
    %
    % authors claim compositionality with fencing and sandboxing
    % however, it's not robust: they assume all code to follow a certain scheme
    \cite{shen2019venkman} &
    \acrshort{ccspecct} &
    $\specbtb$, $\specrsb$ &
    \acrshort{fi},\acrshort{iso} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    % claim it combines well with safespec and invisspec (both are hardware)
    \cite{koruyeh2019speccfi} &
    \acrshort{ccspecct} &
    $\specbtb$, $\specrsb$ &
    \acrshort{cfi} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}/\acrshort{h}
    \\
    %
    \cite{yan2018invisispec} &
    \acrshort{ccspecct} &
    $\specpht$, $\specbtb$, $\specrsb$, $\specssb$, $\specstl$  &
    \acrshort{iso} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{h}
    \\
    %
    \cite{eleksenko2018bypass} &
    ? &
    $\specpht$ &
    \acrshort{add} &
    $\informal$ &
    ? &
    \acrshort{s}
    \\
    %
    \cite{slh} &
    ? &
    $\specpht$ &
    \acrshort{slh} &
    $\informal$ &
    $\partialsec$ & % may leak data accessed non-speculativey
                    % misses variable time instructions
    \acrshort{s}
    \\
    %
    \cite{patrignani2021exorcising} &
    \acrshort{ccspecct} &
    $\specpht$ &
    \acrshort{sslh} &
    $\proven$ &
    $\partialsec$ & % misses variable time instructions
    \acrshort{s}
    \\
    %
    \cite{zhang2023uslh} &
    \acrshort{ccspecct} &
    $\specpht$ &
    \acrshort{uslh} &
    $\proven$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    \cite{taram2019csf} &
    \acrshort{ccspecct} &
    $\specpht$, $\specrsb$, $\specbtb$ &
    \acrshort{fi} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{h}
    \\
    %
    \hline
  \end{tabular}
\end{center}

\footnotetext{
The above table uses execution modes \gls{seq}, \gls{seq-ooo}, \gls{spec}, and \gls{spec-ooo}.
Moreover, it relies on observers \gls{ctobs}, \gls{pathctobs}, \gls{memobs}, and \gls{archobs}.
}

\clearpage

\section{Observers}

\[
  \begin{array}{rcl}
  \ccseqct &-&
    \begin{array}{rcl}
      \seqctEvent & = & \seqctev{\emptyevent} \mid %
                        \seqctev{\lightning} \mid %
                        \seqctev{Load\;\varLoc} \mid %
                        \seqctev{Store\;\varLoc} \mid %
                        \seqctev{Pc\;n}
    \end{array} \\
  \ccspecct &-&
    \begin{array}{rcl}
      \specctEvent & = & \specctev{\emptyevent} \mid %
                         \specctev{\lightning} \mid %
                         \specctev{Load\;\varLoc} \mid %
                         \specctev{Store\;\varLoc} \mid %
                         \specctev{Pc\;n} \mid %
                         \specctev{Spec} \mid %
                         \specctev{Rlb} 
    \end{array} \\
  \ccseqmem &-&
    \begin{array}{rcl}
      \seqmemEvent & = & \seqmemev{\emptyevent} \mid %
                         \seqmemev{\lightning} \mid %
                         \seqmemev{Load\;\varLoc} \mid %
                         \seqmemev{Store\;\varLoc}
    \end{array} \\
  \ccspecmem &-&
    \begin{array}{rcl}
      \specmemEvent & = & \specmemev{\emptyevent} \mid %
                          \specmemev{\lightning} \mid %
                          \specmemev{Load\;\varLoc} \mid %
                          \specmemev{Store\;\varLoc} \mid %
                          \specmemev{Spec} \mid %
                          \specmemev{Rlb} 
    \end{array} \\
  \ccseqarch &-&
    \begin{array}{rcl}
      \seqarchEvent & = & \seqarchev{\emptyevent} \mid %
                          \seqarchev{\lightning} \mid %
                          \seqarchev{Load\;\varLoc\;v} \mid %
                          \seqarchev{Store\;\varLoc\;v} \mid %
                          \seqarchev{Pc\;n}
    \end{array} \\
  \ccspecarch &-&
    \begin{array}{rcl}
      \specarchEvent & = & \specarchev{\emptyevent} \mid %
                           \specarchev{\lightning} \mid %
                           \specarchev{Load\;\varLoc\;v} \mid %
                           \specarchev{Store\;\varLoc\;v} \mid %
                           \specarchev{Pc\;n} \mid %
                           \specarchev{Spec} \mid %
                           \specarchev{Rlb} 
    \end{array} \\
  \end{array}
\]

\section{Mappings between Observers}

\subsection{Sequential to Speculative}

All relations presented in this section share the same key idea, so it is mostly repetitive. 
The key insight is to index the relations by natural numbers in order to keep track of the depth of nested speculation and ignore if the depth is non-zero, i.e., if there is speculation.
The trace-level versions have to do minor bookkeeping to count speculation depth, but the counting is done at event-level.

\paragraph{Constant-Time} $\;$\\

\judgbox{\seqctTOspecct{n}{m} : \seqctEvent\to\specctEvent\to\mathbb{P}}{,,Map sequential constant time to speculative constant time events.\\%
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqct-to-specct-empty}{}{
    \seqctev{\emptyevent}\seqctTOspecct{n}{n}\specctev{\emptyevent}
  }{seqct-to-specct-empty}
  %
  \typerule{seqct-to-specct-crash}{}{
    \seqctev{\lightning}\seqctTOspecct{n}{n}\specctev{\lightning}
  }{seqct-to-specct-crash}
  %
  \typerule{seqct-to-specct-pc}{}{
    \seqctev{Pc\;n}\seqctTOspecct{0}{0}\specctev{Pc\;n}
  }{seqct-to-specct-pc}
  %
  \typerule{seqct-to-specct-store}{}{
    \seqctev{Store\;\varLoc}\seqctTOspecct{0}{0}\specctev{Store\;\varLoc}
  }{seqct-to-specct-store}
  %
  \typerule{seqct-to-specct-load}{}{
    \seqctev{Load\;\varLoc}\seqctTOspecct{0}{0}\specctev{Load\;\varLoc}
  }{seqct-to-specct-load}
  %
  \typerule{seqct-to-specct-spec}{
  }{
    \emptyevent\seqctTOspecct{n}{1+n}\specctev{Spec}
  }{seqct-to-specct-spec}
  %
  \typerule{seqct-to-specct-rlb}{
  }{
    \emptyevent\seqctTOspecct{1+n}{n}\specctev{Rlb}
  }{seqct-to-specct-rlb}
  %
  \typerule{seqct-to-specct-pc-ign}{}{
    \seqctev{\emptyevent}\seqctTOspecct{1+n}{1+n}\specctev{Pc\;m}
  }{seqct-to-specct-pc-ign}
  %
  \typerule{seqct-to-specct-store-ign}{}{
    \seqctev{\emptyevent}\seqctTOspecct{1+n}{1+n}\specctev{Store\;\varLoc}
  }{seqct-to-specct-store-ign}
  %
  \typerule{seqct-to-specct-load-ign}{}{
    \seqctev{\emptyevent}\seqctTOspecct{1+n}{1+n}\specctev{Load\;\varLoc}
  }{seqct-to-specct-load-ign}
\end{center}
\judgbox{\seqctTOspeccttr{n}{m} : \seqctTrace\to\specctTrace\to\mathbb{P}}{,,Map sequential constant time to speculative constant time events.\\
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqct-to-specct-refl}{}{
    \hole{\cdot}\seqctTOspeccttr{0}{0}\hole{\cdot}
  }{seqct-to-specct-refl}
  %
  \typerule{seqct-to-specct-trans}{
    \varEvent\seqctTOspecct{n}{m'}\varEvent' \rulesep
    \varTrace\seqctTOspeccttr{m'}{m}\varTrace
  }{
    \varEvent\cdot\varTrace\seqctTOspeccttr{n}{m}\varEvent'\cdot\varTrace'
  }{seqct-to-specct-trans}
\end{center}

\paragraph{Memory} $\;$\\

\judgbox{\seqmemTOspecmem{n}{m} : \seqmemEvent\to\specmemEvent\to\mathbb{P}}{,,Map sequential memory to speculative memory events.\\%
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqmem-to-specmem-empty}{}{
    \seqmemev{\emptyevent}\seqmemTOspecmem{n}{n}\specmemev{\emptyevent}
  }{seqmem-to-specmem-empty}
  %
  \typerule{seqmem-to-specmem-crash}{}{
    \seqmemev{\lightning}\seqmemTOspecmem{n}{n}\specmemev{\lightning}
  }{seqmem-to-specmem-crash}
  %
  \typerule{seqmem-to-specmem-store}{}{
    \seqmemev{Store\;\varLoc}\seqmemTOspecmem{0}{0}\specmemev{Store\;\varLoc}
  }{seqmem-to-specmem-store}
  %
  \typerule{seqmem-to-specmem-load}{}{
    \seqmemev{Load\;\varLoc}\seqmemTOspecmem{0}{0}\specmemev{Load\;\varLoc}
  }{seqmem-to-specmem-load}
  %
  \typerule{seqmem-to-specmem-spec}{
  }{
    \emptyevent\seqmemTOspecmem{n}{1+n}\specmemev{Spec}
  }{seqmem-to-specmem-spec}
  %
  \typerule{seqmem-to-specmem-rlb}{
  }{
    \emptyevent\seqmemTOspecmem{1+n}{n}\specmemev{Rlb}
  }{seqmem-to-specmem-rlb}
  %
  \typerule{seqmem-to-specmem-store-ign}{}{
    \seqmemev{\emptyevent}\seqmemTOspecmem{1+n}{1+n}\specmemev{Store\;\varLoc}
  }{seqmem-to-specmem-store-ign}
  %
  \typerule{seqmem-to-specmem-load-ign}{}{
    \seqmemev{\emptyevent}\seqmemTOspecmem{1+n}{1+n}\specmemev{Load\;\varLoc}
  }{seqmem-to-specmem-load-ign}
\end{center}
\judgbox{\seqmemTOspecmemtr{n}{m} : \seqmemTrace\to\specmemTrace\to\mathbb{P}}{,,Map sequential memory to speculative memory events.\\
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqmem-to-specmem-refl}{}{
    \hole{\cdot}\seqmemTOspecmemtr{0}{0}\hole{\cdot}
  }{seqmem-to-specmem-refl}
  %
  \typerule{seqmem-to-specmem-trans}{
    \varEvent\seqmemTOspecmem{n}{m'}\varEvent' \rulesep
    \varTrace\seqmemTOspecmemtr{m'}{m}\varTrace
  }{
    \varEvent\cdot\varTrace\seqmemTOspecmemtr{n}{m}\varEvent'\cdot\varTrace'
  }{seqmem-to-specmem-trans}
\end{center}


\paragraph{Architecture} $\;$\\


\judgbox{\seqarchTOspecarch{n}{m} : \seqarchEvent\to\specarchEvent\to\mathbb{P}}{,,Map sequential architecture to speculative architecture events.\\%
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqarch-to-specarch-empty}{}{
    \seqarchev{\emptyevent}\seqarchTOspecarch{n}{n}\specarchev{\emptyevent}
  }{seqarch-to-specarch-empty}
  %
  \typerule{seqarch-to-specarch-crash}{}{
    \seqarchev{\lightning}\seqarchTOspecarch{n}{n}\specarchev{\lightning}
  }{seqarch-to-specarch-crash}
  %
  \typerule{seqarch-to-specarch-pc}{}{
    \seqarchev{Pc\;n}\seqarchTOspecarch{0}{0}\specarchev{Pc\;n}
  }{seqarch-to-specarch-pc}
  %
  \typerule{seqarch-to-specarch-store}{}{
    \seqarchev{Store\;\varLoc\;v}\seqarchTOspecarch{0}{0}\specarchev{Store\;\varLoc\;v}
  }{seqarch-to-specarch-store}
  %
  \typerule{seqarch-to-specarch-load}{}{
    \seqarchev{Load\;\varLoc\;v}\seqarchTOspecarch{0}{0}\specarchev{Load\;\varLoc\;v}
  }{seqarch-to-specarch-load}
  %
  \typerule{seqarch-to-specarch-spec}{
  }{
    \emptyevent\seqarchTOspecarch{n}{1+n}\specarchev{Spec}
  }{seqarch-to-specarch-spec}
  %
  \typerule{seqarch-to-specarch-rlb}{
  }{
    \emptyevent\seqarchTOspecarch{1+n}{n}\specarchev{Rlb}
  }{seqarch-to-specarch-rlb}
  %
  \typerule{seqarch-to-specarch-pc-ign}{}{
    \seqarchev{\emptyevent}\seqarchTOspecarch{1+n}{1+n}\specarchev{Pc\;m}
  }{seqarch-to-specarch-pc-ign}
  %
  \typerule{seqarch-to-specarch-store-ign}{}{
    \seqarchev{\emptyevent}\seqarchTOspecarch{1+n}{1+n}\specarchev{Store\;\varLoc\;v}
  }{seqarch-to-specarch-store-ign}
  %
  \typerule{seqarch-to-specarch-load-ign}{}{
    \seqarchev{\emptyevent}\seqarchTOspecarch{1+n}{1+n}\specarchev{Load\;\varLoc\;v}
  }{seqarch-to-specarch-load-ign}
\end{center}
\judgbox{\seqarchTOspecarchtr{n}{m} : \seqarchTrace\to\specarchTrace\to\mathbb{P}}{,,Map sequential architecture to speculative architecture events.\\
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqarch-to-specarch-refl}{}{
    \hole{\cdot}\seqarchTOspecarchtr{0}{0}\hole{\cdot}
  }{seqarch-to-specarch-refl}
  %
  \typerule{seqarch-to-specarch-trans}{
    \varEvent\seqarchTOspecarch{n}{m'}\varEvent' \rulesep
    \varTrace\seqarchTOspecarchtr{m'}{m}\varTrace
  }{
    \varEvent\cdot\varTrace\seqarchTOspecarchtr{n}{m}\varEvent'\cdot\varTrace'
  }{seqarch-to-specarch-trans}
\end{center}

\section{Machines}

\[
\begin{array}{rcl}
  \text{(Fencing)} &-&
    \begin{array}{rcl}
      \trg{\varEvent} & = & \trgFenceEv{\emptyevent} \mid
                            \trgFenceEv{Load\;\varLoc\;v} \mid %
                            \trgFenceEv{Store\;\varLoc\;v} \mid %
                            \trgFenceEv{Pc\;n} \mid %
                            \trgFenceEv{Spec} \mid %
                            \trgFenceEv{Rlb} \mid %
                            \trgFenceEv{Fence}
    \end{array} \\
\end{array}
\]

\section{Mappings from Observers to Machines}

\judgbox{\specarchev{\cdot}\sim_o\ev{\cdot}}{,,Map speculative architecture to Mem-Fencing using oracle $o$.''}
\begin{center}
  \typerule{specarch-to-fencing-load}{
    \llbracket o\rrbracket = \text{yes}
  }{
    \specarchev{Load\;\varLoc\;v}\sim_o\trg{Fence\cdot Load\;\varLoc\;v}
  }{specarch-to-fencing-load}
  %
  \typerule{specarch-to-fencing-store}{
    \llbracket o\rrbracket = \text{yes}
  }{
    \specarchev{Store\;\varLoc\;v}\sim_o\trg{Fence\cdot Store\;\varLoc\;v}
  }{specarch-to-fencing-store}
\end{center}

\judgbox{\specarchev{\cdot}\sim\ev{\cdot}}{,,Map speculative architecture to SLH.''}
\begin{center}
  \typerule{specarch-to-slh-load}{
    \specarchev{Rlb}\not\in\varTrace \rulesep
    \trg{Rlb}\not\in\trg{\varTrace} \rulesep
    \vdash{\varLoc}:\text{secret} \rulesep
    \trg{v}=v\vert_{\mathbb{B}}\trg{b}
  }{
    \specarchev{Spec}\cdot\specarchev{Pc\;n}\cdot\varTrace \cdot \specarchev{Load\;\varLoc\;v}\sim\trg{Spec\cdot Br\;b\cdot\varTrace\cdot Load\;\varLoc\;v}
  }{specarch-to-slh-load}
\end{center}

\section{Clustering}

\cite{vassena2021blade} uses combination of above

\printglossary

\clearpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}
\endinput
