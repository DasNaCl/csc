% Fixing: Too many math alphabets used in version normal.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\documentclass[12pt]{article}
\usepackage[left=1.0cm,top=1.5cm,right=1.0cm,bottom=1.5cm]{geometry}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage[numbers]{natbib}
\usepackage{trimclip}
\makeatletter
\DeclareRobustCommand{\circbullet}{\mathbin{\vphantom{\circ}\text{\circbullet@}}}
\newcommand{\circbullet@}{%
  \check@mathfonts
  \m@th\ooalign{%
    \clipbox{0 0 0 {\dimexpr\height-\fontdimen22\textfont2}}{$\bullet$}\cr
    $\circ$\cr
  }%
}
\DeclareRobustCommand{\bulletcirc}{\mathbin{\text{\bulletcirc@}}}
\newcommand{\bulletcirc@}{%
  \check@mathfonts
  \m@th\ooalign{%
    \raisebox{\fontdimen22\textfont2}{\clipbox{0 {\fontdimen22\textfont2} 0 0}{$\bullet$}}\cr
    $\circ$\cr
  }%
}
\makeatother

% https://tex.stackexchange.com/questions/648845/sans-serif-uppercase-greek-no-longer-showing-in-acmart
\DeclareMathAlphabet{\mathsf}{OT1}{LibertinusSans-LF}{m}{n}
\SetMathAlphabet{\mathsf}{bold}{OT1}{LibertinusSans-LF}{bx}{n}
\DeclareMathAlphabet{\mathtt}{OT1}{lmtt}{m}{n}
\SetMathAlphabet{\mathtt}{bold}{OT1}{lmtt}{bx}{n}

\input{cmds.tex}

\newcommand{\ccseqct}{\ensuremath\llbracket\cdot\rrbracket^{\text{seq}}_{\text{ct}}}
\newcommand{\ccseqmem}{\ensuremath\llbracket\cdot\rrbracket^{\text{seq}}_{\text{mem}}}
\newcommand{\ccspecmem}{\ensuremath\llbracket\cdot\rrbracket^{\text{spec}}_{\text{mem}}}
\newcommand{\ccspecct}{\ensuremath\llbracket\cdot\rrbracket^{\text{spec}}_{\text{ct}}}
\newcommand{\ccspecpathct}{\ensuremath\llbracket\cdot\rrbracket^{\text{spec}}_{\text{ct}}}
\newcommand{\ccseqarch}{\ensuremath\llbracket\cdot\rrbracket^{\text{seq}}_{\text{arch}}}
\newcommand{\ccspecarch}{\ensuremath\llbracket\cdot\rrbracket^{\text{spec}}_{\text{arch}}}
\newcommand{\ccseqspecctpc}{\ensuremath\llbracket\cdot\rrbracket^{\text{seq-spec}}_{\text{ct-pc}}}
\newcommand{\ccbot}{\ensuremath\llbracket\cdot\rrbracket_\top}

\newcommand{\partialsec}{\ensuremath\circbullet}
\newcommand{\fullsec}{\ensuremath\bullet}

\newcommand{\proven}{\ensuremath\checkmark}
\newcommand{\partiallyproven}{\ensuremath(\checkmark)}
\newcommand{\informal}{\ensuremath\times}

\newcommand{\specpht}{\ensuremath\text{PHT}}
\newcommand{\specssb}{\ensuremath\text{SSB}} %is this relevant?
\newcommand{\specrsb}{\ensuremath\text{RSB}}
\newcommand{\specbtb}{\ensuremath\text{BTB}}
\newcommand{\specstl}{\ensuremath\text{STL}}
\newcommand{\specpsf}{\ensuremath\text{PSF}}

\loadglsentries{acronyms}
\makeglossaries

\begin{document}

\begin{center}
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    Ref. &
    Cont. &
    Variants &
    Mitigations &
    Proof &
    Security &
    Platform
    \\\hline
    %
    \cite{vassena2021blade} &
    \acrshort{ccspecct} &
    $\specpht,\specrsb$ &
    \acrshort{fi}, \acrshort{slh} &
    $\partiallyproven$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    \cite{elatali2024cmr} &
    \acrshort{ccspecct} &
    $\specpht,\specrsb$ &
    \acrshort{cmr} &
    $\informal$ &
    $\partialsec$ &
    \acrshort{hs}
    \\
    %
    \cite{yu2019stt} &
    \acrshort{ccspecarch} &
    $\specpht$ &
    \acrshort{dtt} &
    $\partiallyproven$ &
    $\partialsec$ &
    \acrshort{h}
    \\
    %
    \cite{lfence} &
    ? &
    $\specpht$ &
    \acrshort{fi} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    \cite{lfence} &
    ? &
    $\specssb$ &
    \acrshort{msr} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}/\acrshort{h}
    \\
    %
    \cite{mosier2023serberus} &
    \acrshort{ccspecct} &
    $\specpht$, $\specbtb$, $\specrsb$, $\specstl$, $\specpsf$ &
    \acrshort{fi},\acrshort{iso},\acrshort{rz} &
    $\partiallyproven$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    \cite{narayan2021swivel} &
    \acrshort{ccspecmem} &
    $\specpht$, $\specbtb$, $\specrsb$, $\specstl$, $\specpsf$ &
    \acrshort{iso},\acrshort{sm},\acrshort{ri} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}/\acrshort{h}
    \\
    %
    \cite{barber2019specshield} &
    \acrshort{ccspecmem} &
    $\specpht$, $\specbtb$, $\specssb$, $\specstl$ &
    - &
    $\informal$ &
    $\partialsec$ &
    \acrshort{hs}
    \\
    %
    \cite{weisse2019nda} &
    ? &
    $\specpht$, $\specbtb$, $\specrsb$, $\specssb$, $\specstl$ &
    - &
    $\informal$ &
    $\fullsec$ &
    \acrshort{hs}
    \\
    %
    \cite{schwarz2019context} &
    ? &
    $\specpht$, $\specbtb$, $\specrsb$, $\specssb$, $\specstl$ &
    \acrshort{ntmmap} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}/\acrshort{h}
    \\
    %
    \cite{khasawneh2018safespec} &
    \acrshort{ccspecct} &
    $\specpht$, $\specbtb$ &
    \acrshort{sm} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{h}
    \\
    %
    % authors claim compositionality with fencing and sandboxing
    % however, it's not robust: they assume all code to follow a certain scheme
    \cite{shen2019venkman} &
    \acrshort{ccspecct} &
    $\specbtb$, $\specrsb$ &
    \acrshort{fi},\acrshort{iso} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    % claim it combines well with safespec and invisspec (both are hardware)
    \cite{koruyeh2019speccfi} &
    \acrshort{ccspecct} &
    $\specbtb$, $\specrsb$ &
    \acrshort{cfi} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{s}/\acrshort{h}
    \\
    %
    \cite{yan2018invisispec} &
    \acrshort{ccspecct} &
    $\specpht$, $\specbtb$, $\specrsb$, $\specssb$, $\specstl$  &
    \acrshort{iso} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{h}
    \\
    %
    \cite{eleksenko2018bypass} &
    ? &
    $\specpht$ &
    \acrshort{add} &
    $\informal$ &
    ? &
    \acrshort{s}
    \\
    %
    \cite{slh} &
    ? &
    $\specpht$ &
    \acrshort{slh} &
    $\informal$ &
    $\partialsec$ & % may leak data accessed non-speculativey
                    % misses variable time instructions
    \acrshort{s}
    \\
    %
    \cite{patrignani2021exorcising} &
    \acrshort{ccspecct} &
    $\specpht$ &
    \acrshort{sslh} &
    $\proven$ &
    $\partialsec$ & % misses variable time instructions
    \acrshort{s}
    \\
    %
    \cite{zhang2023uslh} &
    \acrshort{ccspecct} &
    $\specpht$ &
    \acrshort{uslh} &
    $\proven$ &
    $\fullsec$ &
    \acrshort{s}
    \\
    %
    \cite{taram2019csf} &
    \acrshort{ccspecct} &
    $\specpht$, $\specrsb$, $\specbtb$ &
    \acrshort{fi} &
    $\informal$ &
    $\fullsec$ &
    \acrshort{h}
    \\
    %
    \hline
  \end{tabular}
\end{center}

\footnotetext{
The above table uses execution modes \gls{seq}, \gls{seq-ooo}, \gls{spec}, and \gls{spec-ooo}.
Moreover, it relies on observers \gls{ctobs}, \gls{pathctobs}, \gls{memobs}, and \gls{archobs}.
}

\clearpage

\section{Preliminaries}

\begin{lemma}{\lemmalabel[Left-total and injective $\sim$ induces a Galois Insertion.]{general-induce-galois-insertion}}
  If
  \begin{assumptions}
    \asm{general-induce-galois-insertion-left-total}{\sim\text{ left total}}
    \asm{general-induce-galois-insertion-left-unique}{\sim\text{ left unique}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{general-induce-galois-insertion}{\forall\varProperty,\mapUniversal{\sim}{\mapExistential{\sim}{\varProperty}}=\varProperty}
  \end{goals}
\end{lemma}
\begin{proof}
  % mapUniversal is abstraction
  \newcommand{\lpref}{general-induce-galois-insertion}
  \newcommand{\abstraction}[1]{\mapUniversal{\sim}{#1}}
  \newcommand{\concretization}[1]{\mapExistential{\sim}{#1}}

  Let $\varProperty$ be a set of source-level objects.
  Let $\src{\varEvent[S]}$ be a source-level object. 
  The proof goes by antisymmetry of set-inclusion:
  \begin{proofcase}{\subseteq}
    We know: 
    \begin{passumptions}
      \asm{\lpref-in-acprop}{\src{\varEvent[S]}\in\abstraction{\concretization{\varProperty}}}
    \end{passumptions}
    We need to show:
    \begin{goals}
      \goal{\lpref-in-prop}{\src{\varEvent[S]}\in\varProperty}
    \end{goals}

    From \asmref{\lpref-left-total} we know that there is a $\trg{\varEvent[T]}$ such that:
    \begin{passumptions}
      \asm{\lpref-le-initrel}{\src{\varEvent[S]}\sim\trg{\varEvent[T]}}
    \end{passumptions}
    Specialize \asmref{\lpref-in-acprop} with \asmref{\lpref-le-initrel}, obtaining:
    \begin{passumptions}
      \asm{\lpref-elc}{\trg{\varEvent[T]}\in\concretization{\varProperty}}
    \end{passumptions}
    From \asmref{\lpref-elc}, we know that there is a $\src{\varEvent[S]'}$ such that:
    \begin{passumptions}
      \asm{\lpref-le-rel}{\src{\varEvent[S]'}\sim\trg{\varEvent[T]}}
      \asm{\lpref-in-prop-prime}{\src{\varEvent[S]'}\in\varProperty}
    \end{passumptions}

    Now, \goalref{\lpref-in-prop} follows from \asmref{\lpref-in-prop-prime} by rewriting with \asmref{\lpref-left-unique} whose assumptions are satisfied via \asmref{\lpref-le-initrel} and \asmref{\lpref-le-rel}.
  \end{proofcase}
  \begin{proofcase}{\supseteq}
    We know: 
    \begin{passumptions}
      \asm{\lpref-in-prop}{\src{\varEvent[S]}\in\varProperty}
    \end{passumptions}
    We need to show:
    \begin{goals}
      \goal{\lpref-in-acprop}{\src{\varEvent[S]}\in\abstraction{\concretization{\varProperty}}}
    \end{goals}
    Unfold \goalref{\lpref-in-acprop}, so let $\trg{\varEvent[T]}$ such that:
    \begin{passumptions}
      \asm{\lpref-ge-initrel}{\src{\varEvent[S]}\sim\trg{\varEvent[T]}}
    \end{passumptions}
    What is left to prove is:
    \begin{goals}
      \goal{\lpref-in-propc}{\trg{\varEvent[T]}\in\concretization{\varProperty}}
    \end{goals}
    Simply instantiate the existential in \goalref{\lpref-in-propc} with $\seqarchEvent$, \asmref{\lpref-ge-initrel} and \asmref{\lpref-in-prop} resolve the remaining obligations.
  \end{proofcase}
\end{proof}

\section{Observers}

\[
  \begin{array}{rcl}
  \ccseqct &-&
    \begin{array}{rcl}
      \seqctEvent & = & \seqctev{\emptyevent} \mid %
                        \seqctev{\lightning} \mid %
                        \seqctev{Load\;\varLoc} \mid %
                        \seqctev{Store\;\varLoc} \mid %
                        \seqctev{Pc\;n}
    \end{array} \\
  \ccspecct &-&
    \begin{array}{rcl}
      \specctEvent & = & \specctev{\emptyevent} \mid %
                         \specctev{\lightning} \mid %
                         \specctev{Load\;\varLoc} \mid %
                         \specctev{Store\;\varLoc} \mid %
                         \specctev{Pc\;n} \mid %
                         \specctev{Spec} \mid %
                         \specctev{Rlb} 
    \end{array} \\
  \ccseqmem &-&
    \begin{array}{rcl}
      \seqmemEvent & = & \seqmemev{\emptyevent} \mid %
                         \seqmemev{\lightning} \mid %
                         \seqmemev{Load\;\varLoc} \mid %
                         \seqmemev{Store\;\varLoc}
    \end{array} \\
  \ccspecmem &-&
    \begin{array}{rcl}
      \specmemEvent & = & \specmemev{\emptyevent} \mid %
                          \specmemev{\lightning} \mid %
                          \specmemev{Load\;\varLoc} \mid %
                          \specmemev{Store\;\varLoc} \mid %
                          \specmemev{Spec} \mid %
                          \specmemev{Rlb} 
    \end{array} \\
  \ccseqarch &-&
    \begin{array}{rcl}
      \seqarchEvent & = & \seqarchev{\emptyevent} \mid %
                          \seqarchev{\lightning} \mid %
                          \seqarchev{Load\;\varLoc\;v} \mid %
                          \seqarchev{Store\;\varLoc\;v} \mid %
                          \seqarchev{Pc\;n}
    \end{array} \\
  \ccspecarch &-&
    \begin{array}{rcl}
      \specarchEvent & = & \specarchev{\emptyevent} \mid %
                           \specarchev{\lightning} \mid %
                           \specarchev{Load\;\varLoc\;v} \mid %
                           \specarchev{Store\;\varLoc\;v} \mid %
                           \specarchev{Pc\;n} \mid %
                           \specarchev{Spec} \mid %
                           \specarchev{Rlb} 
    \end{array} \\
  \end{array}
\]

\section{Mappings between Observers}

\subsection{Sequential to Speculative}

All relations presented in this section share the same key idea, so it is mostly repetitive. 
The key insight is to index the relations by natural numbers in order to keep track of the depth of nested speculation and ignore if the depth is non-zero, i.e., if there is speculation.
The trace-level versions have to do minor bookkeeping to count speculation depth, but the counting is done at event-level.

\paragraph{Constant-Time} $\;$\\

\judgbox{\seqctTOspecct{n}{m} : \seqctEvent\to\specctEvent\to\mathbb{P}}{,,Map sequential constant time to speculative constant time events.\\%
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqct-to-specct-empty}{}{
    \seqctev{\emptyevent}\seqctTOspecct{n}{n}\specctev{\emptyevent}
  }{seqct-to-specct-empty}
  %
  \typerule{seqct-to-specct-crash}{}{
    \seqctev{\lightning}\seqctTOspecct{n}{n}\specctev{\lightning}
  }{seqct-to-specct-crash}
  %
  \typerule{seqct-to-specct-pc}{}{
    \seqctev{Pc\;n}\seqctTOspecct{0}{0}\specctev{Pc\;n}
  }{seqct-to-specct-pc}
  %
  \typerule{seqct-to-specct-store}{}{
    \seqctev{Store\;\varLoc}\seqctTOspecct{0}{0}\specctev{Store\;\varLoc}
  }{seqct-to-specct-store}
  %
  \typerule{seqct-to-specct-load}{}{
    \seqctev{Load\;\varLoc}\seqctTOspecct{0}{0}\specctev{Load\;\varLoc}
  }{seqct-to-specct-load}
  %
  \typerule{seqct-to-specct-spec}{
  }{
    \emptyevent\seqctTOspecct{n}{1+n}\specctev{Spec}
  }{seqct-to-specct-spec}
  %
  \typerule{seqct-to-specct-rlb}{
  }{
    \emptyevent\seqctTOspecct{1+n}{n}\specctev{Rlb}
  }{seqct-to-specct-rlb}
  %
  \typerule{seqct-to-specct-pc-ign}{}{
    \seqctev{\emptyevent}\seqctTOspecct{1+n}{1+n}\specctev{Pc\;m}
  }{seqct-to-specct-pc-ign}
  %
  \typerule{seqct-to-specct-store-ign}{}{
    \seqctev{\emptyevent}\seqctTOspecct{1+n}{1+n}\specctev{Store\;\varLoc}
  }{seqct-to-specct-store-ign}
  %
  \typerule{seqct-to-specct-load-ign}{}{
    \seqctev{\emptyevent}\seqctTOspecct{1+n}{1+n}\specctev{Load\;\varLoc}
  }{seqct-to-specct-load-ign}
\end{center}
\judgbox{\seqctTOspeccttr{n}{m} : \seqctTrace\to\specctTrace\to\mathbb{P}}{,,Map sequential constant time to speculative constant time events.\\
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqct-to-specct-refl}{}{
    \hole{\cdot}\seqctTOspeccttr{0}{0}\hole{\cdot}
  }{seqct-to-specct-refl}
  %
  \typerule{seqct-to-specct-trans}{
    \varEvent\seqctTOspecct{n}{m'}\varEvent' 
    \rulesep
    \varTrace\seqctTOspeccttr{m'}{m}\varTrace
  }{
    \varEvent\cdot\varTrace\seqctTOspeccttr{n}{m}\varEvent'\cdot\varTrace'
  }{seqct-to-specct-trans}
\end{center}

\begin{lemma}{\lemmalabel[$\seqctTOspecct{n}{m}$ is left-unique.]{seqct-to-specct-left-unique}}
  $\seqctTOspecct{n}{m}$ is left-unique.
\end{lemma}
\begin{proof}
  \newcommand{\lpref}{seqct-to-specct-left-unique}
  Let $\seqctEvent$ and $\seqctEvent[']$ with $\specctEvent$ such that:
  \begin{passumptions}
    \asm{\lpref-rel1}{\seqctEvent\seqctTOspecct{n}{m}\specctEvent}
    \asm{\lpref-rel2}{\seqctEvent[']\seqctTOspecct{n}{m}\specctEvent}
  \end{passumptions}
  The goal is:
  \begin{goals}
    \goal{\lpref-eq}{\seqctEvent=\seqctEvent[']}
  \end{goals}

  Invert both \asmref{\lpref-rel1} and \asmref{\lpref-rel2}, then \goalref{\lpref-eq} follows by reflexivity.
\end{proof}
\begin{lemma}{\lemmalabel[$\seqctTOspecct{n}{m}$ is left-total.]{seqct-to-specct-left-total}}
  $\seqctTOspecct{n}{m}$ is left-total.
\end{lemma}
\begin{proof}
  Simple case analysis on the arguments.
\end{proof}
\begin{corollary}{\corollarylabel[$\seqctTOspecct{n}{m}$ induces a Galois Insertion.]{seqct-to-specct-induce-galois-insertion}}
  It holds that:
  \begin{goals}
    \goal{seqct-to-specct-induce-galois-insertion}{\forall\varProperty,\mapUniversal{\sim}{\mapExistential{\sim}{\varProperty}}=\varProperty}
  \end{goals}
\end{corollary}
\begin{proof}
  Immediate from \lemmaref{general-induce-galois-insertion} via \lemmaref{seqct-to-specct-left-total} and \lemmaref{seqct-to-specct-left-unique}.
\end{proof}

\paragraph{Memory} $\;$\\

\judgbox{\seqmemTOspecmem{n}{m} : \seqmemEvent\to\specmemEvent\to\mathbb{P}}{,,Map sequential memory to speculative memory events.\\%
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqmem-to-specmem-empty}{}{
    \seqmemev{\emptyevent}\seqmemTOspecmem{n}{n}\specmemev{\emptyevent}
  }{seqmem-to-specmem-empty}
  %
  \typerule{seqmem-to-specmem-crash}{}{
    \seqmemev{\lightning}\seqmemTOspecmem{n}{n}\specmemev{\lightning}
  }{seqmem-to-specmem-crash}
  %
  \typerule{seqmem-to-specmem-store}{}{
    \seqmemev{Store\;\varLoc}\seqmemTOspecmem{0}{0}\specmemev{Store\;\varLoc}
  }{seqmem-to-specmem-store}
  %
  \typerule{seqmem-to-specmem-load}{}{
    \seqmemev{Load\;\varLoc}\seqmemTOspecmem{0}{0}\specmemev{Load\;\varLoc}
  }{seqmem-to-specmem-load}
  %
  \typerule{seqmem-to-specmem-spec}{
  }{
    \emptyevent\seqmemTOspecmem{n}{1+n}\specmemev{Spec}
  }{seqmem-to-specmem-spec}
  %
  \typerule{seqmem-to-specmem-rlb}{
  }{
    \emptyevent\seqmemTOspecmem{1+n}{n}\specmemev{Rlb}
  }{seqmem-to-specmem-rlb}
  %
  \typerule{seqmem-to-specmem-store-ign}{}{
    \seqmemev{\emptyevent}\seqmemTOspecmem{1+n}{1+n}\specmemev{Store\;\varLoc}
  }{seqmem-to-specmem-store-ign}
  %
  \typerule{seqmem-to-specmem-load-ign}{}{
    \seqmemev{\emptyevent}\seqmemTOspecmem{1+n}{1+n}\specmemev{Load\;\varLoc}
  }{seqmem-to-specmem-load-ign}
\end{center}
\judgbox{\seqmemTOspecmemtr{n}{m} : \seqmemTrace\to\specmemTrace\to\mathbb{P}}{,,Map sequential memory to speculative memory events.\\
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqmem-to-specmem-refl}{}{
    \hole{\cdot}\seqmemTOspecmemtr{0}{0}\hole{\cdot}
  }{seqmem-to-specmem-refl}
  %
  \typerule{seqmem-to-specmem-trans}{
    \varEvent\seqmemTOspecmem{n}{m'}\varEvent' 
    \rulesep
    \varTrace\seqmemTOspecmemtr{m'}{m}\varTrace
  }{
    \varEvent\cdot\varTrace\seqmemTOspecmemtr{n}{m}\varEvent'\cdot\varTrace'
  }{seqmem-to-specmem-trans}
\end{center}

\begin{lemma}{\lemmalabel[$\seqmemTOspecmem{n}{m}$ is left-unique.]{seqmem-to-specmem-left-unique}}
  $\seqmemTOspecmem{n}{m}$ is left-unique.
\end{lemma}
\begin{proof}
  \newcommand{\lpref}{seqmem-to-specmem-left-unique}
  Let $\seqmemEvent$ and $\seqmemEvent[']$ with $\specmemEvent$ such that:
  \begin{passumptions}
    \asm{\lpref-rel1}{\seqmemEvent\seqmemTOspecmem{n}{m}\specmemEvent}
    \asm{\lpref-rel2}{\seqmemEvent[']\seqmemTOspecmem{n}{m}\specmemEvent}
  \end{passumptions}
  The goal is:
  \begin{goals}
    \goal{\lpref-eq}{\seqmemEvent=\seqmemEvent[']}
  \end{goals}

  Invert both \asmref{\lpref-rel1} and \asmref{\lpref-rel2}, then \goalref{\lpref-eq} follows by reflexivity.
\end{proof}
\begin{lemma}{\lemmalabel[$\seqmemTOspecmem{n}{m}$ is left-total.]{seqmem-to-specmem-left-total}}
  $\seqmemTOspecmem{n}{m}$ is left-total.
\end{lemma}
\begin{proof}
  Simple case analysis on the arguments.
\end{proof}
\begin{corollary}{\corollarylabel[$\seqmemTOspecmem{n}{m}$ induces a Galois Insertion.]{seqmem-to-specmem-induce-galois-insertion}}
  It holds that:
  \begin{goals}
    \goal{seqmem-to-specmem-induce-galois-insertion}{\forall\varProperty,\mapUniversal{\sim}{\mapExistential{\sim}{\varProperty}}=\varProperty}
  \end{goals}
\end{corollary}
\begin{proof}
  Immediate from \lemmaref{general-induce-galois-insertion} via \lemmaref{seqmem-to-specmem-left-total} and \lemmaref{seqmem-to-specmem-left-unique}.
\end{proof}

\paragraph{Architecture} $\;$\\


\judgbox{\seqarchTOspecarch{n}{m} : \seqarchEvent\to\specarchEvent\to\mathbb{P}}{,,Map sequential architecture to speculative architecture events.\\%
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqarch-to-specarch-empty}{}{
    \seqarchev{\emptyevent}\seqarchTOspecarch{n}{n}\specarchev{\emptyevent}
  }{seqarch-to-specarch-empty}
  %
  \typerule{seqarch-to-specarch-crash}{}{
    \seqarchev{\lightning}\seqarchTOspecarch{n}{n}\specarchev{\lightning}
  }{seqarch-to-specarch-crash}
  %
  \typerule{seqarch-to-specarch-pc}{}{
    \seqarchev{Pc\;n}\seqarchTOspecarch{0}{0}\specarchev{Pc\;n}
  }{seqarch-to-specarch-pc}
  %
  \typerule{seqarch-to-specarch-store}{}{
    \seqarchev{Store\;\varLoc\;v}\seqarchTOspecarch{0}{0}\specarchev{Store\;\varLoc\;v}
  }{seqarch-to-specarch-store}
  %
  \typerule{seqarch-to-specarch-load}{}{
    \seqarchev{Load\;\varLoc\;v}\seqarchTOspecarch{0}{0}\specarchev{Load\;\varLoc\;v}
  }{seqarch-to-specarch-load}
  %
  \typerule{seqarch-to-specarch-spec}{
  }{
    \emptyevent\seqarchTOspecarch{n}{1+n}\specarchev{Spec}
  }{seqarch-to-specarch-spec}
  %
  \typerule{seqarch-to-specarch-rlb}{
  }{
    \emptyevent\seqarchTOspecarch{1+n}{n}\specarchev{Rlb}
  }{seqarch-to-specarch-rlb}
  %
  \typerule{seqarch-to-specarch-pc-ign}{}{
    \seqarchev{\emptyevent}\seqarchTOspecarch{1+n}{1+n}\specarchev{Pc\;m}
  }{seqarch-to-specarch-pc-ign}
  %
  \typerule{seqarch-to-specarch-store-ign}{}{
    \seqarchev{\emptyevent}\seqarchTOspecarch{1+n}{1+n}\specarchev{Store\;\varLoc\;v}
  }{seqarch-to-specarch-store-ign}
  %
  \typerule{seqarch-to-specarch-load-ign}{}{
    \seqarchev{\emptyevent}\seqarchTOspecarch{1+n}{1+n}\specarchev{Load\;\varLoc\;v}
  }{seqarch-to-specarch-load-ign}
\end{center}
\judgbox{\seqarchTOspecarchtr{n}{m} : \seqarchTrace\to\specarchTrace\to\mathbb{P}}{,,Map sequential architecture to speculative architecture events.\\
  $n$ represents the current size of speculation depth and $m$ the new size.%
''}
\begin{center}
  \typerule{seqarch-to-specarch-refl}{}{
    \hole{\cdot}\seqarchTOspecarchtr{0}{0}\hole{\cdot}
  }{seqarch-to-specarch-refl}
  %
  \typerule{seqarch-to-specarch-trans}{
    \varEvent\seqarchTOspecarch{n}{m'}\varEvent' 
    \rulesep
    \varTrace\seqarchTOspecarchtr{m'}{m}\varTrace
  }{
    \varEvent\cdot\varTrace\seqarchTOspecarchtr{n}{m}\varEvent'\cdot\varTrace'
  }{seqarch-to-specarch-trans}
\end{center}

\begin{lemma}{\lemmalabel[$\seqarchTOspecarch{n}{m}$ is left-unique.]{seqarch-to-specarch-left-unique}}
  $\seqarchTOspecarch{n}{m}$ is left-unique.
\end{lemma}
\begin{proof}
  \newcommand{\lpref}{seqarch-to-specarch-left-unique}
  Let $\seqarchEvent$ and $\seqarchEvent[']$ with $\specarchEvent$ such that:
  \begin{passumptions}
    \asm{\lpref-rel1}{\seqarchEvent\seqarchTOspecarch{n}{m}\specarchEvent}
    \asm{\lpref-rel2}{\seqarchEvent[']\seqarchTOspecarch{n}{m}\specarchEvent}
  \end{passumptions}
  The goal is:
  \begin{goals}
    \goal{\lpref-eq}{\seqarchEvent=\seqarchEvent[']}
  \end{goals}

  Invert both \asmref{\lpref-rel1} and \asmref{\lpref-rel2}, then \goalref{\lpref-eq} follows by reflexivity.
\end{proof}
\begin{lemma}{\lemmalabel[$\seqarchTOspecarch{n}{m}$ is left-total.]{seqarch-to-specarch-left-total}}
  $\seqarchTOspecarch{n}{m}$ is left-total.
\end{lemma}
\begin{proof}
  Simple case analysis on the arguments.
\end{proof}
\begin{corollary}{\corollarylabel[$\seqarchTOspecarch{n}{m}$ induces a Galois Insertion.]{seqarch-to-specarch-induce-galois-insertion}}
  It holds that:
  \begin{goals}
    \goal{seqarch-to-specarch-induce-galois-insertion}{\forall\varProperty,\mapUniversal{\sim}{\mapExistential{\sim}{\varProperty}}=\varProperty}
  \end{goals}
\end{corollary}
\begin{proof}
  Immediate from \lemmaref{general-induce-galois-insertion} via \lemmaref{seqarch-to-specarch-left-total} and \lemmaref{seqarch-to-specarch-left-unique}.
\end{proof}

\begin{lemma}{\lemmalabel[$\seqarchTOspecarchtr{n}{m}$ is left-unique.]{seqarch-to-specarchtr-left-unique}}
  $\seqarchTOspecarchtr{n}{m}$ is left-unique.
\end{lemma}
\begin{proof}
  \newcommand{\lpref}{seqarch-to-specarchtr-left-unique}
  Let $\seqarchTrace$ and $\seqarchTrace[']$ with $\specarchTrace$ such that:
  \begin{passumptions}
    \asm{\lpref-rel1}{\seqarchTrace\seqarchTOspecarchtr{n}{m}\specarchTrace}
    \asm{\lpref-rel2}{\seqarchTrace[']\seqarchTOspecarchtr{n}{m}\specarchTrace}
  \end{passumptions}
  The goal is:
  \begin{goals}
    \goal{\lpref-eq}{\seqarchTrace=\seqarchTrace[']}
  \end{goals}

  Induce on \asmref{\lpref-rel1} then invert \asmref{\lpref-rel2}. 
  The base-case follows by reflexivity and the induction case follows by inductive hypothesis and \lemmaref{seqarch-to-specarch-left-unique}.
\end{proof}
\begin{lemma}{\lemmalabel[$\seqarchTOspecarchtr{n}{m}$ is left-total.]{seqarch-to-specarchtr-left-total}}
  $\seqarchTOspecarchtr{n}{m}$ is left-total.
\end{lemma}
\begin{proof}
  Let $\seqarchTrace$ be a trace.
  We want to show that there are $n,m,\specarchTrace$ such that $\seqarchTrace\seqarchTOspecarchtr{n}{m}\specarchTrace$.
  Simply induce on $\seqarchTrace$ and use \lemmaref{seqarch-to-specarch-left-total}.
\end{proof}

\begin{corollary}{\corollarylabel[$\seqarchTOspecarchtr{n}{m}$ induces a Galois Insertion.]{seqarch-to-specarchtr-induce-galois-insertion}}
  It holds that:
  \begin{goals}
    \goal{seqarch-to-specarchtr-induce-galois-insertion}{\forall\varProperty,\mapUniversal{\seqarchTOspecarchtr{n}{m}}{\mapExistential{\seqarchTOspecarchtr{n}{m}}{\varProperty}}=\varProperty}
  \end{goals}
\end{corollary}
\begin{proof}
  Immediate from \lemmaref{general-induce-galois-insertion} via \lemmaref{seqarch-to-specarchtr-left-total} and \lemmaref{seqarch-to-specarchtr-left-unique}.
\end{proof}

\subsection{Across Observer Types}

\paragraph{Memory to Constant-Time} $\;$

\begin{center}
  \typerule{specmem-to-specct-empty}{}{
    \specmemev{\emptyevent}\specmemTOspecct\specctev{\emptyevent}
  }{specmem-to-specct-empty}
\end{center}

\subsection{Observer Hierarchy}

\begin{center}
  \begin{tikzpicture}[node distance=.75cm]
    \node[draw] (SpecArch) {$\specarchEvent$};
    \node[draw] (SeqArch)[below right=of SpecArch] {$\seqarchEvent$};

    \node[draw] (SpecCt)[below left=1cm of SpecArch] {$\specctEvent$};
    \node[draw] (SeqCt)[below right=of SpecCt] {$\seqctEvent$};

    \node[draw] (SpecMem)[below left=1cm of SpecCt] {$\specmemEvent$};
    \node[draw] (SeqMem)[below right=of SpecMem] {$\seqmemEvent$};

    \draw[very thick,->] (SpecArch) -- (SeqArch);
    \draw[very thick,->] (SpecCt) -- (SeqCt);
    \draw[very thick,->] (SpecMem) -- (SeqMem);

    \draw[very thick,->] (SpecArch) -- (SpecCt);
    \draw[very thick,->] (SpecCt) -- (SpecMem);
    
    \draw[very thick,dotted,->] (SeqArch) -- (SeqCt);
    \draw[very thick,dotted,->] (SeqCt) -- (SeqMem);
  \end{tikzpicture}
\end{center}

\section{Machines}

\[
\begin{array}{rcl}
  \text{(Fencing)} &-&
    \begin{array}{rcl}
      \trg{\varEvent} & = & \trgFenceEv{\emptyevent} \mid
                            \trgFenceEv{Load\;\varLoc\;v} \mid %
                            \trgFenceEv{Store\;\varLoc\;v} \mid %
                            \trgFenceEv{Pc\;n} \mid %
                            \trgFenceEv{Spec} \mid %
                            \trgFenceEv{Rlb} \mid %
                            \trgFenceEv{Fence}
    \end{array} \\
\end{array}
\]

\section{Mappings from Observers to Machines}

\judgbox{\specarchev{\cdot}\sim_o\ev{\cdot}}{,,Map speculative architecture to Mem-Fencing using oracle $o$.''}
\begin{center}
  \typerule{specarch-to-fencing-load}{
    \llbracket o\rrbracket = \text{yes}
  }{
    \specarchev{Load\;\varLoc\;v}\sim_o\trg{Fence\cdot Load\;\varLoc\;v}
  }{specarch-to-fencing-load}
  %
  \typerule{specarch-to-fencing-store}{
    \llbracket o\rrbracket = \text{yes}
  }{
    \specarchev{Store\;\varLoc\;v}\sim_o\trg{Fence\cdot Store\;\varLoc\;v}
  }{specarch-to-fencing-store}
\end{center}

\judgbox{\specarchev{\cdot}\sim\ev{\cdot}}{,,Map speculative architecture to SLH.''}
\begin{center}
  \typerule{specarch-to-slh-load}{
    \specarchev{Rlb}\not\in\varTrace 
    \rulesep
    \trg{Rlb}\not\in\trg{\varTrace} 
    \rulesep
    \vdash{\varLoc}:\text{secret} 
    \rulesep
    \trg{v}=v\operatorname{bitor}\trg{b}
  }{
    \specarchev{Spec}\cdot\specarchev{Pc\;n}\cdot\varTrace \cdot \specarchev{Load\;\varLoc\;v}\sim\trg{Spec\cdot Br\;b\cdot\varTrace\cdot Load\;\varLoc\;v}
  }{specarch-to-slh-load}
\end{center}

\section{Clustering}

\printglossary

\clearpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}
\endinput
