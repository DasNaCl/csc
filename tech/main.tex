% Fixing: Too many math alphabets used in version normal.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\documentclass[a4paper,12pt]{article}
\usepackage[left=1.0cm,top=1.5cm,right=1.0cm,bottom=1.5cm]{geometry}
\usepackage{parskip}

% https://tex.stackexchange.com/questions/648845/sans-serif-uppercase-greek-no-longer-showing-in-acmart
\DeclareMathAlphabet{\mathsf}{OT1}{LibertinusSans-LF}{m}{n}
\SetMathAlphabet{\mathsf}{bold}{OT1}{LibertinusSans-LF}{bx}{n}
\DeclareMathAlphabet{\mathtt}{OT1}{lmtt}{m}{n}
\SetMathAlphabet{\mathtt}{bold}{OT1}{lmtt}{bx}{n}

\input{cmds.tex}

\loadglsentries{acronyms}
\makeglossaries

\title{Secure Composition of Robust and Optimising Compilers}
\begin{document}

\maketitle

\begin{abstract}
% context
To ensure that secure applications do not leak their secrets, they are required to uphold several security properties such as spatial and temporal memory safety, cryptographic constant time, as well as speculative safety.
% need
Existing work shows how to enforce these properties individually, in an architecture-independent way, by using secure compiler passes that each focus on an individual property.
% task
Unfortunately, given two secure compiler passes that each preserve a possibly different security property, it is unclear what kind of security property is preserved by the composition of those secure compiler passes.
%there is no way to tell what kind of security property will the composition of those secure compilers preserve.

% object
This paper is the first to study what security properties are preserved across the composition of different secure compiler passes.
% findings
Starting from a general theory of property composition for security-relevant properties (such as the aforementioned ones), this paper formalises a theory of composition of secure compilers.
Then, it showcases this theory on a secure multi-pass compiler that preserves the aforementioned security-relevant properties.
% conclusion
Crucially, this paper derives the security of the multi-pass compiler from the composition of the security properties preserved by its individual passes, which include security-preserving as well as optimisation passes.
% 
From an engineering perspective, this is the desirable approach to building secure compilers.
\begin{center}\small\it
	{This paper uses syntax highlighting accessible to both colourblind and black \& white readers.}
\end{center}
\end{abstract}

\appendix

\section{Background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preliminaries}

\begin{definition}{\definitionlabel[Function Composition]{function-composition}}
  $\fncompo{f}{g}\isdef \lambda x.g(f\;x)$
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Satisfaction}
\bul{A whole program $\varWholeProg$ satisfies a property $\varProperty$} iff \iul{$\varWholeProg$ yields a trace $\varTrace$} such that \oul{$\varTrace$ satisfies $\varProperty$}.

\begin{definition}{\definitionlabel[Property Satisfaction]{prop-sat}}
    \bul{$\sat{\varWholeProg}{\varProperty}$}
    $\isdef$
    if \iul{$\forall\varRuntimeTerm\ \varTrace, %
      \progstepto{\varWholeProg}{\varRuntimeTerm}{\varTrace}$
    },
    then \oul{$\varTrace\in\varProperty$}.
\end{definition}

With this, \definitionref{prop-sat} can be extended as follows: for \bul{a component $\varComponent$ to robustly satisfy a property $\varProperty$}, take an \iul{attacker context $\varContext$ and link it with $\varComponent$}, \oul{the resulting whole program must satisfy $\varProperty$}.

\begin{definition}{\definitionlabel[Robust Property Satisfaction]{prop-rsat}}
  \bul{$\rsat{\varComponent}{\varProperty}$} %
  $\isdef$ %
  \iul{$\forall \varContext\ \varWholeProg$, %
    if $\bopLink{\varContext}{\varComponent} = \varWholeProg$}, %
    then \oul{$\sat{\varWholeProg}{\varProperty}$%
  }.
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Property Mappings}

This work relies on property mappings introduced in related work~\cite{abate2021extacc}.

\begin{definition}{\definitionlabel[Universal Image]{universal-image}}
  $ 
    \mapUniversal{\sim}{\trgProperty} := 
      \lrbraces{\srcTrace \mid %
        \forall \trgTrace\ldotp \text{if }\xrelTraces{\srcTrace}{\trgTrace}, \text{ then }%
        \trgTrace\in\trgProperty
      }
  $
\end{definition}
\begin{definition}{\definitionlabel[Existential Image]{existential-image}}
  $ 
    \mapExistential{\sim}{\srcProperty} := 
      \lrbraces{\trgTrace \mid %
        \exists \srcTrace\ldotp \xrelTraces{\srcTrace}{\trgTrace} \text{ and }%
        \srcTrace\in\srcProperty
      }
  $
\end{definition}

The lifting of \definitionref{existential-image} and \definitionref{universal-image} to classes of properties is standard, i.e., simply element-wise.

\begin{lemma}[\Coqed]{\lemmalabel[Trace Relation distributes on Universal Image]{xtrace-distribute-universal}}
  Let $X$ be either a trace-property or a class. Then:
  \begin{goals}
    \goal{xtrace-distribute-universal}{\mapUniversal{\fncompo{\sim_1}{\sim_2}}{X} = \mapUniversal{\sim_2}{\mapUniversal{\sim_1}{X}}}
  \end{goals}
\end{lemma}
\begin{proof}
  Straightforward unfolding of \definitionref{universal-image} and \definitionref{function-composition} in \goalref{xtrace-distribute-universal}.
\end{proof}
\begin{lemma}[\Coqed]{\lemmalabel[Trace Relation distributes on Existential Image]{xtrace-distribute-existential}}
  Let $X$ be either a trace-property or a class. Then:
  \begin{goals}
    \goal{xtrace-distribute-existential}{\mapExistential{\fncompo{\sim_1}{\sim_2}}{X} = \mapExistential{\sim_2}{\mapExistential{\sim_1}{X}}}
  \end{goals}
\end{lemma}
\begin{proof}
  Straightforward unfolding of \definitionref{existential-image} and \definitionref{function-composition} in \goalref{xtrace-distribute-existential}.
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Robust Preservation}

The following definitions for secure compilers are standard~\cite{abate2019jour,abate2021extacc}.

\subsubsection{Differing Trace Models}

A \bul{compiler $\ccST$ for languages $\src{S}$ and $\trg{T}$ robustly preserves a $\trg{T}$-level class $\trgClass$}, if for any \rul{property $\trgProperty$ of class $\trgClass$ and programs $\srcComponent$}, where \iul{$\srcComponent$ robustly satisfies $\mapUniversal{\sim}{\trgProperty}$}, \oul{the compilation of $\srcComponent$, we have that $\ccST\lrpars{\srcComponent}$ robustly satisfies $\trgProperty$}.

\begin{definition}{\definitionlabel[Robust Preservation with $\mapUniversal{\sim}{\cdot}$]{rtp-universal}}
  \begin{center}
    \bul{$\rtpUniversal{\ccST}{\trgClass}{\sim}$}
    %, iff 
    $\isdef$
    \rul{$\forall \trgProperty\in\trgClass, \srcComponent\in\src{S},$} %
    if \iul{$\rsat{\srcComponent}{\mapUniversal{\sim}{\trgProperty}}$},
    then \oul{$\rsat{\ccST\lrpars{\srcComponent}}{\trgProperty}$}.
  \end{center}
\end{definition}
A \bul{compiler $\ccST$ for languages $\src{S}$ and $\trg{T}$ robustly preserves a $\src{S}$-level class $\srcClass$}, if for any \rul{property $\srcProperty$ of class $\srcClass$ and programs $\srcComponent$}, where \iul{$\srcComponent$ robustly satisfies $\srcProperty$}, \oul{the compilation of $\srcComponent$, we have that $\ccST\lrpars{\srcComponent}$ robustly satisfies $\mapExistential{\sim}{\srcProperty}$}.

\begin{definition}{\definitionlabel[Robust Preservation with $\mapExistential{\sim}{\cdot}$]{rtp-existential}}
  \begin{center}
    \bul{$\rtpExistential{\ccST}{\srcClass}{\sim}$}
    %, iff 
    $\isdef$
    \rul{$\forall \srcProperty\in\srcClass, \srcComponent\in\src{S},$} %
    if \iul{$\rsat{\srcComponent}{\srcProperty}$},
    then \oul{$\rsat{\ccST\lrpars{\srcComponent}}{\mapExistential{\sim}{\srcProperty}}$}.
  \end{center}
\end{definition}

\subsubsection{Same Trace Models}

\begin{definition}{\definitionlabel[Robust Preservation]{rtp}}
  \begin{center}
    $\rtp{\ccST}{\varClass}$
    %, iff 
    $\isdef$
    $\forall \varProperty\in\varClass, \srcComponent\in\src{S},$ %
    if $\rsat{\srcComponent}{\varProperty}$,
    then $\rsat{\ccST\lrpars{\srcComponent}}{\varProperty}$.
  \end{center}
\end{definition}

\section{Composition of Secure Compilers}\label{sec:rtpc}

This section presents the composition framework.

\subsection{Same Trace Models}\label{subsec:rtpc-same-trace-models}

In the setting of same trace models, composition of secure compilers (as in \defref{rtp}) is simple:

\begin{lemma}[\Coqed]{\lemmalabel[Composition of RTP]{rtp-compo}}
  If 
  \begin{assumptions}
    \asm{rtp-compo-comp1}{\rtp{\ccSI}{\varClass[_1]}}
    \asm{rtp-compo-comp2}{\rtp{\ccIT}{\varClass[_2]}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-compo}{\rtp{\fncompo{\ccSI}{\ccIT}}{\varClass[_1]\cap\varClass[_2]}}
  \end{goals}
\end{lemma}
\begin{proof}
  Unfold \goalref{rtp-compo} and introduce the assumptions. 
  \begin{passumptions}
    \asm{rtp-compo-prop}{\varProperty\in\varClass[_1]\cap\varClass[_2]}
    \asm{rtp-compo-trg-prog}{\srcComponent\in\src{S}}
    \asm{rtp-compo-rsat}{\rsat{\srcComponent}{\varProperty}}
  \end{passumptions}
  What is left to show is:
  \begin{goals}
    \goal{rtp-compo-rsat}{\rsat{\ccIT\lrpars{\ccSI\lrpars{\srcComponent}}}%
                               {\varProperty}}
  \end{goals}
  Apply \asmref{rtp-compo-comp2} on \goalref{rtp-compo-rsat} and note that due to \asmref{rtp-compo-prop}, $\varProperty\in\varClass[_2]$ also holds.
  \begin{goals}
    \goal{rtp-compo-rsatc}{\rsat{\ccSI\lrpars{\srcComponent}}{\varProperty}}
  \end{goals}
  Similarly, apply \asmref{rtp-compo-comp1} on \goalref{rtp-compo-rsatc} and note that due to \asmref{rtp-compo-prop}, $\varProperty\in\varClass[_1]$ also holds.
  \begin{goals}
    \goal{rtp-compo-rsatp}{\rsat{\srcComponent}{\varProperty}}
  \end{goals}
  \goalref{rtp-compo-rsatp} is resolved by \asmref{rtp-compo-rsat}.
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%
The following corollary is a nice consequence of \lemref{rtp-compo}.
\begin{corollary}[\Coqed]{\corollarylabel[Commutativity of RTP]{rtp-swappable}}
  If 
  \begin{assumptions}
    \asm{rtp-swappable-comp1}{\rtp{\ccII}{\varClass[_1]}}
    \asm{rtp-swappable-comp2}{\rtp{\ccII[\delta]}{\varClass[_2]}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-swappable1}{\rtp{\fncompo{\ccII}{\ccII[\delta]}}{\varClass[_1]\cap\varClass[_2]}}
    \goal{rtp-swappable2}{\rtp{\fncompo{\ccII[\delta]}{\ccII}}{\varClass[_1]\cap\varClass[_2]}}
  \end{goals}
\end{corollary}
\begin{proof}
  \goalref{rtp-swappable1} and \goalref{rtp-swappable2} are an immediate consequence based on \lemmaref{rtp-compo} with \asmref{rtp-swappable-comp1} and \asmref{rtp-swappable-comp2}, noting the commutativity of set intersection.
\end{proof}

\subsection{Different Trace Models}\label{subsec:rtpc-different-trace-models}

The situation in \Cref{subsec:rtpc-same-trace-models} is idealistic in the sense that a somewhat realistic robustly preserving compiler will likely have to insert checks for when control switches from context to component.
For example, compiling from a statically typed language into a dynamically typed one, where the static language enforces functions to only accept numbers, the compiler has to insert appropriate checks to make sure that well-typedness is robustly preserved.
Without such checks, a context could simply supply, e.g., a pair, violating the contract that a function can only receive numbers.

These checks yield a mismatch between the source-level trace and the target-level trace, rendering \definitionref{rtp} not provable.
Instead, one would have to use \definitionref{rtp-universal} or \definitionref{rtp-existential} and use an appropriate, cross-language trace relation that precisely describes the semantic effect on traces when compiling.
For the type-checking function interfaces example, parts of this cross-language trace relation may be sketched as:

\begin{center}
  \typerule{ex-rel-interfaces-agree}{
    \trg{v}\text{ is a number} \rulesep
    \src{v}\approx\trg{v}
  }{
    \xrelTraces{\src{Call\;\ctxtocomp\;v}}{\trg{Call\;\ctxtocomp\;v}}
  }{ex-rel-interfaces-agree}
  \typerule{ex-rel-interfaces-disagree}{
    \trg{v}\text{ not a number}
  }{
    \xrelTraces{\src{Abort}}{\trg{Call\;\ctxtocomp\;v}\cdot\trg{Abort}}
  }{ex-rel-interfaces-disagree}
\end{center}
\trref{ex-rel-interfaces-agree} ensures that both in the source and target-level execution, when the context calls into the component, the values agree and are numerical.

\trref{ex-rel-interfaces-disagree} handles the case where the target-level context supplied a $\trg{v}$ that is not a number.
Here, the backtranslation cannot construct a context that gives a well-typed program {\em and} produces the same trace as the target, since the behavior is ill-defined to begin with.
So, the only option for the backtranslation is to immediately crash.
This, however, is a mismatch with the target-level trace, which only aborts in the wrapper that the compiler inserted.

\begin{definition}{\definitionlabel[Closedness w.r.t. Universal Image]{universal-map-wf}}
  \[
    \mapUniversalWF{\sim}{\trgClass} \isdef \forall \trgProperty\in\trgClass, \mapUniversal{\sim}{\trgProperty}\in\mapUniversal{\sim}{\trgClass}
  \]
\end{definition}
\begin{definition}{\definitionlabel[Closedness w.r.t. Existential Image]{existential-map-wf}}
  \[
    \mapExistentialWF{\sim}{\srcClass} \isdef \forall \srcProperty\in\srcClass, \mapExistential{\sim}{\srcProperty}\in\mapExistential{\sim}{\srcClass}
  \]
\end{definition}


\begin{lemma}[\Coqed]{\lemmalabel[Composition of RTP-Universal]{rtp-universal-compo}}
  If 
  \begin{assumptions}
    \asm{rtp-universal-compo-wfsig}{\mapUniversalWF{\sim_2}{\trgClass[_1]}}
    \asm{rtp-universal-compo-comp1}{\rtpUniversal{\ccSI}{\mapUniversal{\sim_2}{\trgClass[_1]}}{\sim_1}}
    \asm{rtp-universal-compo-comp2}{\rtpUniversal{\ccIT}{\trgClass[_2]}{\sim_2}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-universal-compo}{\rtpUniversal{\fncompo{\ccSI}{\ccIT}}{\trgClass[_1]\cap\trgClass[_2]}{\fncompo{\sim_1}{\sim_2}}}
  \end{goals}
\end{lemma}
\begin{proof}
  Unfold \goalref{rtp-universal-compo} and introduce the assumptions. 
  \begin{passumptions}
    \asm{rtp-universal-compo-prop}{\trgProperty\in\trgClass[_1]\cap\trgClass[_2]}
    \asm{rtp-universal-compo-trg-prog}{\srcComponent\in\src{S}}
    \asm{rtp-universal-compo-rsat}{\rsat{\srcComponent}{\mapUniversal{\fncompo{\sim_1}{\sim_2}}{\trgProperty}}}
  \end{passumptions}
  What is left to show is:
  \begin{goals}
    \goal{rtp-universal-compo-rsat}{\rsat{\ccIT\lrpars{\ccSI\lrpars{\srcComponent}}}%
                                         {\trgProperty}}
  \end{goals}
  Apply \asmref{rtp-universal-compo-comp2} on \goalref{rtp-universal-compo-rsat} and note that due to \asmref{rtp-universal-compo-prop}, $\trgProperty\in\trgClass[_2]$ also holds.
  \begin{goals}
    \goal{rtp-universal-compo-rsatc}{\rsat{\ccSI\lrpars{\srcComponent}}{\mapUniversal{\sim_2}{\trgProperty}}}
  \end{goals}
  Similarly, apply \asmref{rtp-universal-compo-comp1} on \goalref{rtp-universal-compo-rsatc} and note that due to \asmref{rtp-universal-compo-prop} and \asmref{rtp-universal-compo-wfsig}, $\trgProperty\in\mapUniversal{\sim_2}{\trgClass[_1]}$ also holds.
  \begin{goals}
    \goal{rtp-universal-compo-rsatp}{\rsat{\srcComponent}{\mapUniversal{\sim_2}{\mapUniversal{\sim_1}{\trgProperty}}}}
  \end{goals}
  Note that $\mapUniversal{\sim_2}{\mapUniversal{\sim_1}{\trgProperty}}=\mapUniversal{\fncompo{\sim_1}{\sim_2}}{\trgProperty}$, and thus \goalref{rtp-universal-compo-rsatp} is resolved by \asmref{rtp-universal-compo-rsat}.
\end{proof}

\begin{lemma}[\Coqed]{\lemmalabel[Composition of RTP-Existential]{rtp-existential-compo}}
  If 
  \begin{assumptions}
    \asm{rtp-existential-compo-comp1}{\rtpExistential{\ccSI}{\srcClass[_1]}{\sim_1}}
    \asm{rtp-existential-compo-comp2}{\rtpExistential{\ccIT}{\mapExistential{\sim_1}{\srcClass[_2]}}{\sim_2}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-existential-compo}{\rtpExistential{\fncompo{\ccSI}{\ccIT}}{\srcClass[_1]\cap\srcClass[_2]}{\fncompo{\sim_1}{\sim_2}}}
  \end{goals}
\end{lemma}
\begin{proof}
  Similar to \lemmaref{rtp-universal-compo}.
\end{proof}

While compiler passes can be incompatible with each other in the sense that the resulting, mapped property is useless/not what is desired, it is enough to reason about compatibility of compilers at the level of traces.
This is what this work refers to as ,,semantic effect of a compiler''.
Instead of having to do syntactic arguments for the interaction of several compilation passes, one only has to do them for the semantic notion, i.e., the cross-language trace relations, which are much simpler proofs by an order of magnitude. 
\MKin{
  cite section backing up this claim
}

To conclude a similar colloray as \corollaryref{rtp-swappable}, it is of great use to show that a given cross-language trace relation has no effect on the class of security properties.
Then, it is possible to derive the following consequences:

\begin{corollary}[\Coqed]{\lemmalabel[Commutativity of RTP-Universal]{rtp-universal-swappable}}
  If 
  \begin{assumptions}
    \asm{rtp-universal-compo-wfsig1}{\mapUniversalWF{\sim_1}{\irlClass[_2]}}
    \asm{rtp-universal-compo-wfsig2}{\mapUniversalWF{\sim_2}{\irlClass[_1]}}
    \asm{rtp-universal-compo-eq2}{\mapUniversal{\sim_2}{\irlClass[_1]}=\irlClass[_1]}
    \asm{rtp-universal-compo-eq1}{\mapUniversal{\sim_1}{\irlClass[_2]}=\irlClass[_2]}
    \asm{rtp-universal-swappable-comp1}{\rtpUniversal{\ccII}{\irlClass[_1]}{\sim_1}}
    \asm{rtp-universal-swappable-comp2}{\rtpUniversal{\ccII[\delta]}{\irlClass[_2]}{\sim_2}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-universal-swappable1}{\rtpUniversal{\fncompo{\ccII}{\ccII[\delta]}}{\irlClass[_1]\cap\irlClass[_2]}{\fncompo{\sim_1}{\sim_2}}}
    \goal{rtp-universal-swappable2}{\rtpUniversal{\fncompo{\ccII[\delta]}{\ccII}}{\irlClass[_1]\cap\irlClass[_2]}{\fncompo{\sim_2}{\sim_1}}}
  \end{goals}
\end{corollary}
\begin{proof}
  \goalref{rtp-universal-swappable1} and \goalref{rtp-universal-swappable2} are an immediate consequence based on \lemmaref{rtp-universal-compo} with \asmref{rtp-universal-swappable-comp1} and \asmref{rtp-universal-swappable-comp2}, noting the commutativity of set intersection.
\end{proof}

\begin{corollary}[\Coqed]{\lemmalabel[Commutativity of RTP-existential]{rtp-existential-swappable}}
  If 
  \begin{assumptions}
    \asm{rtp-existential-compo-wfsig1}{\mapExistentialWF{\sim_1}{\irlClass[_2]}}
    \asm{rtp-existential-compo-wfsig2}{\mapExistentialWF{\sim_2}{\irlClass[_1]}}
    \asm{rtp-existential-compo-eq2}{\mapExistential{\sim_2}{\irlClass[_1]}=\irlClass[_1]}
    \asm{rtp-existential-compo-eq1}{\mapExistential{\sim_1}{\irlClass[_2]}=\irlClass[_2]}
    \asm{rtp-existential-swappable-comp1}{\rtpExistential{\ccII}{\irlClass[_1]}{\sim_1}}
    \asm{rtp-existential-swappable-comp2}{\rtpExistential{\ccII[\delta]}{\irlClass[_2]}{\sim_2}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-existential-swappable1}{\rtpExistential{\fncompo{\ccII}{\ccII[\delta]}}{\irlClass[_1]\cap\irlClass[_2]}{\fncompo{\sim_1}{\sim_2}}}
    \goal{rtp-existential-swappable2}{\rtpExistential{\fncompo{\ccII[\delta]}{\ccII}}{\irlClass[_1]\cap\irlClass[_2]}{\fncompo{\sim_2}{\sim_1}}}
  \end{goals}
\end{corollary}
\begin{proof}
  \goalref{rtp-existential-swappable1} and \goalref{rtp-existential-swappable2} are an immediate consequence based on \lemmaref{rtp-existential-compo} with \asmref{rtp-existential-swappable-comp1} and \asmref{rtp-existential-swappable-comp2}, noting the commutativity of set intersection.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
\section{Case Study}\label{sec-cs}
This part instantiates the previously presented theory. 
\Cref{subsec-cs-properties} presents all properties. 

\subsection{Properties}\label{subsec-cs-properties}

The properties considered in this case-study are a mixture of trace-properties as welll as hyperproperties.
However, to carry out proofs, all properties are overapproximated by a monitor.

\subsubsection{Formal Definition}\label{subsubsec-cs-properties-formaldef}

For simple memory safety composed of temporal and spatial memory safety, the trace model defines events ($\varEvent[_{\mssafe}]$) as either the empty event ($\emptyevent$), a crash ($\lightning$), or a base-event ($\varEvent[_{\mssafe}]$).

\begin{definition}{\definitionlabel[\glsfirst{ms} Trace Model]{mstraces}}
\[
  \begin{array}{rcll}
    \text{(Base-Events)}&\varEvent[_{\mssafe}] &:=& \msAlloc \mid \msDealloc \mid \msUse \\
    \text{(Events)}&\varEvent[_{\mssafe}] &:=& \varEvent[_{\mssafe}] \mid \emptyevent \mid \lightning \\ 
  \end{array}
\]
\end{definition}

Base-events describe the actual kind of event that happened.
For the basic memory-safety properties, these are three variants:
First, the allocation event ($\msAlloc$) that fires whenever a program claims $n$ cells of memory and stores them at address $\varLoc$, where addresses are assumed to be unique.
Second, deallocation ($\msDealloc$) announces that the object at location $\varLoc$ is freed.
Third, an event to describe reads from and writes to the $n$-th memory cell from address $\varLoc$ ($\msUse$).

\paragraph{Temporal Memory Safety}

\gls*{tms}~\cite{nagarakatte2010cets} is a safety property that describes that an unallocated object must not be (re-)used.
Since it does not care about bounds of an object in memory, we emphasize this fact by deviating from the unified, memory-safety trace model and instead introduce traces for temporal memory safety:
\begin{definition}{\definitionlabel[\glsfirst{tms} Traces]{tmstraces}}
\[
  \begin{array}{rcll}
    \text{(Base-Events)}&\tmsEvent &:=& \tmsAlloc \mid \tmsDealloc \mid \tmsUse \\
    \text{(Events)}&\tmsEvent &:=& \tmsEvent \mid \emptyevent \mid \lightning \\ 
  \end{array}
\]
\end{definition}

With this, \gls*{tms} is defined as follows.
\begin{definition}{\definitionlabel[\glsfirst{tms}]{tmsdef}}
  \[
  \tmssafe:=\left\{\tmsTrace
    \left| 
      \begin{array}{rcl}
        \tmsAlloc&\le_{\tmsTrace}&\tmsDealloc \\
        \tmsUse&\le_{\tmsTrace}&\tmsDealloc \\
      \end{array}
    \right.
  \right\}
  \]
\end{definition}
Hereby, the notation $\varEvent[_{1}]\le_{\varTrace}\varEvent[_{2}]$ means that if $\varEvent[_{1}]$ is in $\varTrace$ and if $\varEvent[_{2}]$ is in $\varTrace$, then $\varEvent[_{1}]$ appears before $\varEvent[_{2}]$.

\paragraph{Spatial Memory Safety}
\gls*{sms}~\cite{nagarakatte2009soft} is a safety property that prohibits out-of-bounds accesses.
For emphasis, we also use a custom trace-model for spatial memory safety.
\begin{definition}{\definitionlabel[\glsfirst{sms} Traces]{smstraces}}
\[
  \begin{array}{rcll}
    \text{(Base-Events)}&\smsEvent &:=& \smsAlloc \mid \smsUse \\
    \text{(Events)}&\smsEvent &:=& \smsEvent \mid \emptyevent \mid \lightning \\ 
  \end{array}
\]
\end{definition}

With this, \gls*{sms} is defined as follows.
\begin{definition}{\definitionlabel[\glsfirst{sms}]{smsdef}}
  \[
  \smssafe:=\left\{\smsTrace \left|\begin{array}{rcl}
      \text{If }\smsAlloc\le_{\smsTrace}\smsUse, \text{ then }m<n
  \end{array}\right.\right\}
  \]
\end{definition}

\paragraph{Memory Safety}

In spirit of earlier work~\cite{nagarakatte2009soft,nagarakatte2010cets,jim2002cyclone,necula2005ccured,michael2023mswasm}, full \gls*{ms} is the intersection of \definitionref{tmsdef} and \definitionref{smsdef}.
However, both properties use a different trace model, so intersecting them alone would trivially yield the empty set.
To remedy this, we define cross-language trace relations that lift both \definitionref{tmstraces} and \definitionref{smstraces} to \definitionref{mstraces}.
\begin{definition}{\definitionlabel[Mapping \glsfirst{ms} to \glsfirst{tms}]{mapping-tms-ms}}
  \newcommand{\mmap}[2]{{#1}\;{\xlangrel{\mssafe}{\tmssafe}}\;{#2}}
  \begin{center}
    \judgbox{\mmap{\msEvent}{\tmsEvent}}{,,Translate \gls*{ms}-events to \gls*{tms}-events.''}

    \typerule{mapping-ms-tms-empty}{}{
      \mmap{\msev{\emptyevent}}{\tmsev{\emptyevent}}
    }{mapping-ms-tms-empty}
    %
    \typerule{mapping-ms-tms-crash}{}{
      \mmap{\msev{\lightning}}{\tmsev{\lightning}}
    }{mapping-ms-tms-crash}
    %
    \typerule{mapping-ms-tms-alloc}{}{
      \mmap{\msAlloc}{\tmsAlloc}
    }{mapping-ms-tms-alloc}
    %
    \typerule{mapping-ms-tms-dealloc}{}{
      \mmap{\msDealloc}{\tmsDealloc}
    }{mapping-ms-tms-dealloc}
    %
    \typerule{mapping-ms-tms-use}{}{
      \mmap{\msUse}{\tmsUse}
    }{mapping-ms-tms-use}
  \end{center}
  \begin{center}
    \judgbox{\mmap{\msTrace}{\tmsTrace}}{,,Translate \gls*{ms}-traces to \gls*{tms}-traces.''}
    
    \typerule{mapping-ms-tms-empty}{}{
      \mmap{\emptyTrace}{\emptyTrace}
    }{mapping-ms-tms-empty}
    %
    \typerule{mapping-ms-tms-cons}{}{
      \mmap{\consTrace{\msEvent}{\msTrace}}{\consTrace{\tmsEvent}{\tmsTrace}}
    }{mapping-ms-tms-cons}
  \end{center}
\end{definition}
\begin{definition}{\definitionlabel[Mapping \glsfirst{ms} to \glsfirst{sms}]{mapping-sms-ms}}
  \newcommand{\mmap}[2]{{#1}\;{\xlangrel{\mssafe}{\smssafe}}\;{#2}}
  \begin{center}
    \judgbox{\mmap{\msEvent}{\smsEvent}}{,,Translate \gls*{ms}-events to \gls*{sms}-events.''}

    \typerule{mapping-ms-sms-empty}{}{
      \mmap{\msev{\emptyevent}}{\smsev{\emptyevent}}
    }{mapping-ms-sms-empty}
    %
    \typerule{mapping-ms-sms-crash}{}{
      \mmap{\msev{\lightning}}{\smsev{\lightning}}
    }{mapping-ms-sms-crash}
    %
    \typerule{mapping-ms-sms-alloc}{}{
      \mmap{\msAlloc}{\smsAlloc}
    }{mapping-ms-sms-alloc}
    %
    \typerule{mapping-ms-sms-dealloc}{}{
      \mmap{\msDealloc}{\emptyevent}
    }{mapping-ms-sms-dealloc}
    %
    \typerule{mapping-ms-sms-use}{
      n=m
    }{
      \mmap{\msUse}{\smsUse}
    }{mapping-ms-sms-use}
  \end{center}
  \begin{center}
    \judgbox{\mmap{\msTrace}{\smsTrace}}{,,Translate \gls*{ms}-traces to \gls*{sms}-traces.''}
    
    \typerule{mapping-ms-sms-empty}{}{
      \mmap{\emptyTrace}{\emptyTrace}
    }{mapping-ms-sms-empty}
    %
    \typerule{mapping-ms-sms-cons}{}{
      \mmap{\consTrace{\msEvent}{\msTrace}}{\consTrace{\smsEvent}{\smsTrace}}
    }{mapping-ms-sms-cons}
  \end{center}
\end{definition}

\begin{definition}{\definitionlabel[\glsfirst{ms}]{msdef}}
  \[
    \mssafe:=\mapUniversal{\xlangrel{\mssafe}{\tmssafe}}{\tmssafe} \cap \mapUniversal{\xlangrel{\mssafe}{\smssafe}}{\smssafe}
  \]
\end{definition}

Note that \definitionref{msdef} ignores data isolation, so there may still be memory-safety issues introduced by side-channels.

\subsubsection{Strict Cryptographic Constant Time}

\begin{definition}{\definitionlabel[\glsfirst{scct} Traces]{sccttraces}}
\[
  \begin{array}{rcll}
    \text{(Secrecy Tags)}&\varSecuritytag &:=& \unlock \mid \lock \\
    \text{(Events)}&\tmsEvent &:=& \scctAny \mid \emptyevent \mid \lightning \\ 
  \end{array}
\]
\end{definition}

\gls*{cct} is a hypersafety property~\cite{barthe2018sec} and, thus, difficult to check with monitors.
This is because, intuitively, hypersafety properties can relate multiple execution traces with each other, but monitors work on a single execution.
It is a common trick to sidestep this issue by means of overapproximation: this section defines the property \gls*{scct}, a stricter variant of \gls*{cct} (inspired by earlier work~\cite{almeida2017jasmin}) that enforces the policy that no secret appears on a trace.
Programs that satisfy \gls*{scct} also satisfy \gls*{cct}, but programs that satisfy \gls*{cct} may not satisfy \gls*{scct}.

\begin{definition}{\definitionlabel[\glsfirst{scct}]{scctdef}}
  \noindent\[
  \scctsafe:=\left\{\scctTrace 
      \left|
        \begin{array}{l}
          \scctTrace=\hole{\cdot} \text{ or } \scctTrace=\lightning \\
          \exists\scctTrace['],\left(\scctTrace=\scctAny[\unlock]\cdot\varTrace[_{\ctsafe}'] \text{ or } \right.\\
          \hspace{2.8em}\left.\scctTrace=\emptyevent\cdot\scctTrace[']
          \wedge \varTrace[_{\ctsafe}']\in\scctsafe \right)
        \end{array}
      \right.
    \right\}
  \]
\end{definition}

\gls*{scct} may appear overly strict, since it seems that secrets must not occur on a trace (since $\varSecuritytag$ is forced to be $\unlock$). 
However, this is considered standard practice in terms of coding guidelines~\cite{ctguidelines}.
Moreover, programs that have been compiled with FaCT~\cite{cauligi2019fact} and run with a ``data independent timing mode''~\cite{arm-refman,intel-refman} enabled do not leak secrets. 
We'd like to emphasize that our goal is to motivate the core theory presented in \Cref{sec:rtpc} and not develop a new programming language.

\paragraph{\gls*{ms}, Strict Cryptographic Constant Time}

The combination of \gls*{ms} and \gls*{scct} is the intersection of these properties, \gls*{msscct}.
However, \gls*{ms} uses a different trace model than \gls*{scct}, so intersecting them would trivially yield the empty set. 
To remedy this issue, we introduce $\xlangrel{\scctsafe}{\mssafe} : \scctEvent \to \msEvent \to \mathbb{P}$, a cross-language trace relation (whose key cases are presented below), that we use to intuitively unify the trace model in which the two properties are expressed:

\begin{definition}{\definitionlabel[Mapping \glsfirst{ms} to \glsfirst{scct}]{mapping-ms-scct}}
  \newcommand{\mmap}[2]{{#1}\;{\xlangrel{\mssafe}{\scctsafe}}\;{#2}}
  \begin{center}
    \judgbox{\mmap{\msEvent}{\scctEvent}}{,,Translate \gls*{ms}-events to \gls*{scct}-events.''}

    \typerule{mapping-ms-scct-empty}{}{
      \mmap{\msev{\emptyevent}}{\scctev{\emptyevent}}
    }{mapping-ms-scct-empty}
    %
    \typerule{mapping-ms-scct-crash}{}{
      \mmap{\msev{\lightning}}{\scctev{\lightning}}
    }{mapping-ms-scct-crash}
    %
    \typerule{mapping-ms-scct-alloc}{}{
      \mmap{\msAlloc}{\scctAny[\unlock]}
    }{mapping-ms-scct-alloc}
    %
    \typerule{mapping-ms-scct-dealloc}{}{
      \mmap{\msDealloc}{\scctAny[\unlock]}
    }{mapping-ms-scct-dealloc}
    %
    \typerule{mapping-ms-scct-use}{}{
      \mmap{\msUse}{\scctAny[\unlock]}
    }{mapping-ms-scct-use}
  \end{center}
  \begin{center}
    \judgbox{\mmap{\msTrace}{\scctTrace}}{,,Translate \gls*{ms}-traces to \gls*{scct}-traces.''}
    
    \typerule{mapping-ms-scct-empty}{}{
      \mmap{\emptyTrace}{\emptyTrace}
    }{mapping-ms-scct-empty}
    %
    \typerule{mapping-ms-scct-cons}{}{
      \mmap{\consTrace{\msEvent}{\msTrace}}{\consTrace{\scctEvent}{\scctTrace}}
    }{mapping-ms-scct-cons}
  \end{center}
\end{definition}

%Essentially, $\sim_{\ctsafe}$ ignores both the new $\ev{Branch\ n}$ and $\ev{Binop\ n}$ base-events as it relates security-insensitive actions ($\unlock$) to their equivalent counterparts.
\gls*{ms} traces trivially satisfy \gls*{scct}, since it is assumed here that they are the result of a cryptographic constant time computation.
This may be ensured by a compiler, such as FaCT, or the semantics of the language itself.
We also don't have any other information in \gls*{scct} traces besides the secrecy tags, since the semantics of a language can simply tag relevant events with the respective vulnerability, such as a leak of secret data.
% 
It is now possible to define \gls*{msscct} using the universal image:

\begin{definition}{\definitionlabel[\glsfirst{ms} and \glsfirst{scct}]{msscctdef}}
  \[
    \msscctsafe:=\mssafe\cap\mapUniversal{\xlangrel{\mssafe}{\scctsafe}}{\scctsafe}
  \]
\end{definition}

\paragraph{Extending the Trace Model with Speculation}

So far, the considered trace models do not let us express speculative execution attacks such as Spectre~\cite{kocher2019spectre}. 
For this, we extend the earlier trace model so that the secrecy tags ($\varSecuritytag{}$) carry additional information about the kind of private data leakage, i.e., the type of speculative leak.
This tag may be emitted by the semantics of a concrete programming language, as seen in earlier work~\cite{fabian2022automatic}. 
%Moreover, we add base-events signalling the beginning of a speculative execution ($\ev{Spec}$), a barrier ($\ev{Barrier}$) that signals that any speculative execution may not go past it, as well as a rollback event ($\ev{Rlb}$), which signals that execution resumes to where speculation started.

\begin{definition}{\definitionlabel[\glsfirst{ss} traces]{sstraces}}
{
\[
  \begin{array}{rrcl}
    (\text{Spectre Variants}) & vX &:=& \operatorname{NONE} \mid \operatorname{PHT} \mid \dots \\
    (\text{Secrecy Tags}) & \varSecuritytag{} &:=& \lock_{vX} \mid \unlock\\ 
    (\text{Events}) & \specEvent &:=& \specEvent \mid \emptyevent \mid \lightning \\ 
  \end{array}
\]
}
\end{definition}

%Even though the considered Spectre variants are just SPECTRE-PHT~\cite{kocher2019spectre}, NONE just describes secret data as in \gls*{scct} (see \Cref{subsec:scct:tracemodel}), the trace model is general enough to allow for potential future extension with different variants~\cite{kocher2019spectre,maisuradze2018ret2spec,horn2019zero}.
NONE describes secret data as in \gls*{scct} (see \Cref{subsec:scct:tracemodel}).
Any other secrecy tag, such as PHT, describes the concrete reason for the respective leak.
The trace model in \defref{sstraces} is general enough to allow for potential future extension with different variants~\cite{kocher2019spectre,maisuradze2018ret2spec,horn2019zero}.
%For sake of readability, this paper just uses the notation $\lock$ in place of $\lock_{\text{PHT}}$.

\subsubsection{Speculation Safety}

\gls*{ss}~\cite{patrignani2021exorcising}, similar to \gls*{scct}, is a sound overapproximation of a variant of noninterference.

\begin{definition}{\definitionlabel[\glsfirst{ss}]{ssdef}}
  \[
    \sssafe := \left\{
      \specTrace
        \left|
          \begin{array}{l}
            \specTrace=\hole{\cdot} 
              \text{ or } 
            \specTrace=\lightning
              \text{ or }
            \exists\specTrace['].\\
            %
            \left(\specTrace=\specAny[\unlock]\cdot\specTrace['] 
              \text{or }
            \varTrace[_{\mathghost}]=\specAny[\lock_{\text{NONE}}]\cdot\specTrace[']\right.\\
            \hspace{2em}\text{or }
            \left.\varTrace[_{\mathghost}]=\emptyevent\cdot\specTrace[']\right)\\
            %
            \text{and }%
            \ \varTrace[_{\mathghost}']\in\sssafe
          \end{array}
        \right.
      \right\}
  \] 
\end{definition}
The technical setup so far leads to the above definition, where only locks annotated with $\text{SPECTRE-PHT}$ are disallowed to occur on the trace.
That way, programs attaining \gls*{ss} do not necessarily attain \gls*{scct}.

\subsubsection{Speculation Memory Safety}\label{sec:spec-ms-rel}

As before, we need to relate the different trace models with each other, so that the memory safety property without speculation can be lifted to speculation. 
To this end, let $\xlangrel{ms}{ss}: \msEvent \to \specEvent\to\mathbb{P}$ be a cross-language trace relation whose key cases are below.
The intuition is that \gls*{ss} is trivially satisfied in \gls*{ms}, since speculation is inexpressible there and a language attaining \gls*{ms} by means of semantics can enforce \gls*{ss} simply by not having a speculative dynamic semantics. 
In turn, all base events tagged with $\lock_{\text{PHT}}$ are simply dropped. 

\begin{definition}{\definitionlabel[Mapping \glsfirst{ms} to \glsfirst{ss}]{mapping-ms-spec}}
  \newcommand{\mmap}[2]{{#1}\;{\xlangrel{\mssafe}{\sssafe}}\;{#2}}
  \begin{center}
    \judgbox{\mmap{\msEvent}{\specEvent}}{,,Translate \gls*{ms}-events to \gls*{ss}-events.''}

    \typerule{mapping-ms-spec-empty}{}{
      \mmap{\msev{\emptyevent}}{\specev{\emptyevent}}
    }{mapping-ms-spec-empty}
    %
    \typerule{mapping-ms-spec-crash}{}{
      \mmap{\msev{\lightning}}{\specev{\lightning}}
    }{mapping-ms-spec-crash}
    %
    \typerule{mapping-ms-spec-alloc}{}{
      \mmap{\msAlloc}{\specAny[\unlock]}
    }{mapping-ms-spec-alloc}
    %
    \typerule{mapping-ms-spec-dealloc}{}{
      \mmap{\msDealloc}{\specAny[\unlock]}
    }{mapping-ms-spec-dealloc}
    %
    \typerule{mapping-ms-spec-use}{}{
      \mmap{\msUse}{\specAny[\unlock]}
    }{mapping-ms-spec-use}
  \end{center}
  \begin{center}
    \judgbox{\mmap{\msTrace}{\specTrace}}{,,Translate \gls*{ms}-traces to \gls*{ss}-traces.''}
    
    \typerule{mapping-ms-spec-empty}{}{
      \mmap{\emptyTrace}{\emptyTrace}
    }{mapping-ms-spec-empty}
    %
    \typerule{mapping-ms-spec-cons}{}{
      \mmap{\consTrace{\msEvent}{\msTrace}}{\consTrace{\specEvent}{\specTrace}}
    }{mapping-ms-spec-cons}
  \end{center}
\end{definition}

We conclude with the ultimate property of interest for our secure compiler: \gls*{specms}.
\begin{definition}{\definitionlabel[\glsfirst{specms}]{specmsdef}}
  \[
    \specmssafe := \msscctsafe\cap\mapUniversal{\xlangrel{\mssafe}{\sssafe}}{\sssafe}
  \]
\end{definition}


\subsection{Monitors}\label{subsec-cs-monitors}

This part presents monitors for the properties presented in \Cref{subsec-cs-properties}.
Since all properties are safety properties, it is enough to consider trace-prefixes, i.e., finite lists of events.

\subsubsection{\gls*{tms} Monitor}\label{subsubsec-mon-tms}

\begin{definition}{\definitionlabel[\gls*{tms} Monitor]{monitor-tms}}
  \begin{gather*}
    \begin{aligned}
      \text{(Abstract Store)}~\tmsMonitor &\isdef\{A : \mi{Locs}, F : \mi{Locs}\} \\
      \tmsMonitor\subseteq_F \tmsMonitor['] &\text{ iff } \tmsMonitor[.F] \subseteq \tmsMonitor['.F]\\
      \varLoc\in \tmsMonitor &\text{ iff } \varLoc \in {\tmsMonitor[.A]} \wedge \varLoc \notin {\tmsMonitor[.F]}\\
      \varLoc\notin \tmsMonitor &\text{ iff } \varLoc \notin {\tmsMonitor[.A]} \wedge \varLoc \notin {\tmsMonitor[.F]}\\
      \{\varLoc\}\cup \tmsMonitor &= \{A : \{\varLoc\}\cup \tmsMonitor[.A], F : \tmsMonitor[.F]\}\\
      \tmsMonitor\setminus\{\varLoc\} &= \{A : \tmsMonitor[.A]\setminus\{\varLoc\}, F : \tmsMonitor[.F]\cup\left\{\varLoc\right\}\}\\
      \tmsMonitor\cup \tmsMonitor' &= \{A : \tmsMonitor[.A]\cup \tmsMonitor['.A], F : \tmsMonitor[.F]\cup \tmsMonitor['.F]\}\\
    \end{aligned}
  \end{gather*}
\end{definition}

The reductions are defined as follows:
\begin{definition}{\definitionlabel[\gls*{tms} Monitor Reductions]{monitor-tms-steps}}
  \begin{center}
    \judgbox{\monitorcheck[]{\tmsMonitor}{\tmsMonitor[']}{\tmsEvent}}{,,Given abstract state $\tmsMonitor$, step to abstract state $\tmsMonitor'$\\ emitting an abstract event $\tmsEvent$.''}

    \typerule{tmsmon-empty}{}{
      \monitorcheck[]{\tmsMonitor}{\tmsMonitor}{\emptyevent}
    }{tmsmon-empty}
    \typerule{tmsmon-alloc}{
      \varLoc\not\in\tmsMonitor
    }{
      \monitorcheck[]{\tmsMonitor}{\{\varLoc\}\cup\tmsMonitor}{\tmsAlloc}
    }{tmsmon-alloc}
    \typerule{tmsmon-dealloc}{
      \varLoc\in\tmsMonitor
    }{
      \monitorcheck[]{\tmsMonitor}{\tmsMonitor\setminus\{\varLoc\}}{\tmsDealloc}
    }{tmsmon-dealloc}
    \typerule{tmsmon-use}{
      \varLoc\in\tmsMonitor
    }{
      \monitorcheck[]{\tmsMonitor}{\tmsMonitor}{\tmsUse}
    }{tmsmon-use}
    \typerule{tmsmon-crash}{}{
      \monitorcheck[]{\tmsMonitor}{\tmsMonitor}{\lightning}
    }{tmsmon-crash}
  \end{center}
  \begin{center}
    \judgbox{\monitorcheck{\tmsMonitor}{\tmsMonitor[']}{\tmsEvent}}{,,Reflexive-Transitive closure of above judgement.\\$\tmsTrace$ is a list of events.''}

    \typerule{tmsmon-refl}{
      \tmsMonitor[.A]=\emptyset
    }{
      \monitorcheck{\tmsMonitor}{\tmsMonitor}{\hole{\cdot}}
    }{tmsmon-refl}
    %
    \typerule{tmsmon-trans}{
      \monitorcheck[]{\tmsMonitor}{\tmsMonitor[']}{\tmsEvent} \rulesep
      \monitorcheck{\tmsMonitor[']}{\tmsMonitor['']}{\tmsTrace}
    }{
      \monitorcheck{\tmsMonitor}{\tmsMonitor['']}{\tmsEvent\cdot\tmsTrace}
    }{tms-trans}
  \end{center}
\end{definition}

\begin{definition}{\definitionlabel[Trace is \gls*{tms} via Monitor]{trace-is-tms-via-mon}}
  \begin{align*}
    \tmssafe\vdash\tmsTrace &\isdef \exists\tmsMonitor,\monitorcheck{\emptyset}{\tmsMonitor}{\tmsTrace}
  \end{align*}
\end{definition}

\begin{lemma}{\lemmalabel[Monitor \gls*{tms} is $\tmssafe$]{monitor-tms-is-tms}}
  If
  \begin{assumptions}
    \asm{monitor-tms-is-tms}{\tmssafe\vdash\tmsTrace}
  \end{assumptions}
  then
  \begin{goals}
    \goal{monitor-tms-is-tms}{\tmsTrace\in\tmssafe}
  \end{goals}
\end{lemma}
\begin{proof}
  \incompleteProof
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{\gls*{sms} Monitor}\label{subsubsec-mon-sms}
\begin{definition}{\definitionlabel[\gls*{sms} Monitor]{monitor-sms}}
  \begin{gather*}
    \begin{aligned}
      \text{(Abstract Store)}~\smsMonitor &\isdef \mi{Locs}\times\mathbb{N} \\
      \operatorname{dom}\lrpars{\smsMonitor}&=\{\varLoc \mid \forall n, \lrpars{\varLoc;n}\in\smsMonitor\}
    \end{aligned}
  \end{gather*}
\end{definition}

The reductions are defined as follows:
\begin{definition}{\definitionlabel[\gls*{sms} Monitor Reductions]{monitor-sms-steps}}
  \begin{center}
    \judgbox{\monitorcheck[]{\smsMonitor}{\smsMonitor[']}{\smsEvent}}{,,Given abstract state $\smsMonitor$, step to abstract state $\smsMonitor'$\\ emitting an abstract event $\smsEvent$.''}

    \typerule{smsmon-empty}{}{
      \monitorcheck[]{\smsMonitor}{\smsMonitor}{\emptyevent}
    }{smsmon-empty}
    \typerule{smsmon-alloc}{
      \varLoc\not\in\operatorname{dom}\lrpars{\smsMonitor}
    }{
      \monitorcheck[]{\smsMonitor}{\{\varLoc\}\cup\smsMonitor}{\smsAlloc}
    }{smsmon-alloc}
    \typerule{smsmon-use}{
      \lrpars{\varLoc;n}\in\smsMonitor \rulesep
      m<n
    }{
      \monitorcheck[]{\smsMonitor}{\smsMonitor}{\smsUse}
    }{smsmon-use}
    \typerule{smsmon-crash}{}{
      \monitorcheck[]{\smsMonitor}{\smsMonitor}{\lightning}
    }{smsmon-crash}
  \end{center}
  \begin{center}
    \judgbox{\monitorcheck{\smsMonitor}{\smsMonitor[']}{\smsEvent}}{,,Reflexive-Transitive closure of above judgement.\\$\smsTrace$ is a list of events.''}

    \typerule{smsmon-refl}{
      \smsMonitor=\emptyset
    }{
      \monitorcheck{\smsMonitor}{\smsMonitor}{\hole{\cdot}}
    }{smsmon-refl}
    %
    \typerule{smsmon-trans}{
      \monitorcheck[]{\smsMonitor}{\smsMonitor[']}{\smsEvent} \rulesep
      \monitorcheck{\smsMonitor[']}{\smsMonitor['']}{\smsTrace}
    }{
      \monitorcheck{\smsMonitor}{\smsMonitor['']}{\smsEvent\cdot\smsTrace}
    }{smsmon-trans}
  \end{center}
\end{definition}

\begin{definition}{\definitionlabel[Trace is \gls*{sms} via Monitor]{trace-is-sms-via-mon}}
  \begin{align*}
    \smssafe\vdash\smsTrace &\isdef \exists\smsMonitor,\monitorcheck{\emptyset}{\smsMonitor}{\smsTrace}
  \end{align*}
\end{definition}

\begin{lemma}{\lemmalabel[Monitor \gls*{sms} is $\smssafe$]{monitor-sms-is-sms}}
  If
  \begin{assumptions}
    \asm{monitor-sms-is-sms}{\smssafe\vdash\smsTrace}
  \end{assumptions}
  then
  \begin{goals}
    \goal{monitor-sms-is-sms}{\smsTrace\in\smssafe}
  \end{goals}
\end{lemma}
\begin{proof}
  \incompleteProof
\end{proof}

\subsubsection{Dual-Monitor}\label{subsubsec-mon-dual}

\begingroup
  \newcommand{\aM}[1][]{\varMonitor[A]#1}
  \newcommand{\bM}[1][]{\varMonitor[B]#1}
  \newcommand{\aE}[1][]{\varEvent[A]#1}
  \newcommand{\bE}[1][]{\varEvent[B]#1}

For sake of this section, let $A,B$ be monitors with respective monitor states $\aM$ and $\bM$.
Then, both monitor states can be combined as follows:

\begin{definition}{\definitionlabel[Dual-Monitor State]{monitor-dual}}
  \begin{gather*}
    \begin{aligned}
      \text{(Abstract State)}~\dualMonitor &\isdef \aM \times \bM\\
    \end{aligned}
  \end{gather*}
\end{definition}

The reductions are defined as follows:
\begin{definition}{\definitionlabel[Dual-Monitor Reductions]{monitor-dual-steps}}
  \begin{center}
    \typerule{dualmon-refl}{}{
      \monitorcheck{\lrpars{\emptyset_A;\emptyset_B}}{\lrpars{\emptyset_A;\emptyset_B}}{\hole{\cdot}}
    }{dualmon-refl}
    %
    \typerule{dualmon-trans-emptyA}{
      \dualMonitor=\lrpars{\aM;\bM} \rulesep
      \monitorcheck[]{\bM}{\bM}{\bE} \rulesep
      \monitorcheck{\dualMonitor}{\dualMonitor[']}{\varTrace[_{A;B}]}
    }{
      \monitorcheck{\dualMonitor}{\dualMonitor[']}{\lrpars{\emptyevent;\bE}\cdot\varTrace[_{A;B}]}
    }{dualmon-trans-emptyA}
    %
    \typerule{dualmon-trans-emptyB}{
      \dualMonitor=\lrpars{\aM;\bM} \rulesep
      \aE\not=\emptyevent \rulesep
      \monitorcheck[]{\aM}{\aM}{\aE} \rulesep
      \monitorcheck{\dualMonitor}{\dualMonitor[']}{\varTrace[_{A;B}]}
    }{
      \monitorcheck{\dualMonitor}{\dualMonitor}{\lrpars{\aE;\emptyevent}\cdot\varTrace[_{A;B}]}
    }{dualmon-trans-emptyB}
    %
    \typerule{dualmon-trans}{
      \lrpars{\aE;\bE}\not=\lrpars{\emptyevent;\emptyevent} \rulesep
      \monitorcheck[]{\aM}{\aM[']}{\aE} \rulesep
      \monitorcheck[]{\bM}{\bM[']}{\bE} \rulesep
      \monitorcheck{\dualMonitor}{\dualMonitor[']}{\varTrace[_{A;B}]}
    }{
      \monitorcheck{\dualMonitor}{\dualMonitor}{\lrpars{\aE;\bE}\cdot\varTrace[_{A;B}]}
    }{dualmon-trans}
  \end{center}
\end{definition}

\begin{definition}{\definitionlabel[Dual-Trace Satisfaction via Monitor]{trace-is-ab-via-mon}}
  Let $A,B$ monitors and $\varProperty$ a property,
  \begin{align*}
    \varProperty\vdash\varTrace[A;B] &\isdef \exists\aM\;\bM,\monitorcheck{\emptyset}{\lrpars{\aM;\bM}}{\varTrace[A;B]}
  \end{align*}
\end{definition}

% \begin{lemma}{\lemmalabel[Monitor \gls*{sms} is $\smssafe$]{monitor-sms-is-sms}}
%   If
%   \begin{assumptions}
%     \asm{monitor-sms-is-sms}{\smssafe\vdash\smsTrace}
%   \end{assumptions}
%   then
%   \begin{goals}
%     \goal{monitor-sms-is-sms}{\smsTrace\in\smssafe}
%   \end{goals}
% \end{lemma}
% \begin{proof}
%   \incompleteProof
% \end{proof}
\endgroup

\subsubsection{\gls*{ms} Monitor}\label{subsubsec-mon-ms}
Instantiate \Cref{subsubsec-mon-dual} with \Cref{subsubsec-mon-tms,subsubsec-mon-sms}. 
What is left to give is a translation from traces $\msTrace$ to traces $\varTrace[\tmssafe;\smssafe]$.
This translation is done as follows:
\begin{definition}{\definitionlabel[\gls*{ms} to \gls*{tms} and \gls*{sms}]{traces-ms-to-tmssms}}
  ...
\end{definition}

\subsubsection{\gls*{scct} Monitor}\label{subsubsec-mon-scct}
placeholder
\subsubsection{\gls*{msscct} Monitor}\label{subsubsec-mon-msscct}
placeholder
\subsubsection{\gls*{ss} Monitor}\label{subsubsec-mon-spec}
placeholder
\subsubsection{\gls*{specms} Monitor}\label{subsubsec-mon-specms}
placeholder

%%%%%%%%%%%%%

\subsection{$\src{RusT}$- A Temporal Memory Safe Language}\label{subsec-rust}
placeholder
\subsubsection{Syntax}\label{subsec-rust-syntax}
placeholder
\subsubsection{Static Semantics}\label{subsec-rust-static}
placeholder
\subsubsection{Dynamic Semantics}\label{subsec-rust-dynamic}
placeholder
\subsubsection{Properties}\label{subsec-rust-properties}
placeholder

%%%%%%%%%%%%%

\subsection{$\irl{CePeEs}$- An Intermediate Representation}\label{subsec-cepees}
placeholder
\subsubsection{Syntax}\label{subsec-cepees-syntax}
placeholder
\subsubsection{Static Semantics}\label{subsec-cepees-static}
placeholder
\subsubsection{Dynamic Semantics}\label{subsec-cepees-dynamic}
placeholder
\subsubsection{Properties}\label{subsec-cepees-properties}
placeholder

%%%%%%%%%%%%%

\subsection{Compiler from $\src{RusT}$ to $\irl{CePeEs}$}\label{subsec-rust-to-cepees}
placeholder
\subsubsection{Secure Compiler}\label{subsec-rust-to-cepees-seccomp}
placeholder

\subsection{Bounds-Check Instrumentation in $\irl{CePeEs}$}\label{subsec-softbounds-in-cepees}
placeholder
\subsubsection{Secure Compiler}\label{subsec-softbounds-cepees-seccomp}
placeholder

\subsection{Improved Compiler from $\src{RusT}$ to $\irl{CePeEs}$}\label{subsec-improved-rust-to-cepees}
placeholder
\subsubsection{Secure Compiler}\label{subsec-improved-rust-to-cepees-seccomp}
placeholder

\subsection{Dead Code Elimination in $\irl{CePeEs}$}\label{subsec-dce-in-cepees}
placeholder
\subsubsection{Secure Compiler}\label{subsec-dce-cepees-seccomp}
placeholder

\subsection{Constant Folding in $\irl{CePeEs}$}\label{subsec-cf-in-cepees}
placeholder
\subsubsection{Secure Compiler}\label{subsec-cf-cepees-seccomp}
placeholder

\subsection{Optimising Compiler from $\src{RusT}$ to $\irl{CePeEs}$}\label{subsec-optimising-rust-to-cepees}
placeholder
\subsubsection{Secure Compiler}\label{subsec-optimising-rust-to-cepees-seccomp}
placeholder

%%%%%%%%%%%%%

\subsection{$\obj{A}$ - An Assembly-Like Target}\label{subsec-a}
placeholder
\subsubsection{Syntax}\label{subsec-a-syntax}
placeholder
\subsubsection{Static Semantics}\label{subsec-a-static}
placeholder
\subsubsection{Dynamic Semantics}\label{subsec-a-dynamic}
placeholder
\subsubsection{Properties}\label{subsec-a-properties}
placeholder

%%%%%%%%%%%%

\subsection{Compiler from $\irl{CePeEs}$ to $\obj{A}$}\label{subsec-cepees-to-a}
placeholder
\subsubsection{Secure Compiler}\label{subsec-cepees-to-a-seccomp}
placeholder

\subsection{Compiler from $\src{RusT}$ to $\obj{A}$}\label{subsec-rust-to-a}
placeholder
\subsubsection{Secure Compiler}\label{subsec-rust-to-a-seccomp}
placeholder

%%%%%%%%%%%%

\subsection{$\ird{SpA}$ - An Assembly-Like Target with Speculation}\label{subsec-spa}
placeholder
\subsubsection{Syntax}\label{subsec-spa-syntax}
placeholder
\subsubsection{Static Semantics}\label{subsec-spa-static}
placeholder
\subsubsection{Dynamic Semantics}\label{subsec-spa-dynamic}
placeholder
\subsubsection{Properties}\label{subsec-spa-properties}
placeholder

%%%%%%%%%%%%

\subsection{Compiler from $\obj{A}$ to $\ird{SpA}$}\label{subsec-a-to-spa}
placeholder
\subsubsection{Secure Compiler}\label{subsec-a-to-spa-seccomp}
placeholder

\subsection{Compiler from $\src{RusT}$ to $\ird{SpA}$}\label{subsec-rust-to-spa}
placeholder
\subsubsection{Secure Compiler}\label{subsec-rust-to-spa-seccomp}
placeholder


\clearpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\printglossary

\end{document}
\endinput
