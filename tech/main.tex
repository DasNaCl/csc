% Fixing: Too many math alphabets used in version normal.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\documentclass[a4paper,12pt]{article}
\usepackage[left=1.5cm,top=1.5cm,right=1.5cm,bottom=1.5cm]{geometry}
\usepackage{parskip}

% https://tex.stackexchange.com/questions/648845/sans-serif-uppercase-greek-no-longer-showing-in-acmart
\DeclareMathAlphabet{\mathsf}{OT1}{LibertinusSans-LF}{m}{n}
\SetMathAlphabet{\mathsf}{bold}{OT1}{LibertinusSans-LF}{bx}{n}
\DeclareMathAlphabet{\mathtt}{OT1}{lmtt}{m}{n}
\SetMathAlphabet{\mathtt}{bold}{OT1}{lmtt}{bx}{n}

\input{cmds.tex}

\loadglsentries{acronyms}
\makeglossaries

\title{Secure Composition of Robust and Optimising Compilers}
\begin{document}

\maketitle

\begin{abstract}
% context
To ensure that secure applications do not leak their secrets, they are required to uphold several security properties such as spatial and temporal memory safety, cryptographic constant time, as well as speculative safety.
% need
Existing work shows how to enforce these properties individually, in an architecture-independent way, by using secure compiler passes that each focus on an individual property.
% task
Unfortunately, given two secure compiler passes that each preserve a possibly different security property, it is unclear what kind of security property is preserved by the composition of those secure compiler passes.
%there is no way to tell what kind of security property will the composition of those secure compilers preserve.

% object
This paper is the first to study what security properties are preserved across the composition of different secure compiler passes.
% findings
Starting from a general theory of property composition for security-relevant properties (such as the aforementioned ones), this paper formalises a theory of composition of secure compilers.
Then, it showcases this theory on a secure multi-pass compiler that preserves the aforementioned security-relevant properties.
% conclusion
Crucially, this paper derives the security of the multi-pass compiler from the composition of the security properties preserved by its individual passes, which include security-preserving as well as optimisation passes.
% 
From an engineering perspective, this is the desirable approach to building secure compilers.
\begin{center}\small\it
	{This paper uses syntax highlighting accessible to both colourblind and black \& white readers.}
\end{center}
\end{abstract}

\appendix

\section{Background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Satisfaction}
\bul{A whole program $\varWholeProg$ satisfies a property $\varProperty$} iff \iul{$\varWholeProg$ yields a trace $\varTrace$} such that \oul{$\varTrace$ satisfies $\varProperty$}.

\begin{definition}{\definitionlabel[Property Satisfaction]{prop-sat}}
    \bul{$\sat{\varWholeProg}{\varProperty}$}
    $\isdef$
    if \iul{$\forall\varRuntimeTerm\ \varTrace, %
      \progstepto{\varWholeProg}{\varRuntimeTerm}{\varTrace}$
    },
    then \oul{$\varTrace\in\varProperty$}.
\end{definition}

With this, \definitionref{prop-sat} can be extended as follows: for \bul{a component $\varComponent$ to robustly satisfy a property $\varProperty$}, take an \iul{attacker context $\varContext$ and link it with $\varComponent$}, \oul{the resulting whole program must satisfy $\varProperty$}.

\begin{definition}{\definitionlabel[Robust Property Satisfaction]{prop-rsat}}
  \bul{$\rsat{\varComponent}{\varProperty}$} %
  $\isdef$ %
  \iul{$\forall \varContext\ \varWholeProg$, %
    if $\bopLink{\varContext}{\varComponent} = \varWholeProg$}, %
    then \oul{$\sat{\varWholeProg}{\varProperty}$%
  }.
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Property Mappings}

\begin{definition}{\definitionlabel[Universal Image]{universal-image}}
  $ 
    \mapUniversal{\sim}{\trgProperty} := 
      \lrbraces{\srcTrace \mid %
        \forall \trgTrace\ldotp \text{if }\xrelTraces{\srcTrace}{\trgTrace}, \text{ then }%
        \trgTrace\in\trgProperty
      }
  $
\end{definition}
\begin{definition}{\definitionlabel[Existential Image]{existential-image}}
  $ 
    \mapExistential{\sim}{\srcProperty} := 
      \lrbraces{\trgTrace \mid %
        \exists \srcTrace\ldotp \xrelTraces{\srcTrace}{\trgTrace} \text{ and }%
        \srcTrace\in\srcProperty
      }
  $
\end{definition}

The lifting of \definitionref{existential-image} and \definitionref{universal-image} to classes of properties is standard, i.e., simply element-wise.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Robust Preservation}

\subsubsection{Differing Trace Models}

A \bul{compiler $\ccST$ for languages $\src{S}$ and $\trg{T}$ robustly preserves a $\trg{T}$-level class $\trgClass$}, if for any \rul{property $\trgProperty$ of class $\trgClass$ and programs $\srcComponent$}, where \iul{$\srcComponent$ robustly satisfies $\mapUniversal{\sim}{\trgProperty}$}, \oul{the compilation of $\srcComponent$, we have that $\ccST\lrpars{\srcComponent}$ robustly satisfies $\trgProperty$}.

\begin{definition}{\definitionlabel[Robust Preservation with $\mapUniversal{\sim}{\cdot}$]{rtp-universal}}
  \begin{center}
    \bul{$\rtpUniversal{\ccST}{\trgClass}{\sim}$}
    %, iff 
    $\isdef$
    \rul{$\forall \trgProperty\in\trgClass, \srcComponent\in\src{S},$} %
    if \iul{$\rsat{\srcComponent}{\mapUniversal{\sim}{\trgProperty}}$},
    then \oul{$\rsat{\ccST\lrpars{\srcComponent}}{\trgProperty}$}.
  \end{center}
\end{definition}
A \bul{compiler $\ccST$ for languages $\src{S}$ and $\trg{T}$ robustly preserves a $\src{S}$-level class $\srcClass$}, if for any \rul{property $\srcProperty$ of class $\srcClass$ and programs $\srcComponent$}, where \iul{$\srcComponent$ robustly satisfies $\srcProperty$}, \oul{the compilation of $\srcComponent$, we have that $\ccST\lrpars{\srcComponent}$ robustly satisfies $\mapExistential{\sim}{\srcProperty}$}.

\begin{definition}{\definitionlabel[Robust Preservation with $\mapExistential{\sim}{\cdot}$]{rtp-existential}}
  \begin{center}
    \bul{$\rtpExistential{\ccST}{\srcClass}{\sim}$}
    %, iff 
    $\isdef$
    \rul{$\forall \srcProperty\in\srcClass, \srcComponent\in\src{S},$} %
    if \iul{$\rsat{\srcComponent}{\srcProperty}$},
    then \oul{$\rsat{\ccST\lrpars{\srcComponent}}{\mapExistential{\sim}{\srcProperty}}$}.
  \end{center}
\end{definition}

\subsubsection{Same Trace Models}

\begin{definition}{\definitionlabel[Robust Preservation]{rtp}}
  \begin{center}
    $\rtp{\ccST}{\varClass}$
    %, iff 
    $\isdef$
    $\forall \varProperty\in\varClass, \srcComponent\in\src{S},$ %
    if $\rsat{\srcComponent}{\varProperty}$,
    then $\rsat{\ccST\lrpars{\srcComponent}}{\varProperty}$.
  \end{center}
\end{definition}


\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\printglossary

\end{document}
\endinput
