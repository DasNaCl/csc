% Fixing: Too many math alphabets used in version normal.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\documentclass[a4paper,12pt]{article}
\usepackage[left=1.5cm,top=1.5cm,right=1.5cm,bottom=1.5cm]{geometry}
\usepackage{parskip}

% https://tex.stackexchange.com/questions/648845/sans-serif-uppercase-greek-no-longer-showing-in-acmart
\DeclareMathAlphabet{\mathsf}{OT1}{LibertinusSans-LF}{m}{n}
\SetMathAlphabet{\mathsf}{bold}{OT1}{LibertinusSans-LF}{bx}{n}
\DeclareMathAlphabet{\mathtt}{OT1}{lmtt}{m}{n}
\SetMathAlphabet{\mathtt}{bold}{OT1}{lmtt}{bx}{n}

\input{cmds.tex}

\loadglsentries{acronyms}
\makeglossaries

\title{Secure Composition of Robust and Optimising Compilers}
\begin{document}

\maketitle

\begin{abstract}
% context
To ensure that secure applications do not leak their secrets, they are required to uphold several security properties such as spatial and temporal memory safety, cryptographic constant time, as well as speculative safety.
% need
Existing work shows how to enforce these properties individually, in an architecture-independent way, by using secure compiler passes that each focus on an individual property.
% task
Unfortunately, given two secure compiler passes that each preserve a possibly different security property, it is unclear what kind of security property is preserved by the composition of those secure compiler passes.
%there is no way to tell what kind of security property will the composition of those secure compilers preserve.

% object
This paper is the first to study what security properties are preserved across the composition of different secure compiler passes.
% findings
Starting from a general theory of property composition for security-relevant properties (such as the aforementioned ones), this paper formalises a theory of composition of secure compilers.
Then, it showcases this theory on a secure multi-pass compiler that preserves the aforementioned security-relevant properties.
% conclusion
Crucially, this paper derives the security of the multi-pass compiler from the composition of the security properties preserved by its individual passes, which include security-preserving as well as optimisation passes.
% 
From an engineering perspective, this is the desirable approach to building secure compilers.
\begin{center}\small\it
	{This paper uses syntax highlighting accessible to both colourblind and black \& white readers.}
\end{center}
\end{abstract}

\appendix

\section{Background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preliminaries}

\begin{definition}{\definitionlabel[Function Composition]{function-composition}}
  $\fncompo{f}{g}\isdef \lambda x.g(f\;x)$
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Satisfaction}
\bul{A whole program $\varWholeProg$ satisfies a property $\varProperty$} iff \iul{$\varWholeProg$ yields a trace $\varTrace$} such that \oul{$\varTrace$ satisfies $\varProperty$}.

\begin{definition}{\definitionlabel[Property Satisfaction]{prop-sat}}
    \bul{$\sat{\varWholeProg}{\varProperty}$}
    $\isdef$
    if \iul{$\forall\varRuntimeTerm\ \varTrace, %
      \progstepto{\varWholeProg}{\varRuntimeTerm}{\varTrace}$
    },
    then \oul{$\varTrace\in\varProperty$}.
\end{definition}

With this, \definitionref{prop-sat} can be extended as follows: for \bul{a component $\varComponent$ to robustly satisfy a property $\varProperty$}, take an \iul{attacker context $\varContext$ and link it with $\varComponent$}, \oul{the resulting whole program must satisfy $\varProperty$}.

\begin{definition}{\definitionlabel[Robust Property Satisfaction]{prop-rsat}}
  \bul{$\rsat{\varComponent}{\varProperty}$} %
  $\isdef$ %
  \iul{$\forall \varContext\ \varWholeProg$, %
    if $\bopLink{\varContext}{\varComponent} = \varWholeProg$}, %
    then \oul{$\sat{\varWholeProg}{\varProperty}$%
  }.
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Property Mappings}

This work relies on property mappings introduced in related work~\cite{abate2021extacc}.

\begin{definition}{\definitionlabel[Universal Image]{universal-image}}
  $ 
    \mapUniversal{\sim}{\trgProperty} := 
      \lrbraces{\srcTrace \mid %
        \forall \trgTrace\ldotp \text{if }\xrelTraces{\srcTrace}{\trgTrace}, \text{ then }%
        \trgTrace\in\trgProperty
      }
  $
\end{definition}
\begin{definition}{\definitionlabel[Existential Image]{existential-image}}
  $ 
    \mapExistential{\sim}{\srcProperty} := 
      \lrbraces{\trgTrace \mid %
        \exists \srcTrace\ldotp \xrelTraces{\srcTrace}{\trgTrace} \text{ and }%
        \srcTrace\in\srcProperty
      }
  $
\end{definition}

The lifting of \definitionref{existential-image} and \definitionref{universal-image} to classes of properties is standard, i.e., simply element-wise.

\begin{lemma}[\Coqed]{\lemmalabel[Trace Relation distributes on Universal Image]{xtrace-distribute-universal}}
  Let $X$ be either a trace-property or a class. Then:
  \begin{goals}
    \goal{xtrace-distribute-universal}{\mapUniversal{\fncompo{\sim_1}{\sim_2}}{X} = \mapUniversal{\sim_2}{\mapUniversal{\sim_1}{X}}}
  \end{goals}
\end{lemma}
\begin{proof}
  Straightforward unfolding of \definitionref{universal-image} and \definitionref{function-composition} in \goalref{xtrace-distribute-universal}.
\end{proof}
\begin{lemma}[\Coqed]{\lemmalabel[Trace Relation distributes on Existential Image]{xtrace-distribute-existential}}
  Let $X$ be either a trace-property or a class. Then:
  \begin{goals}
    \goal{xtrace-distribute-existential}{\mapExistential{\fncompo{\sim_1}{\sim_2}}{X} = \mapExistential{\sim_2}{\mapExistential{\sim_1}{X}}}
  \end{goals}
\end{lemma}
\begin{proof}
  Straightforward unfolding of \definitionref{existential-image} and \definitionref{function-composition} in \goalref{xtrace-distribute-existential}.
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Robust Preservation}

The following definitions for secure compilers are standard~\cite{abate2019jour,abate2021extacc}.

\subsubsection{Differing Trace Models}

A \bul{compiler $\ccST$ for languages $\src{S}$ and $\trg{T}$ robustly preserves a $\trg{T}$-level class $\trgClass$}, if for any \rul{property $\trgProperty$ of class $\trgClass$ and programs $\srcComponent$}, where \iul{$\srcComponent$ robustly satisfies $\mapUniversal{\sim}{\trgProperty}$}, \oul{the compilation of $\srcComponent$, we have that $\ccST\lrpars{\srcComponent}$ robustly satisfies $\trgProperty$}.

\begin{definition}{\definitionlabel[Robust Preservation with $\mapUniversal{\sim}{\cdot}$]{rtp-universal}}
  \begin{center}
    \bul{$\rtpUniversal{\ccST}{\trgClass}{\sim}$}
    %, iff 
    $\isdef$
    \rul{$\forall \trgProperty\in\trgClass, \srcComponent\in\src{S},$} %
    if \iul{$\rsat{\srcComponent}{\mapUniversal{\sim}{\trgProperty}}$},
    then \oul{$\rsat{\ccST\lrpars{\srcComponent}}{\trgProperty}$}.
  \end{center}
\end{definition}
A \bul{compiler $\ccST$ for languages $\src{S}$ and $\trg{T}$ robustly preserves a $\src{S}$-level class $\srcClass$}, if for any \rul{property $\srcProperty$ of class $\srcClass$ and programs $\srcComponent$}, where \iul{$\srcComponent$ robustly satisfies $\srcProperty$}, \oul{the compilation of $\srcComponent$, we have that $\ccST\lrpars{\srcComponent}$ robustly satisfies $\mapExistential{\sim}{\srcProperty}$}.

\begin{definition}{\definitionlabel[Robust Preservation with $\mapExistential{\sim}{\cdot}$]{rtp-existential}}
  \begin{center}
    \bul{$\rtpExistential{\ccST}{\srcClass}{\sim}$}
    %, iff 
    $\isdef$
    \rul{$\forall \srcProperty\in\srcClass, \srcComponent\in\src{S},$} %
    if \iul{$\rsat{\srcComponent}{\srcProperty}$},
    then \oul{$\rsat{\ccST\lrpars{\srcComponent}}{\mapExistential{\sim}{\srcProperty}}$}.
  \end{center}
\end{definition}

\subsubsection{Same Trace Models}

\begin{definition}{\definitionlabel[Robust Preservation]{rtp}}
  \begin{center}
    $\rtp{\ccST}{\varClass}$
    %, iff 
    $\isdef$
    $\forall \varProperty\in\varClass, \srcComponent\in\src{S},$ %
    if $\rsat{\srcComponent}{\varProperty}$,
    then $\rsat{\ccST\lrpars{\srcComponent}}{\varProperty}$.
  \end{center}
\end{definition}

\section{Composition of Secure Compilers}\label{sec:rtpc}

This section presents the composition framework.

\subsection{Same Trace Models}\label{subsec:rtpc-same-trace-models}

In the setting of same trace models, composition of secure compilers (as in \defref{rtp}) is simple:

\begin{lemma}[\Coqed]{\lemmalabel[Composition of RTP]{rtp-compo}}
  If 
  \begin{assumptions}
    \asm{rtp-compo-comp1}{\rtp{\ccSI}{\varClass[_1]}}
    \asm{rtp-compo-comp2}{\rtp{\ccIT}{\varClass[_2]}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-compo}{\rtp{\fncompo{\ccSI}{\ccIT}}{\varClass[_1]\cap\varClass[_2]}}
  \end{goals}
\end{lemma}
\begin{proof}
  \incompleteProof
\end{proof}
The following corollary is a nice consequence of \lemref{rtp-compo}.
\begin{corollary}[\Coqed]{\corollarylabel[Commutativity of RTP]{rtp-swappable}}
  If 
  \begin{assumptions}
    \asm{rtp-swappable-comp1}{\rtp{\ccII}{\varClass[_1]}}
    \asm{rtp-swappable-comp2}{\rtp{\ccII[\delta]}{\varClass[_2]}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-swappable1}{\rtp{\fncompo{\ccII}{\ccII[\delta]}}{\varClass[_1]\cap\varClass[_2]}}
    \goal{rtp-swappable2}{\rtp{\fncompo{\ccII[\delta]}{\ccII}}{\varClass[_1]\cap\varClass[_2]}}
  \end{goals}
\end{corollary}
\begin{proof}
  \goalref{rtp-swappable1} and \goalref{rtp-swappable2} are an immediate consequence based on \lemmaref{rtp-compo} with \asmref{rtp-swappable-comp1} and \asmref{rtp-swappable-comp2}, noting the commutativity of set intersection.
\end{proof}

\subsection{Different Trace Models}\label{subsec:rtpc-different-trace-models}

The situation in \Cref{subsec:rtpc-same-trace-models} is idealistic in the sense that a somewhat realistic robustly preserving compiler will likely have to insert checks for when control switches from context to component.
For example, compiling from a statically typed language into a dynamically typed one, where the static language enforces functions to only accept numbers, the compiler has to insert appropriate checks to make sure that well-typedness is robustly preserved.
Without such checks, a context could simply supply, e.g., a pair, violating the contract that a function can only receive numbers.

These checks yield a mismatch between the source-level trace and the target-level trace, rendering \definitionref{rtp} not provable.
Instead, one would have to use \definitionref{rtp-universal} or \definitionref{rtp-existential} and use an appropriate, cross-language trace relation that precisely describes the semantic effect on traces when compiling.
For the type-checking function interfaces example, parts of this cross-language trace relation may be sketched as:

\begin{center}
  \typerule{ex-rel-interfaces-agree}{
    \trg{v}\text{ is a number} \rulesep
    \src{v}\approx\trg{v}
  }{
    \xrelTraces{\src{Call\;\ctxtocomp\;v}}{\trg{Call\;\ctxtocomp\;v}}
  }{ex-rel-interfaces-agree}
  \typerule{ex-rel-interfaces-disagree}{
    \trg{v}\text{ not a number}
  }{
    \xrelTraces{\src{Abort}}{\trg{Call\;\ctxtocomp\;v}\cdot\trg{Abort}}
  }{ex-rel-interfaces-disagree}
\end{center}
\trref{ex-rel-interfaces-agree} ensures that both in the source and target-level execution, when the context calls into the component, the values agree and are numerical.

\trref{ex-rel-interfaces-disagree} handles the case where the target-level context supplied a $\trg{v}$ that is not a number.
Here, the backtranslation cannot construct a context that gives a well-typed program {\em and} produces the same trace as the target, since the behavior is ill-defined to begin with.
So, the only option for the backtranslation is to immediately crash.
This, however, is a mismatch with the target-level trace, which only aborts in the wrapper that the compiler inserted.

\begin{lemma}[\Coqed]{\lemmalabel[Composition of RTP-Universal]{rtp-universal-compo}}
  If 
  \begin{assumptions}
    \asm{rtp-universal-compo-comp1}{\rtpUniversal{\ccSI}{\mapUniversal{\sim_2}{\trgClass[_1]}}{\sim_1}}
    \asm{rtp-universal-compo-comp2}{\rtpUniversal{\ccIT}{\trgClass[_2]}{\sim_2}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-universal-compo}{\rtpUniversal{\fncompo{\ccSI}{\ccIT}}{\trgClass[_1]\cap\trgClass[_2]}{\fncompo{\sim_1}{\sim_2}}}
  \end{goals}
\end{lemma}
\begin{proof}
  \incompleteProof
\end{proof}

\begin{lemma}[\Coqed]{\lemmalabel[Composition of RTP-Existential]{rtp-existential-compo}}
  If 
  \begin{assumptions}
    \asm{rtp-existential-compo-comp1}{\rtpExistential{\ccSI}{\srcClass[_1]}{\sim_1}}
    \asm{rtp-existential-compo-comp2}{\rtpExistential{\ccIT}{\mapExistential{\sim_1}{\srcClass[_2]}}{\sim_2}}
  \end{assumptions}
  then
  \begin{goals}
    \goal{rtp-existential-compo}{\rtpExistential{\fncompo{\ccSI}{\ccIT}}{\srcClass[_1]\cap\srcClass[_2]}{\fncompo{\sim_1}{\sim_2}}}
  \end{goals}
\end{lemma}
\begin{proof}
  \incompleteProof
\end{proof}

While compiler passes can be incompatible with each other in the sense that the resulting, mapped property is useless/not what is desired, it is enough to reason about compatibility of compilers at the level of traces.
This is what this work refers to as ,,semantic effect of a compiler''.
Instead of having to do syntactic arguments for the interaction of several compilation passes, one only has to do them for the semantic notion, i.e., the cross-language trace relations, which are much simpler proofs by an order of magnitude. 
\MKin{
  cite section backing up this claim 
}

%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
\section{Case Study}

\clearpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\printglossary

\end{document}
\endinput
